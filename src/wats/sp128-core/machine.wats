// ============================================================================
// ZX Spectrum 128K machine-specific routines
// ============================================================================

// ----------------------------------------------------------------------------
// Virtual machine memory map:

// Block 00: 0x00'0000 - 0x00'1fff (ROM 0, lower 8K)
// Block 01: 0x00'2000 - 0x00'3fff (ROM 0, upper 8K)
// Block 02: 0x00'4000 - 0x00'5fff (ROM 1, lower 8K)
// Block 03: 0x00'6000 - 0x00'7fff (ROM 1, upper 8K)
// Block 04: 0x00'8000 - 0x00'9fff (BANK 0, lower 8K)
// Block 05: 0x00'a000 - 0x00'bfff (BANK 0, upper 8K)
// Block 06: 0x00'c000 - 0x00'dfff (BANK 1, lower 8K, contended)
// Block 07: 0x00'e000 - 0x00'ffff (BANK 1, upper 8K, contended)
// Block 08: 0x01'0000 - 0x01'1fff (BANK 2, lower 8K)
// Block 09: 0x01'2000 - 0x01'3fff (BANK 2, upper 8K)
// Block 10: 0x01'4000 - 0x01'5fff (BANK 3, lower 8K, contended)
// Block 11: 0x01'6000 - 0x00'7fff (BANK 3, upper 8K, contended)
// Block 12: 0x01'8000 - 0x01'9fff (BANK 4, lower 8K)
// Block 13: 0x01'a000 - 0x01'bfff (BANK 4, upper 8K)
// Block 14: 0x01'c000 - 0x01'dfff (BANK 5, lower 8K, contended)
// Block 15: 0x01'e000 - 0x00'ffff (BANK 5, upper 8K, contended)
// Block 16: 0x02'0000 - 0x02'1fff (BANK 6, lower 8K)
// Block 17: 0x02'2000 - 0x02'3fff (BANK 6, upper 8K)
// Block 18: 0x02'4000 - 0x02'5fff (BANK 7, lower 8K, contended)
// Block 19: 0x02'6000 - 0x02'7fff (BANK 7, upper 8K, contended)

// Unused: 0x02'8000 - 0xff'ffff

// --- ZX Spectrum 128 virtual memory offsets
const u32 ROM_0_OFFSET = 0x00'0000;
const u32 ROM_1_OFFSET = 0x00'4000;
const u32 BANK_0_OFFSET = 0x00'8000;
const u32 BANK_5_OFFSET = 0x01'c000;
const u32 BANK_7_OFFSET = 0x02'4000;

// ----------------------------------------------------------------------------
// Public routines

// Sets up the ZX Spectrum machine
export void setupMachine () {
  // --- Let's use ULA issue 3 by default
  ulaIssue = 3;

  // --- CPU configuration
  baseClockFrequency = 3'546'900;
  clockMultiplier = defaultClockMultiplier;
  resetCpu(true);
  
  // --- Memory configuration
  numberOfRoms = 2;
  ramBanks = 8;
  memoryScreenOffset = 0x01'c000; // BANK 5

  // --- Set up block lookup table
  setMemoryBlockEntry(0, 0x00'0000, false, true);   // ROM 0, lower
  setMemoryBlockEntry(1, 0x00'2000, false, true);   // ROM 0, upper
  setMemoryBlockEntry(2, 0x01'c000, true, false);   // BANK 5, lower, contended
  setMemoryBlockEntry(3, 0x01'e000, true, false);   // BANK 5, upper, contended
  setMemoryBlockEntry(4, 0x01'0000, false, false);  // BANK 2, lower
  setMemoryBlockEntry(5, 0x01'2000, false, false);  // BANK 2, upper
  setMemoryBlockEntry(6, 0x00'8000, false, false);  // BANK 0, lower
  setMemoryBlockEntry(7, 0x00'a000, false, false);  // BANK 0, upper

  // --- Rom configuration
  memorySelectedRom = 0;
  spectrumRomIndex = 1;

  // --- Set the initial state of a ZX Spectrum machine
  resetMachine();

  // --- Screen frame configuration
  setInterruptTact(0);
  verticalSyncLines = 8;
  nonVisibleBorderTopLines = 7;
  borderTopLines = 48;
  borderBottomLines = 48;
  nonVisibleBorderBottomLines = 8;
  displayLines = 192;
  borderLeftTime = 24;
  borderRightTime = 24;
  displayLineTime = 128;
  horizontalBlankingTime = 40;
  nonVisibleBorderRightTime = 12;
  pixelDataPrefetchTime = 2;
  attributeDataPrefetchTime = 1;

  calcScreenAttributes();
  initRenderingTactTable();

  // --- Tape device data
  tapeLoadBytesRoutine = 0x056c;
  tapeLoadBytesInvalidHeader = 0x056b;
  tapeLoadBytesResume = 0x05e2;
  tapeSaveBytesRoutine = 0x04c2;

  // --- Setup the PSG sound
  initEnvelopeTables();
  initSound(&psg);
  psgRegisterIndex = 0;

  psgNextClockTact = 0;
  psgOrphanSamples =0;
  psgOrphanSum = 0;
}

// ----------------------------------------------------------------------------
// I/O port handling

// Reads a byte from the specified I/O port
u8 readPort(u16 port) {
  // --- Handle the contention delay
  applyIOContentionDelay(port);

  // --- Handle the 0xfe port
  if (!(port & 0x0001)) {
    local u8 value = readPortFE(port);
    return value;
  }

  // --- Handle the Kempston port
  if (!(port & 0x00e0)) {
    // TODO: Implement Kempston port handling
    return 0xff;
  }
  
  // --- Handle the PSG register index port
  if ((port & 0xc002) == 0xc000) {
    return readPsgRegisterValue(&psg);
  }

  // --- Floating port handling
  // --- Get the rendering table entry of the current ULA tact
  local *renderingTactEntry tactItem = &(renderingTactTable[(tacts-3)/clockMultiplier]);
  local u8 phase = (*tactItem).phase;

  if (phase == 2) {
    return vmMemory[memoryScreenOffset + (*tactItem).pixelAddress];
  } else if (phase == 3) {
    return vmMemory[memoryScreenOffset + (*tactItem).attrAddress];
  } else if (phase == 5) {
    return vmMemory[memoryScreenOffset + (*tactItem).pixelAddress];
  } else if (phase == 6) {
    return vmMemory[memoryScreenOffset + (*tactItem).attrAddress];
  } else if (phase == 8) {
    return vmMemory[memoryScreenOffset + (*tactItem).pixelAddress];
  } else if (phase == 9) {
    return vmMemory[memoryScreenOffset + (*tactItem).attrAddress];
  }

  // --- Return the default port value
  return 0xff;
}

// Writes a byte to the specified I/O port
void writePort(u16 port, u8 value) {
  applyIOContentionDelay(port);

  // --- Standard ZX Spectrum port
  if (!(port & 0x0001)) {
    writePortFE(port, value);
    return;
  }

  // --- Test for memory paging port
  if ((port & 0xc002) == 0x4000) {
    handleMemoryPagingPort(value);
    return;
  }

  // --- Test for PSG register index port
  if ((port & 0xc002) == 0xc000) {
    psgRegisterIndex = value & 0x0f;
    return;
  }

  // --- Test for PSG register value port
  if ((port & 0xc002) == 0x8000) {
    writePsgRegisterValue(&psg, value);
  }
}

// ----------------------------------------------------------------------------
// Screen rendering table

// Initializes the table used for screen rendering
export void initRenderingTactTable() {

  // Calculate the first and last visible lines
  local u32 firstVisibleLine = verticalSyncLines + nonVisibleBorderTopLines;
  local u32 lastVisibleLine = rasterLines - nonVisibleBorderBottomLines;
  local u32 firstVisibleBorderTact = screenLineTime - borderLeftTime;

  // Calculate the last visible line tact
  local u32 lastVisibleLineTact = displayLineTime + borderRightTime;

  // Calculate border pixel and attribute fetch tacts
  local u32 borderPixelFetchTact = screenLineTime - pixelDataPrefetchTime;
  local u32 borderAttrFetchTact = screenLineTime - attributeDataPrefetchTime;

  // Init the loop over tacts
  local *renderingTactEntry tablePtr = &renderingTactTable;
  local *u8 contentionPtr = &contentionTable;
  local u32 tact = 0;

  while (tact < tactsInFrame) {
    // --- Init the current tact
    local u32 phase = RT_NONE;
    local u32 contentionDelay = 0;
    local u32 pixelAddr = 0;
    local u32 attrAddr = 0;

    // --- Calculate line and tact in line
    local u32 line = tact/screenLineTime;
    local u32 tactInLine = tact % screenLineTime;

    // Test, if the current tact is visible
    if (
      (line >= firstVisibleLine) & 
      (line < lastVisibleLine) & 
      (tactInLine < lastVisibleLineTact | tactInLine >= firstVisibleBorderTact)
    ) {
      // --- Yes, the tact is visible.
      // --- Is it the first pixel/attr prefetch?
      local bool calculated = false;
      if (line == firstDisplayLine - 1) {
        if (tactInLine == borderPixelFetchTact - 1) {
          phase = RT_Border;
          contentionDelay = 6;
          calculated = true;
        } else if (tactInLine == borderPixelFetchTact) {
          // --- Yes, prefetch pixel data
          phase = RT_BorderFetchPixel;
          pixelAddr = calcPixelAddress(line + 1, 0);
          contentionDelay = 5;
          calculated = true;
        } else if (tactInLine == borderAttrFetchTact) {
          phase = RT_BorderFetchAttr;
          attrAddr = calcAttrAddress(line + 1, 0);
          contentionDelay = 4;
          calculated = true;
        }
      } 

      // --- Test, if it is in the display area
      if (!calculated) {
        if (
          (line >= firstDisplayLine) &
          (line <= lastDisplayLine) &
          (tactInLine < displayLineTime)
        ) {
          // --- Yes, it is the display area
          // --- Carry out actions according to pixel tact
          local u32 pixelTact = tactInLine & 0x07;
          if (!pixelTact) {
            phase = RT_DisplayB1FetchB2;
            pixelAddr = calcPixelAddress(line, tactInLine + 4);
            contentionDelay = 3;
          } else if (pixelTact == 1) {
            phase = RT_DisplayB1FetchA2;
            attrAddr = calcAttrAddress(line, tactInLine + 3);
            contentionDelay = 2;
          } else if (pixelTact == 2) {
            phase = RT_DisplayB1;
            contentionDelay = 1;
          } else if (pixelTact == 3) {
            phase = RT_DisplayB1;
            contentionDelay = 0;
          } else if (pixelTact == 4) {
            phase = RT_DisplayB2;
            contentionDelay = 0;
          } else if (pixelTact == 5) {
            phase = RT_DisplayB2;
            contentionDelay = 6;
          } else if (pixelTact == 6) {
            // --- Test, if there are more pixels to display in this line
            if (tactInLine < (displayLineTime - pixelDataPrefetchTime)) {
              // --- Yes, there are still more bytes
              phase = RT_DisplayB2FetchB1;
              pixelAddr = calcPixelAddress(line, tactInLine + pixelDataPrefetchTime);
              contentionDelay = 5;
            } else {
              // --- Last byte in this line
              phase = RT_DisplayB2;
            }
          } else {
            // --- Pixel tact 7
            // --- Test, if there are more pixels to display in this line
            if (tactInLine < (displayLineTime - attributeDataPrefetchTime)) {
              // --- Yes, there are still more bytes
              phase = RT_DisplayB2FetchA1;
              attrAddr = calcAttrAddress(line, tactInLine + attributeDataPrefetchTime);
              contentionDelay = 4;
            }
            else {
              // --- Last byte in this line
              phase = RT_DisplayB2;
            }
          }
        } else {
          // --- No, it is the border area
          phase = RT_Border;
          
          // --- Left or right border?
          if (line >= firstDisplayLine) {
            if (line <= lastDisplayLine) {
              // -- Yes, it is left or right border
              // --- Is it pixel data prefetch time?
              if (tactInLine == borderPixelFetchTact) {
                // --- Yes, prefetch pixel data
                phase = RT_BorderFetchPixel;
                pixelAddr = calcPixelAddress(line + 1, 0);
                contentionDelay = 0;
              } else if (tactInLine == borderAttrFetchTact) {
                phase = RT_BorderFetchAttr;
                attrAddr = calcAttrAddress(line + 1, 0);
                contentionDelay = 6;
              }
            }
          } 
        }
      }
    }

    // --- Store the current rendering item
    (*tablePtr).phase = phase;
    (*tablePtr).pixelAddress = pixelAddr;
    (*tablePtr).attrAddress = attrAddr;
    *contentionPtr = contentionDelay;

    if (tact >= 14350 & tact <= 14400) {
      trace(333333);
      trace(tact);
      trace(contentionDelay);
    }

    // --- Move to the next table item
    tablePtr += 1;
    contentionPtr += 1;
    tact += 1;
  }

  // Add extra (non-rendering) tacts to protect frame overflow
  line = 100;
  while (line) {
    (*tablePtr).phase = RT_NONE;
    (*tablePtr).pixelAddress = 0;
    (*tablePtr).attrAddress = 0;
    tablePtr += 1;
    line -= 1;
  }
}
