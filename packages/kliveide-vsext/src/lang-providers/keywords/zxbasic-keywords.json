[{
        "keyword": "ABS",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nABS(numericExpression)\n\u0060\u0060\u0060\n\n\n**Description**\n\nReturns the absolute value of the given argument.\nArgument must be a numeric expression. Returned value has the same type as the input argument.\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Absolute value\nLET a = -1\nPRINT \u0022Absolute value of a is \u0022; ABS(a)\nREM \u0027Will print 1\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/abs.md"
    },
    {
        "keyword": "ACS",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nACS(numericExpression)\n\u0060\u0060\u0060\n \n\n**Description**\n\nReturns the arc cosine value of the given argument.\nArgument must be a numeric expression. Returned value type is [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Arc cosine value\nPRINT \u0022Arc Cosine value of a is \u0022; ACS(a)\n\u0060\u0060\u0060\n \n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n* If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n\n**See also**\n\n* [SIN](sin.md) and [ASN](https://github.com/boriel/zxbasic/blob/master/docs/asn.md)\n* [TAN](tan.md) and [ATN](https://github.com/boriel/zxbasic/blob/master/docs/atn.md)\n* [COS](https://github.com/boriel/zxbasic/blob/master/docs/cos.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/acs.md"
    },
    {
        "keyword": "ALIGN",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/align.md"
    },
    {
        "keyword": "ASM",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nasm\n  (z80 assembler code)\n  ...\nend asm\n\u0060\u0060\u0060\n\n**Description**\n\nStarts immediate inline assembly context using standard z80 opcodes.\nUse with caution.\n\n**Examples**\n\n\u0060\u0060\u0060\nFUNCTION FASTCALL whatLetter (A as uByte) as uByte\n   Asm\n             JP START\n   DATA:     DEFB \u0022A Man, A Plan, A Canal, Panama\u0022\n   START:    LD HL,DATA\n             LD E, A\n             LD D, 0\n             ADD HL, DE\n             LD A, (HL)\n   End Asm\nEND FUNCTION\n\u0060\u0060\u0060\n\n\nThe above function, when called with \u0060whatLetter(\u003Cvalue\u003E)\u0060 will return the \u0060\u003Cvalue\u003E\u0060-th letter of the phrase\n\u0060\u0022A Man, A Plan, A Canal, Panama\u0022\u0060.\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/asm.md"
    },
    {
        "keyword": "ASN",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nASN(numericExpression)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the arc sine value of the given argument.\nArgument must be a numeric expression. Returned value type is [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Arc sine value\nPRINT \u0022Arc Sine value of a is \u0022; ASN(a)\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n*  This function is 100% Sinclair BASIC Compatible\n*  If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n\n**See also**\n\n* [COS](cos.md) and [ACS](https://github.com/boriel/zxbasic/blob/master/docs/acs.md)\n* [TAN](tan.md) and [ATN](https://github.com/boriel/zxbasic/blob/master/docs/atn.md)\n* [SIN](https://github.com/boriel/zxbasic/blob/master/docs/sin.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/asn.md"
    },
    {
        "keyword": "AT",
        "description": "**Description**\n\n**AT** is not a statement, but a _modifier_.\nIt can be used both as a [PRINT modifier](print#modifiers.md) and a [variable declaration modifier](https://github.com/boriel/zxbasic/blob/master/docs/dim.md).\n\n**Remarks**\n\n* This identifier is compatible with Sinclair BASIC (see [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)), but _expands_ it, since it allows positioning at rows 22 and 23 (all 24 rows are available to the programmer). Traditionally, Sinclair BASIC only allows to print at rows 0..21.\n* This identifier _expands_ the Sinclair BASIC version when used with [DIM](https://github.com/boriel/zxbasic/blob/master/docs/dim.md)\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [DIM](https://github.com/boriel/zxbasic/blob/master/docs/dim.md) - Variable Declarations\n* [POS](https://github.com/boriel/zxbasic/blob/master/docs/library/pos.md)\n* [CSRLIN](https://github.com/boriel/zxbasic/blob/master/docs/library/csrlin.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/at.md"
    },
    {
        "keyword": "ATN",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nATN(numericExpression)\n\u0060\u0060\u0060\n \n\n**Description**\n\nReturns the arc tangent value of the given argument.\nArgument must be a numeric expression. Returned value type is [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Arc tangent value\nPRINT \u0022Arc Tangent value of a is \u0022; ATN(a)\n\u0060\u0060\u0060\n\n**Remarks**\n\n*  This function is 100% Sinclair BASIC Compatible\n*  If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n\n**See also**\n\n* [COS](acs.md) and [ACS](https://github.com/boriel/zxbasic/blob/master/docs/asn.md)\n* [SIN](sin.md) and [ASN](https://github.com/boriel/zxbasic/blob/master/docs/asn.md)\n* [TAN](https://github.com/boriel/zxbasic/blob/master/docs/tan.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/atn.md"
    },
    {
        "keyword": "BEEP",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nBEEP \u003Cduration\u003E,\u003Cpitch\u003E\n\u0060\u0060\u0060\n\n**Description**\n\nEmits a sound using the ZX Spectrum speaker. The \u0027\u0027duration\u0027\u0027 is given in seconds, and the \u0027\u0027pitch\u0027\u0027 is given in semitones above middle C using negative numbers for notes below middle C.\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n\n**See also**\n\n* Example of using BEEP: [FrereGustav.bas](https://github.com/boriel/zxbasic/blob/master/docs/examples/freregustav.bas.md)\n\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/beep.md"
    },
    {
        "keyword": "BOLD",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nBOLD \u003Cvalue\u003E \n\u0060\u0060\u0060\nor\n\n\u0060\u0060\u0060\nPRINT BOLD \u003Cvalue\u003E;\n\u0060\u0060\u0060\n\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\n\n\u0060\u0060\u0060\nBOLD n\n\u0060\u0060\u0060\nwhere n is either 0 (false) or 1 (true), then the subsequent print statements will have their INK pixels emphasized,\nmaking text appear bolder.\n\nThis command can be used as temporary colours by combining them with a print statement:\n\n\n\u0060\u0060\u0060\nPrint INK 0;PAPER 7; BOLD 1; \u0022This is BOLD BLACK text on WHITE\u0022\n\u0060\u0060\u0060\n\nThis version does not change the permanent colour settings and only affects\nthe characters printed within that print statement.\n\n**Remarks**\n\n* This statement is NOT Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/bold.md"
    },
    {
        "keyword": "BORDER",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nBORDER \u003Cvalue\u003E \n\u0060\u0060\u0060\nThis can be used to change the border colour.\n\n\u0060\u0060\u0060\nBORDER n\n\u0060\u0060\u0060\nwhere n is a number between 0 and 7.\n\n\nAs the ZX Spectrum manual states:\n\n\u0060\u0060\u0060\n0 - black\n1 - blue\n2 - red\n3 - purple, technically called magenta\n4 - green\n5 - pale blue, technically called cyan\n6 - yellow\n7 - white\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/border.md"
    },
    {
        "keyword": "BRIGHT",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nBRIGHT \u003Cvalue\u003E\n\u0060\u0060\u0060\nor\n\u0060\u0060\u0060\nPRINT BRIGHT \u003Cvalue\u003E;\n\u0060\u0060\u0060\nThis can be used to change the permanent print settings, or the temporary ones.\nWhen used as a direct command:\n\n\u0060\u0060\u0060\nBRIGHT n\n\u0060\u0060\u0060\nwhere n is either 0 (false) or 1 (true), then the subsequent print statements will have both their \u0060INK\u0060 and \u0060PAPER\u0060\nvalues set to the higher intensity \u0060BRIGHT\u0060 mode.\n\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\n\n\n\u0060\u0060\u0060\nPrint INK 0;PAPER 7; BRIGHT 1; \u0022This is BLACK text on BRIGHT WHITE background\u0022\n\u0060\u0060\u0060\n\nNote that the BRIGHT black and standard black are identical.\n\nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\n\n**Remarks**\n\n* This statement is 100% Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [FLASH](https://github.com/boriel/zxbasic/blob/master/docs/flash.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/bright.md"
    },
    {
        "keyword": "BYREF",
        "description": "\u0060ByRef\u0060 is a modifier used in function parameters to specify that the parameters is passed by reference (that is, \nthe original variable is passed to the [FUNCTION](function.md) or [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)).\n\n**Syntax**\n\nIt\u0027s used in function parameter declaration as in this example:\n\n\u0060\u0060\u0060\nFUNCTION plusOne(ByRef a As Ubyte) As UByte\n  LET a = a \u002B 1\n  RETURN a\nEND FUNCTION\nLET a = 0\nPRINT plusOne(a): REM prints 1\nPRINT a: REM prints 1; original value of A has been *modified* within the function\n\u0060\u0060\u0060\n \nHere the variable \u0060a\u0060 is being modified within the function, and this modification persist upon return.\nExcept for arrays, when \u0060ByRef\u0060 or [ByVAL](byval.md) is not specified in [FUNCTION](function.md) or [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\nparameters, [ByVAL](https://github.com/boriel/zxbasic/blob/master/docs/byval.md) will be used by default. On the other hand, if the parameter is an array,\nand no access is specified, it\u0027s supposed to be \u0060ByRef\u0060 (arrays cannot be passed by value).\n\nByRef allows us to pass arrays to [FUNCTION](function.md) or [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md):\n\n\u0060\u0060\u0060\nREM arrays passed to functions can be of *any dimensions*.\nREM Use LBOUND and UBOUND to detect dimensions!\nFUNCTION maxValue(ByRef a() as Ubyte) As UByte\n  DIM i as UInteger\n  DIM result As UByte = 0 \n  FOR i = LBOUND(a, 1) TO UBOUND(a, 1)\n    IF a(i) \u003E result THEN result = a(i)\n  NEXT i\n  RETURN result\nEND FUNCTION\nDIM myArray(4) As UByte = {4, 3, 1, 2, 5}\nPRINT \u0022Max value is \u0022; maxValue(myArray)\n\u0060\u0060\u0060\n\nWhen passing arrays like in this example, if \u0060ByRef\u0060 can be omitted.\nArrays parameters cannot be passed to a function using [ByVAL](https://github.com/boriel/zxbasic/blob/master/docs/byval.md).\n\n\u0060ByRef\u0060 is also useful to return values in the parameters. [RETURN](https://github.com/boriel/zxbasic/blob/master/docs/return.md) allows to return a single value\nfrom a [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md), but we can return several values by storing the result in those parameters.\n\n\u0060ByRef\u0060 requires the parameter to be an _lvalue_, that is, a variable, an array or an array cell. You cannot use\n\u0060ByRef\u0060 with expressions (i.e. numbers) because you cannot store a value in them.\n\nExample of wrong usage:\n\n\u0060\u0060\u0060\nFUNCTION plusOne(ByRef a As Ubyte) As UByte\n  LET a = a \u002B 1\n  RETURN a\nEND FUNCTION\n\nDIM i as UByte = 7\nDIM myArray(5) as Ubyte\nPRINT plusOne(5): REM syntax error, 5 is not a variable or an array element.\nPRINT plusOne(i): REM Ok. Will change i value to 8, and print 8)\nPRINT plusOne(i \u002B 1): REM syntax error, i \u002B 1 is not a variable\nPRINT plusOne(myArray(3)): REM Ok. Will increase myArray(3) by 1 and print the result\n\u0060\u0060\u0060\n\nSee also:\n\n* [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md)\n* [RETURN](https://github.com/boriel/zxbasic/blob/master/docs/return.md)\n* [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\n* [ByVAL](https://github.com/boriel/zxbasic/blob/master/docs/byval.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/byref.md"
    },
    {
        "keyword": "BYVAL",
        "description": "\u0060ByVal\u0060 is a modifier used in function parameters to specify that the parameters is passed by value (that is, \na copy of the value is passed to the [FUNCTION](function.md) or [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)).\n\n**Syntax**\n\nIt\u0027s used in function parameter declaration as in this example:\n\n\u0060\u0060\u0060\nFUNCTION plusOne(ByVal a As Ubyte) As UByte\n  LET a = a \u002B 1\n  RETURN a\nEND FUNCTION\nLET a = 0\nPRINT plusOne(a): REM prints 1\nPRINT a: REM prints 0; original value of A is preserved\n\u0060\u0060\u0060\n \nHere the variable \u0060a\u0060 is being modified within the function, but the original value is preserved upon return.\nExcept for arrays, when [ByREF](byref.md) or \u0060ByVal\u0060 is not specified in [FUNCTION](function.md) or [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\nparameters, \u0060ByVal\u0060 will be used by default. On the other hand, if the parameter is an array, and no access is \nspecified, it\u0027s supposed to be [ByREF](https://github.com/boriel/zxbasic/blob/master/docs/byref.md) (arrays cannot be passed by value).\n\nSee also:\n\n* [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md)\n* [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\n* [ByREF](https://github.com/boriel/zxbasic/blob/master/docs/byref.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/byval.md"
    },
    {
        "keyword": "CAST",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nCAST (type,numeric value)\nCAST (type,variable)\nCAST (type,function(data))\n\u0060\u0060\u0060\n\n**Description**\n\nReturns a value of the [type](https://github.com/boriel/zxbasic/blob/master/docs/types.md) specified with a value equivalent to the item specified, if that is possible.\n\n**Remarks**\n\n* This function can lose precision if used indiscriminately.\nFor example, CAST(Integer,PI) returns 3, losing precision on the value of PI.\n* This function is NOT Sinclair Compatible.\n\n**See also**\n\n* [Types](https://github.com/boriel/zxbasic/blob/master/docs/types.md)\n\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/cast.md"
    },
    {
        "keyword": "CHR",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nchr(\u003Cvalue\u003E)\nchr(\u003Cvalue1\u003E[, \u003CvalueN\u003E])\nchr$(\u003Cvalue\u003E)\nchr$(\u003Cvalue1\u003E[, \u003CvalueN\u003E])\n\u0060\u0060\u0060\n\n**Description**\n\nReturns a string containing the ASCII characters whose codes are the given values.\nThe arguments must be a numeric expression and, unlike Sinclair BASIC, parenthesis\nare mandatory. Returned value type is [string](https://github.com/boriel/zxbasic/blob/master/docs/types.md#String).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Char for ASCII code 65 is \u0027A\u0027\nPRINT \u0022CHR(65) is \u0022; CHR(65)\n\u0060\u0060\u0060\n \nThis function is extended, and several values can be given at once. The result is a concatenation of all the given values:\n\n\u0060\u0060\u0060\nREM Chars for ASCII codes from 65 to 67 (\u0027A\u0027 to \u0027C\u0027)\nPRINT \u0022CHR(65, 66, 67) is \u0022; CHR(65, 66, 67)\n\u0060\u0060\u0060\n\nThe following lines are both equivalent, but the 2\u003Csup\u003End\u003C/sup\u003E is faster and takes less memory:\n\n\n\u0060\u0060\u0060\nREM These two sentences are equivalent\nPRINT \u0022CHR(65, 66, 67) is \u0022; CHR(65) \u002B CHR(66) \u002B CHR(67)\nPRINT \u0022CHR(65, 66, 67) is \u0022; CHR(65, 66, 67)\n\u0060\u0060\u0060\n \n\nIn fact, if the compiler detects the programmer is using \u0060CHR(x) \u002B CHR(y)\u0060, it might compile it as\n\u0060CHR(x, y)\u0060 to perform such optimization.\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible, but parenthesis are mandatory\n* This function is expanded comparing to the original Sinclair BASIC\n* As with other functions and variables, the trailing \u0060$\u0060 can be omitted.\n\n**See Also**\n\n* [CODE](https://github.com/boriel/zxbasic/blob/master/docs/code.md)\n* [STR](https://github.com/boriel/zxbasic/blob/master/docs/str.md)\n* [VAL](https://github.com/boriel/zxbasic/blob/master/docs/val.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/chr.md"
    },
    {
        "keyword": "CIRCLE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nCIRCLE \u003Cx\u003E, \u003Cy\u003E, \u003Cradius\u003E\nCIRCLE \u003CAttribute Modifiers\u003E; \u003Cx\u003E, \u003Cy\u003E, \u003Cradius\u003E\n\u0060\u0060\u0060\n\n\n**Description**\n\nDraws a _circle_ centered on coordinates (x, y) (see [PLOT](https://github.com/boriel/zxbasic/blob/master/docs/plot.md)) with the given radius. Coordinate (0, 0) designates bottom-left screen corner. Drawing coordinates are updated to the last plotted position.\n\n**CIRCLE** is enhanced in ZX BASIC to allow drawing on the last two screen rows (this was not possible in Sinclair BASIC). So now we have 16 lines more (192 in total). Sinclair BASIC only used top 176 scan lines. This means if in Sinclair BASIC you write:\n\n\n\u0060\u0060\u0060\nCIRCLE x, y, r\n\u0060\u0060\u0060\n\n\nYou must translate it to ZX BASIC as:\n\n\n\u0060\u0060\u0060\nCIRCLE x, y \u002B 16, r\n\u0060\u0060\u0060\n\n\nIf you want both drawings to show at exactly the same vertical screen position.\n\nAlso maximum circle radius size is 96, not 86.\n\n*Remarks*\n\n* This function is not strictly Sinclair BASIC compatible since it uses all 192 screen lines instead of top 176. If you translate **PLOT**, **DRAW** \u0026  **CIRCLE**, commands from Sinclair BASIC _as is_ your drawing will be _shifted down_ 16 pixels.\n* This primitive uses Bresenham\u0027s algorithm for faster drawing instead of ROMs implementation.\n\n*See also*\n\n* [PLOT](https://github.com/boriel/zxbasic/blob/master/docs/plot.md)\n* [DRAW](https://github.com/boriel/zxbasic/blob/master/docs/draw.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/circle.md"
    },
    {
        "keyword": "CLS",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n CLS\n\u0060\u0060\u0060\n\n**Description**\n\n\u0060CLS\u0060 is short for *CLear Screen*, and will do just that: it will clear the screen, setting the background\nwith the current [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md) color, and placing the Screen Cursor at (0, 0) - screen top-leftmost corner.\n\n\n**Examples**\n\n\u0060\u0060\u0060\nREM sets the screen black, and INK white\nBORDER 0: PAPER 0: INK 7\nCLS\nPRINT \u0022White text on black background\u0022\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This sentence is compatible with Sinclair BASIC \n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [AT](https://github.com/boriel/zxbasic/blob/master/docs/at.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/cls.md"
    },
    {
        "keyword": "CODE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\ncode(\u003Cvalue\u003E)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the ASCII code of the first character of the given string value.\nIf the string is empty, the returned value is 0.\nReturned value type is [UByte](https://github.com/boriel/zxbasic/blob/master/docs/types.md#UByte).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM ASCII CODE of \u0022A\u0022\nPRINT \u0022ASCII CODE of A is \u0022; CODE(\u0022A\u0022)\nLET a$ = \u0022\u0022\nPRINT \u0022ASCII CODE of emtpy string is \u0022; CODE(a$)\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n\n**See Also**\n\n* [CHR](https://github.com/boriel/zxbasic/blob/master/docs/chr.md)\n* [STR](https://github.com/boriel/zxbasic/blob/master/docs/str.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/code.md"
    },
    {
        "keyword": "CONST",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nCONST \u003Cvarname\u003E [AS \u003Ctype\u003E] = \u003Cvalue\u003E\n\u0060\u0060\u0060\n\n\n**Description**\n\n**CONST** declares a non-modifable variable.\n\n\u0060\u003Ctype\u003E\u0060 can be something like \u0060Integer\u0060, \u0060Byte\u0060, \u0060Float\u0060, etc.\nSee the list of [available types](https://github.com/boriel/zxbasic/blob/master/docs/types#types.md). If type is not specified,\n\u0060Float\u0060 will be used, unless you use a modifier like \u0060$\u0060 or \u0060%\u0060.\n\n**Examples**\n\n\u0060\u0060\u0060\nCONST screenAddress as uInteger = 16384\n\u0060\u0060\u0060\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/const.md"
    },
    {
        "keyword": "CONTINUE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nCONTINUE DO\nCONTINUE FOR\nCONTINUE WHILE\n\u0060\u0060\u0060\n\n\n**Description**\n\nRestarts the current loop at the initial control statement immediately, as though the CONTINUE was an end of loop. While conditions are checked again, and FOR variables are incremented or decremented as appropriate as would be normal for entering the next loop.\n\n**Remarks**\n\n* This statement is NOT Sinclair compatible, and is NOT related to the Sinclair BASIC CONTINUE statement.\n\n**See also**\n\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/continue.md"
    },
    {
        "keyword": "COS",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nCOS(numericExpression)\n\u0060\u0060\u0060\n \n\n**Description**\n\nReturns the cosine value of the given argument.\nArgument must be a numeric expression in radians units. Returned value type is [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Cosine value\nPRINT \u0022Cosine value of a is \u0022; COS(a)\n\u0060\u0060\u0060\n \n\n**Remarks**\n\n*  This function is 100% Sinclair BASIC Compatible\n*  If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n\n**See also**\n\n* [SIN](sin.md) and [ASN](https://github.com/boriel/zxbasic/blob/master/docs/asn.md)\n* [TAN](tan.md) and [ATN](https://github.com/boriel/zxbasic/blob/master/docs/atn.md)\n* [ACS](https://github.com/boriel/zxbasic/blob/master/docs/acs.md)\n*  Faster library option for lower accuracy trigonometry for games: [FCOS](https://github.com/boriel/zxbasic/blob/master/docs/fsin.bas.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/cos.md"
    },
    {
        "keyword": "DECLARE",
        "description": "ZX BASIC is a single pass compiler - that means it goes through your source code once and only once \nwhen reading your program code and compiling. Unfortunately, this method does lead to some issues when\ncalling [SUB](sub.md) and [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md) code. If a FUNCTION is not defined prior to being called,\nthe compiler neither knows what its return type nor knows parameter types, or whether you are calling the\nSUB/FUNCTION correctly. The compiler, in this case, assumes the function returns the compiler\u0027s largest type:\na float. This is often incorrect and suboptimal.\n\nTraditionally, in compiler design, there are several ways to fix this problem.\nOne is to have the compiler run two passes through the code; picking up the SUB/FUNCTION definitions as it goes,\nthen a second pass to compile. On the original ZX spectrum, most BASIC compilers were multipass\nto allow for this information gathering. \n\nZX BASIC remains single pass, which means there are two options open to you the programmer.\nThe first is to define all functions before they are used; for example, at the start of the code.\nThis method does work fine, but perhaps limits where you want to put functions in memory.\n\nThe second option is to use the DECLARE keyword. This way, the programmer can tell the compiler about a function\nin advance before it is used, and before it is fully defined with the [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md) keyword.\nPutting a DECLARE statement at the start of your code tells the compiler about the function that is defined later on.\nIn essence, you are making a promise to define it later. This fully defines the return type for the function,\nso the receiving code can be built to work with that. It also, in theory, allows the compiler to have information\nabout the function and enable it to trap errors in use of the function.\n\n**Syntax**\n\n\u0060\u0060\u0060\nDECLARE \u003Cfunction_name\u003E [(\u003Cparameter_list\u003E)] AS \u003Creturn_type\u003E\n\u0060\u0060\u0060\n\n\n**Examples**\n\n\u0060\u0060\u0060\nDeclare Function myFunction(n As Ubyte) As Ubyte\nREM Now you can call myFunction\nPRINT myFunction(32): REM This print 33\nREM Now implements myFunction \nFunction myFunction(n As Ubyte) As UByte\n    Return n \u002B 1\nEnd Function\n\u0060\u0060\u0060\n\n**See Also**\n\n* [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md)\n* [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\n\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/declare.md"
    },
    {
        "keyword": "DIM",
        "description": "**DIM** is used in Sinclair BASIC to declare arrays.\nIn ZX BASIC, its usage has been extended to declare any variable and its type.\nA [type](https://github.com/boriel/zxbasic/blob/master/docs/types.md) is a name for the kind of data (\u0060Integer\u0060, \u0060Byte\u0060, \u0060String\u0060, etc.) it holds.\n\n**Declaration of variables**\n\n*Syntax*\n\n\u0060\u0060\u0060\nDIM \u003Cvariable_name\u003E[,\u003Cvariable_name\u003E...] [AS \u003Ctype\u003E] [= \u003Cvalue\u003E]\n\u0060\u0060\u0060\n\nWhere _\u003Ctype\u003E_ can be one of **INTEGER**, **BYTE**, **FLOAT**, etc.\nSee the list of [available types](https://github.com/boriel/zxbasic/blob/master/docs/types.md). If type is not specified, **FLOAT** will be used, unless you use\na suffix (usually called _sigil_) like \u0060$\u0060 or \u0060%\u0060.\n\n*Default variable values*\n\nZX BASIC will initialize any numeric variable to 0 (like most BASIC flavors), and any string variable to an\nempty string, so you don\u0027t need to initialize them, though it\u0027s recommended.\n\n*Undeclared variables*\n\nZX BASIC allows you to use undeclared variables. In Sinclair BASIC, using an unassigned variable triggered\nthe error _Variable not found_, but in ZX BASIC it will default to 0 value.\n\nYou can enforce variable declaration using the \u0060--explicit\u0060 [command line option](https://github.com/boriel/zxbasic/blob/master/docs/zxb.md#Command_Line_Options).\nWhen it\u0027s used, the compiler will require every variable to be declared with DIM before being used for the 1st time.\n\nYou can also enforce explicit type declaration using the \u0060--strict\u0060 [command line option](https://github.com/boriel/zxbasic/blob/master/docs/zxb.md#Command_Line_Options).\nThis way, if you use \u0060DIM\u0060 you will be required to declare also the type needed.\n\nWhen you use an undeclared variable, ZX BASIC will try to guess its type by looking at the context in which \nit is being used and then will initialize it with a default value, depending on the type (0 or an empty string).\nIf it cannot guess the type (this is usually very difficult), it will fallback to float.\nThe float type is the most inefficient (though most flexible) type ZX BASIC supports,\nbut it is the Sinclair BASIC compatible one. So if you want the compiler to make an efficient and optimized compilation,\nit is better to declare the variable types you use in advance using the DIM statement\n(Note that languages like C or Pascal requires every used variable to be declared).\n\nDeclaring a variable that has already been referenced in previous lines will result in a syntax error.\n\n**Examples**\n\n*Examples of variable declarations*\n\n\u0060\u0060\u0060\nREM Declares \u0027a\u0027 as a 16 bit signed integer variable\nDIM a AS INTEGER\nREM Declares \u0027b\u0027 as a Float because no type is specified\nDIM b\nREM Declares \u0027c\u0027 as String, because of the \u0027$\u0027 suffix\nDIM c$\nREM Declares \u0027d\u0027 as String, using an explicit type\nDIM d as STRING\nREM Declares \u0027x\u0027, \u0027y\u0027 as 32bit unsigned integers in a single line\nDIM x, y as ULONG\nREM Here \u0027S\u0027 is declared as String, because \u0027R\u0027 has a \u0027$\u0027\nDIM R$, S\nREM initialize an unsigned byte with 5\nDIM b as UBYTE = 5\nREM warning: Using default implicit type float for \u0027a\u0027\nDIM a = 5\nREM No warning here, because the compiler knows it is an integer (% suffix)\nDIM c% = 5\n\u0060\u0060\u0060\n\n*Examples of undeclared variables*\n\n\u0060\u0060\u0060\nREM variable a is not declared, but since you use PI, it must be float\nLET a = PI\n\u0060\u0060\u0060\n\nHowever, other examples might be more complex:\n\n\u0060\u0060\u0060\nREM variable a here is taken as a FIXED not FLOAT. Beware with precision loss!\nLET a = 3.5\n\u0060\u0060\u0060\n\nFor any positive integer, unsigned types will be used, but if an implicit initialization contains a negative value\nthe signed type will be used instead.\n\n\u0060\u0060\u0060\nREM variable a will be declared implicitly as BYTE \nFOR a = -1 TO 10\n   ...\nNEXT\nREM Warning, truncation!\nLET a = -3.5\nREM variable b will be declared as UByte\nFOR b = 1 TO 10\n   ...\nNEXT\nREM Warning, sign overflow!\nLET b = -1\n\u0060\u0060\u0060\n\nAs you might see, using undeclared variables might lead to errors (truncation, overflow).\nThe compiler will try to warning about these whenever it can, but sometimes this will be not possible,\nand errors might pass silently... (you might experience strange behaviors in your program).\n\nIt might even be difficult for you to guess which type will be implicitly used for an undeclared variable.\nThe safest choice is to always declare them.\n\n**Variable mapping**\n\nYou can declare a variable at a fixed memory address. This is called _variable mapping_.\n\nE.g. in ZX Spectrum Sinclair\u0027s ROM address 23675 contains a system variable which points to UDG address.\nYou could traditionally read this content by doing:\n\n\u0060\u0060\u0060\nPRINT \u0022UDG memory address is \u0022; PEEK 23675 \u002B 256 * PEEK 23676\n\u0060\u0060\u0060\n\nIt is a 16 bit unsigned integer value (\u0060Uinteger\u0060). We can map a variable on that address:\n\n\u0060\u0060\u0060\nDIM UDGaddr AS Uinteger AT 23675\nPRINT \u0022UDG memory address is \u0022; UDGaddr\n\u0060\u0060\u0060\n\nThis is more readable. Also, setting a value to this variable changes UDG address.\n\n**Variable aliasing**\n\nA variable is just a memory position containing data. In same cases you might find useful a variable having\nmore than one name, for the sake of code readability:\n\n\u0060\u0060\u0060\nDIM a AS Float = PI\nREM Now let\u0027s declare an alias of \u0027a\u0027, called \u0027radians\u0027\nDIM radians AS Float AT @a\nPRINT \u0022radians = \u0022; radians\nLET radians = 1.5\nPRINT \u0022a = \u0022; a\n\u0060\u0060\u0060\n\nAs you can see, both _**radians**_ and _**a**_ can be used interchangeably.\n\n**Array Declaration**\n\n*Syntax*\n\n\u0060\u0060\u0060\nDIM a([\u003Clower_bound\u003E TO] \u003Cupper_bound\u003E [, ...]) AS \u003Ctype\u003E\n\u0060\u0060\u0060\n\n*Description*\n\nBy default, array indexes starts from 0, not from 1 as in Sinclair BASIC. You can change this behavior setting \na different array base index using either a [#pragma option](pragma.md) or a [command line option](https://github.com/boriel/zxbasic/blob/master/docs/zxb.md#Command Line Options).\n\n*Examples*\n\n\u0060\u0060\u0060\nREM \u0027a\u0027 is an array of 11 floats, from a(0) to a(10)\nDIM a(10)\nREM \u0027b\u0027 has the same size\nDIM b(0 TO 10)\n\u0060\u0060\u0060\n\n\n*Initialized arrays*\n\nYou can also use DIM to declare an array, and promptly fill it with data. At the moment, this is not valid for string arrays, only numerical arrays. One handy way to use this would be to use an array to store a table, such as user defined graphics:\n\n\u0060\u0060\u0060\nREM udg will be an array of 8 UBytes\nREM Remember, the default in ZX Basic is for arrays to begin at zero, so 0-7 is 8 bytes\nDIM udg(7) AS uByte =\u003E {0,1,3,7,15,31,63,127}\nREM This sets the System UDG variable to point to the 1st array element:\nPOKE UINTEGER 23675,@udg(0): REM udg(0) is the 1st array element\n\u0060\u0060\u0060\n\nArrays of 2 or more dimensions can be initialized using this syntax:\n\n\u0060\u0060\u0060\nDIM udg(1, 7) AS uByte =\u003E {{0,1,3,7,15,31,63,127}, _\n                           {1,2,4,7,15,31,63,127}}\nREM Each row contains an UDG. All bytes are stored in a continuous memory block\n\u0060\u0060\u0060\n\nNote the usage of \u0060@variable\u0060 to denote the location in memory the variable is stored into. Also see the extensions to [POKE](https://github.com/boriel/zxbasic/blob/master/docs/poke.md).\n\n**See also**\n\n* [LBOUND](https://github.com/boriel/zxbasic/blob/master/docs/lbound.md)\n* [UBOUND](https://github.com/boriel/zxbasic/blob/master/docs/ubound.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/dim.md"
    },
    {
        "keyword": "DO",
        "description": "**DO** ... **LOOP** is a _compound_ statement used to perform loops. The code within the **DO ... LOOP** statement will be repeated if the given condition is _true_. The loop is executed at less once when the loop condition is written at the end, even if the given _condition_ is false at the first iteration.\n\n**Syntax**\n\nThe **DO** ... **LOOP** construct is a very powerful sentence and can be used in up to 5 different ways:\n\n*Infinite loops*\n\nSometimes we want a loop to repeat forever, no matter what, because we need to exit the loop when an external event happens. For example, we want to repeat forever waiting for a key press. Traditionally we use GOTO for this in Sinclair BASIC. Other languages use WHILE (1), etc. The best way to do this in ZX BASIC is this one:\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP: REM This loop repeats forever.\n\u0060\u0060\u0060\n\nThis form **loops forever**. It\u0027s better to use this form instead of using **STEP** 0 in a **FOR** loop, or a **WHILE** 1 condition loop. The generated code is more efficient.\n\n*Looping UNTIL*\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP UNTIL \u003Ccondition\u003E\n\u0060\u0060\u0060\n\n\nThis form repeats _until_ the given condition is met. The loop is guaranteed to execute at least once regardless of loop exit condition - it is only evaluated at the end of the first loop.\n\nYou can also put the condition at the beginning, this way:\n\n\u0060\u0060\u0060\nDO UNTIL \u003Ccondition\u003E\n    [\u003Csentences\u003E]\nLOOP\n\u0060\u0060\u0060\n\n\nIn this case, the condition is checked first, and the program won\u0027t enter to the inner _sentences_ if the condition is not satisfied at first.\n\n####Example using UNTIL\nExample: _Loop until the user press a Key_\n\n\u0060\u0060\u0060\nREM in a single line!\nDO LOOP UNTIL INKEY$ \u003C\u003E \u0022\u0022\n\u0060\u0060\u0060\n\n\n*Looping WHILE*\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP WHILE \u003Ccondition\u003E\n\u0060\u0060\u0060\n\n\nThis form repeats _while_ the given condition is true.\nThe difference with the [WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md) sentence is the latter won\u0027t execute the inner sentences if _condition_ is false at the start. Remember: **DO**...**LOOP** will execute _sentences_ at least once regardless of the condition upon entry to the loop - it is only evaluated at the end of the first loop.\n\nYou can also put the condition at the beginning, this way:\n\n\u0060\u0060\u0060\nDO WHILE \u003Ccondition\u003E\n    [\u003Csentences\u003E]\nLOOP\n\u0060\u0060\u0060\n\n\nIn this case, the condition is checked first, and the program won\u0027t enter to the inner _sentences_ if the condition is not satisfied at first.\n\n####Example using WHILE\nExample: _Loop while there is no key pressed_\n\n\u0060\u0060\u0060\nREM in a single line!\nDO LOOP WHILE INKEY$ = \u0022\u0022\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This statement does not exist in Sinclair Basic.\n* **WHILE** can also be used with [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md) loops.\n\n**See Also**\n\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/do.md"
    },
    {
        "keyword": "DATA",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n DATA \u003Cexpression\u003E[, \u003Cexpression\u003E, \u003Cexpression\u003E...] \n\u0060\u0060\u0060\n\n**DATA** statement stores values to be retrieved using the [READ](https://github.com/boriel/zxbasic/blob/master/docs/read.md) sentence. These can be numerical or string expressions.\nInstead of using INPUT() function or [LET](https://github.com/boriel/zxbasic/blob/master/docs/let.md) assignments, you can write a sequence (or several of them) of **DATA** \nwhich might result in a compact and more readable code to initialize data variables.\n\n**DATA** statements can be placed anywhere in the code, but they\u0027re usually located at the end for better readability.\n\n**Example**\n\n\u0060\u0060\u0060\nFOR i = 1 TO 2\n    READ a, b, c$\n    PRINT \u0022a: \u0022; a\n    PRINT \u0022b: \u0022; b\n    PRINT \u0022c: \u0022; c\nNEXT i\nREM notice the a * a expression\nDATA 2, a * a, \u0022Hello\u0022\nDATA b * 5, 32, \u0022World\u0022\n\u0060\u0060\u0060\n\nThis will output:\n\n\u0060\u0060\u0060\n a: 2\n b: 4\n c: Hello\n a: 20\n b: 32\n c: World\n\u0060\u0060\u0060\nExpressions are read and evaluated one by one. When a **DATA** line is finished, the next one in the listing will be read.\nTraditionally if there\u0027s no more data to read, an _OUT of Data_ error happened. In ZX Basic, the read sequence restarts from the beginning.\n\n**Remarks**\n\n* This statement is Sinclair BASIC compatible.\n\n**See also**\n\n* [READ](https://github.com/boriel/zxbasic/blob/master/docs/read.md)\n* [RESTORE](https://github.com/boriel/zxbasic/blob/master/docs/restore.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/data.md"
    },
    {
        "keyword": "DRAW",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n DRAW dx, dy [, arc]\n\u0060\u0060\u0060\n or\n\u0060\u0060\u0060\n DRAW \u003CAttribute Modifiers\u003E; dx, dy [, arc]\n\u0060\u0060\u0060\nDraws a _straight line_ starting from the current drawing coordinates (x, y)\n(see [PLOT](https://github.com/boriel/zxbasic/blob/master/docs/plot.md)) to \u0060(x \u002B dx, y \u002B dy)\u0060 position. Coordinate \u0060(0, 0)\u0060\ndesignates bottom-left screen corner. Drawing coordinates are updated\nto the last position.\n\n**DRAW** is enhanced in ZX BASIC to allow drawing on the last two screen rows (this was not possible in Sinclair BASIC). So now we have 16 lines more (192 in total). Sinclair BASIC only used top 176 scan lines. This means that in Sinclair BASIC\n\u0060\u0060\u0060\nPLOT x0, y0: DRAW x, y\n\u0060\u0060\u0060\n\nis equivalent in ZX BASIC to\n\u0060\u0060\u0060\nPLOT x0, y0 \u002B 16: DRAW x, y\n\u0060\u0060\u0060\n\n\n**Remark**: This primitive uses Bresenham\u0027s algorithm for faster drawing instead of ROMs implementation.\n\n*Drawing Arcs*\n\nWhen used with 3 parameters it draws arcs the same way the Sinclair BASIC version does,\nbut again the 192 scan-lines are available.\n\n\u0060\u0060\u0060\nDRAW dx, dy, arc\n\u0060\u0060\u0060\nThe above will draw an arc from the current position to (x \u002B dx, y \u002B dy) position, with a curve of \u0027\u0027arc\u0027\u0027 radians. This routine also have some strange behaviors. High values of arc draws strange patterns.\n\n*Remarks*\n\n* This function is not strictly Sinclair BASIC compatible since it uses all 192 screen lines instead of top 176.\nIf you translate **PLOT**, **DRAW** \u0026 **CIRCLE**, commands from Sinclair BASIC _as is_\nyour drawing will be _shifted down_ 16 pixels.\n\n*See Also*\n\n* [PLOT](https://github.com/boriel/zxbasic/blob/master/docs/plot.md)\n* [CIRCLE](https://github.com/boriel/zxbasic/blob/master/docs/circle.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/draw.md"
    },
    {
        "keyword": "ELSE",
        "description": "**IF** is a very powerful control flow sentence that allows you to _make decisions_ under specified contitions.\n\n**Syntax**\n\n\u0060\u0060\u0060\n IF expression [THEN] sentences [: END IF]\n\u0060\u0060\u0060\nor \n\n\u0060\u0060\u0060\n IF expression [THEN]\n    sentences\n [ELSEIF expression [THEN] sentences]\n [ELSEIF expression [THEN] sentences]\n  ...\n [ELSE sentences]\n END IF\n\u0060\u0060\u0060\n*Examples*\n\n\u0060\u0060\u0060\nIF a \u003C 5 THEN PRINT \u0022A is less than five\u0022 ELSE PRINT \u0022A is greater than five\u0022\n\u0060\u0060\u0060\n\n\nSentences might be in multiple lines:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    a = a \u002B 5 \nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\nSince **IF** is a _sentence_, it can be nested; however, remember that _every_ **IF** _must be closed with_ **END IF** when the line is splitted after **THEN** (mutiline **IF**):\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElse If a \u003C 7 Then\n        Print \u0022A is greater or equal to five, but lower than 7\u0022\n    Else\n        Print \u0022A is greater than five\u0022\n    End If\nEnd If\n\u0060\u0060\u0060\n\n\n**Using ELSEIF**\n\nIn the example above, you see that nesting an **IF** inside another one could be somewhat verbose and error prone. It\u0027s better to use \nthe **ELSEIF** construct. So the previous example could be rewritten as:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElseIf a \u003C 7 Then\n    Print \u0022A is greater or equal to five, but lower than 7\u0022\nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This sentence is **extended** allowing now multiline IFs and also compatible with the Sinclair BASIC version.\n* Starting from version 1.8 onwards the trailing **END IF** is not mandatory for single-line IFs, for compatibility with Sinclair BASIC\n* The **THEN** keyword can be omitted, but keep in mind this might reduce code legibility.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/if.md"
    },
    {
        "keyword": "ELSEIF",
        "description": "**IF** is a very powerful control flow sentence that allows you to _make decisions_ under specified contitions.\n\n**Syntax**\n\n\u0060\u0060\u0060\n IF expression [THEN] sentences [: END IF]\n\u0060\u0060\u0060\nor \n\n\u0060\u0060\u0060\n IF expression [THEN]\n    sentences\n [ELSEIF expression [THEN] sentences]\n [ELSEIF expression [THEN] sentences]\n  ...\n [ELSE sentences]\n END IF\n\u0060\u0060\u0060\n*Examples*\n\n\u0060\u0060\u0060\nIF a \u003C 5 THEN PRINT \u0022A is less than five\u0022 ELSE PRINT \u0022A is greater than five\u0022\n\u0060\u0060\u0060\n\n\nSentences might be in multiple lines:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    a = a \u002B 5 \nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\nSince **IF** is a _sentence_, it can be nested; however, remember that _every_ **IF** _must be closed with_ **END IF** when the line is splitted after **THEN** (mutiline **IF**):\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElse If a \u003C 7 Then\n        Print \u0022A is greater or equal to five, but lower than 7\u0022\n    Else\n        Print \u0022A is greater than five\u0022\n    End If\nEnd If\n\u0060\u0060\u0060\n\n\n**Using ELSEIF**\n\nIn the example above, you see that nesting an **IF** inside another one could be somewhat verbose and error prone. It\u0027s better to use \nthe **ELSEIF** construct. So the previous example could be rewritten as:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElseIf a \u003C 7 Then\n    Print \u0022A is greater or equal to five, but lower than 7\u0022\nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This sentence is **extended** allowing now multiline IFs and also compatible with the Sinclair BASIC version.\n* Starting from version 1.8 onwards the trailing **END IF** is not mandatory for single-line IFs, for compatibility with Sinclair BASIC\n* The **THEN** keyword can be omitted, but keep in mind this might reduce code legibility.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/if.md"
    },
    {
        "keyword": "END",
        "description": "Used for ending a program, an asm block, sub or function\n\n**Syntax**\n\nTo END the program\n\u0060\u0060\u0060\nEND\n\u0060\u0060\u0060\nTo end an asm block\n\u0060\u0060\u0060\nasm\n    LD a, 5   ; Z80n assembly code\nend asm\n\u0060\u0060\u0060\nAnd similar is used after a SUB or FUNCTION\n\u0060\u0060\u0060\nsub mysub()\n    \u0027..code\nend sub\n\u0060\u0060\u0060\n\u0060\u0060\u0060\nfunction hello()\n    \u0027..code\nend function\n\u0060\u0060\u0060\nMore info : https://github.com/boriel/zxbasic/blob/master/docs/while.md",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/end.md"
    },
    {
        "keyword": "EXIT",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nEXIT DO\nEXIT FOR\nEXIT WHILE\n\u0060\u0060\u0060\n\n**Description**\n\nTerminates the current loop structure immediately and carries on execution from after the corresponding **LOOP**, **NEXT** or **END WHILE** statement.\n\n**Remarks**\n\n* This is NOT compatible with Sinclair Basic\n\n**See Also**\n\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/exit.md"
    },
    {
        "keyword": "EXP",
        "description": "You can raise one number to the power of another - that means \u0027multiply the first number by itself the second number of times\u0027.\n\n**Remarks**\n This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/exp.md"
    },
    {
        "keyword": "FASTCALL",
        "description": "Fastcall is used to indicate that an assembly function should be jumped into with registers already set. \n\n* If the function takes a Byte (or uByte) parameter, then the A register will be set with this parameter. \n* If it takes an Integer (or uInteger) parameter, then the HL register will be set with the value of that parameter on entry to the function. \n* If it takes a Long (or uLong), or fixed  parameter, then the DE and HL registers will hold the 32 bit value of the parameter.\n* If it takes a float type parameter, then the registers C, DE and HL will hold the five bytes for that value.\n\nReturn is automatic based on the function return type in the same way:\n* 8 bit returns should be in the A register\n* 16 bit returns should be in HL\n* 32 bit returns should be in DEHL\n* 40 bit FLOAT returns should be in CDEHL.\n\nFastcall should ONLY be used with functions that take a single parameter. If you use more than one parameter, you\u0027ll have to deal with the stack (SP register) and restore it to the previous it had before your function was called.\n\n**Example:**\n\n\u0060\u0060\u0060\nFUNCTION FASTCALL whatLetter (A as uByte) as uByte\n   Asm\n             PROC\n             LOCAL DATA, START\n             JP START\n   DATA:     DEFB \u0022A Man, A Plan, A Canal, Panama\u0022\n   START:    LD HL,DATA\n             LD D,0\n             LD E,A\n             ADD HL,DE\n             LD A,(HL)\n             ENDP\n   End Asm\nEND FUNCTION\n\u0060\u0060\u0060\n\nThe above function, when called with \u0060whatLetter(\u003Cvalue\u003E)\u0060 will return the \u0060\u003Cvalue\u003E\u0060-th letter of the phrase\n\u0060\u0022A Man, A Plan, A Canal, Panama\u0022\u0060.\n\n*Notes*\n\n* Note that the A register already contains \u003Cvalue\u003E when the inline assembly is reached.\n* Note that we do NOT need to put a ret opcode on the end of the assembly. The compiler will do that for us.\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/fastcall.md"
    },
    {
        "keyword": "FLASH",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nFLASH \u003Cvalue\u003E\n\u0060\u0060\u0060\nor\n\u0060\u0060\u0060\nPRINT FLASH \u003Cvalue\u003E;\n\u0060\u0060\u0060\nThis can be used to change the permanent print settings, or the temporary ones.\nWhen used as a direct command:\n\n\u0060\u0060\u0060\nFLASH n\n\u0060\u0060\u0060\nbeing \u0060n\u0060 either 0 (false) or 1 (true), then the subsequent print statements will print characters that have\ntheir \u0060INK\u0060 and \u0060PAPER\u0060 values swapped at regular intervals automatically by the Spectrum\u0027s ULA.\n\nJust as in Sinclair Basic, this command can be used as temporary colours by combining them with a print statement:\n\n\u0060\u0060\u0060\nPrint INK 0;PAPER 7; FLASH 1; \u0022This is flashing black and white text\u0022\n\u0060\u0060\u0060\nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [BRIGHT](https://github.com/boriel/zxbasic/blob/master/docs/bright.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/flash.md"
    },
    {
        "keyword": "FOR",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n FOR iterator = startvalue TO endvalue [ STEP stepvalue ]\n   [ sentences ]\n NEXT [ iterator ]\n\u0060\u0060\u0060\n**Parameters**\n\n* _iterator_: a variable identifier that is used to iterate from an initial value to an end value.\n* _datatype_: If specified, the variable iterator will automatically be declared with the type datatype.\n* _startvalue_: an expression that denotes the starting value of the iterator.\n* _endvalue_: an expression used to compare with the value of the iterator.\n* _stepvalue_: an expression that is added to the iterator after every iteration.\n\n**Description**\n\nA **For...Next** loop initializes _iterator_ to _startvalue_, then executes the _sentences_, incrementing _iterator_ by \n_stepvalue_ until it reaches or exceeds _endvalue_. If _stepvalue_ is not explicitly given it will set to 1.\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Counts from 1 to 10\nFOR i = 1 TO 10: PRINT i: NEXT\n\u0060\u0060\u0060\n\n*Counts downwards*\n\n\u0060\u0060\u0060\nFOR i = 10 TO 1 STEP -1: PRINT i: NEXT\n\u0060\u0060\u0060\n\n*Loops using odd numbers*\n\n\u0060\u0060\u0060\nFOR i = 1 TO 10 STEP 2: PRINT i: NEXT\n\u0060\u0060\u0060\n\n**Differences From Sinclair Basic**\n\n* The variable name after the NEXT statement is not required.\n\n* Note that variable types can cause issues with ZX Basic For...Next Loops. If the upper limit of the iterator exceeds\nthe upper limit of the variable type, the loop may not complete.\nFor example:\n\u0060\u0060\u0060\nDIM i as UByte\nFOR i = 1 to 300\n    PRINT i\nNEXT i\n\u0060\u0060\u0060\n\nClearly, since the largest value a byte can hold is 255, it\u0027s not possible for i in the above example to exceed 300.\nThe variable will \u0022wrap around\u0022 to 0 and as a result, the loop will not ever terminate.\nThis can happen in much more subtle ways when \u0060STEP\u0060 is used.\nThere has to be \u0022room\u0022 within the variable type for the iterator to exceed the terminator when it is being\nincremented by \u003Cstep\u003E amounts.\n\nFor example, this loop will neved end\n\n\u0060\u0060\u0060\nDIM i as UInteger\nFOR i = 65000 TO 65500 STEP 100\n ...\nNEXT i\n\u0060\u0060\u0060\n\nThis loop will never end. \u0060UInteger\u0060 type allows values in the range \u0060[0..65535]\u0060 so apparently it\u0027s ok, because\n65500 fits in it. However \u0060STEP\u0060 is 100, so 65500 \u002B 100 = 65600 which fall out if such range. There will be an\n_overflow_ and the variable \u0060i\u0060 will take the value 64 and the loop will continue.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n* [Sinclair Basic Manual](http://www.worldofspectrum.org/ZXBasicManual/zxmanchap4.html)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/for.md"
    },
    {
        "keyword": "FUNCTION",
        "description": "ZX Basic allows function and subroutines declarations. This feature is new to ZX Basic.\nSinclair BASIC allowed limited function definitions using \u0060DEF FN\u0060.\n\nA function is a subroutine (like GO SUB) that is invoked directly.\nThe subroutine returns a value than can be used later.\nBASIC language already has some predefined functions, like \u0060SIN\u0060, \u0060COS\u0060, \u0060PEEK\u0060 or \u0060LEN\u0060.\nThe user is now allowed to define his/her own functions.\n\n**Syntax**\n\nBasic function declaration is:\n\n\u0060\u0060\u0060\n FUNCTION \u003Cfunction name\u003E[(\u003Cparamlist\u003E)] [AS \u003Ctype\u003E]\n     \u003Csentences\u003E\n     ...\n END FUNCTION\n\u0060\u0060\u0060\n**Example**\n\nA simple function declaration:\n\n\u0060\u0060\u0060\nREM This function receives and returns a byte\nFUNCTION PlusOne(x AS Byte) AS Byte\n    RETURN x \u002B 1\nEND FUNCTION\nREM Using the function\nPRINT x; \u0022 plus one is \u0022; PlusOne(x)\n\u0060\u0060\u0060\n\nIf \u0060AS\u0060 _type_ is omitted, the function is supposed to return a \u0060Float\u0060.\n\n\u0060\u0060\u0060\nREM This function returns a float number because its type has been omitted.\nREM Also, the \u0027x\u0027 parameter will be converted to float,\nREM because it\u0027s type has been omitted too\nFUNCTION Square(x)\n    RETURN x^2\nEND FUNCTION\nREM Using the function\nPRINT \u0022Square of \u0022; x; \u0022 is \u0022; Square(x)\n\u0060\u0060\u0060\n\n**Recursion**\n\nRecursion is a programming technique in which a function calls itself. A classical recursion example is the factorial function:\n\n\u0060\u0060\u0060\nFUNCTION Factorial(x)\n    IF x \u003C 2 THEN RETURN 1\n    RETURN Factorial(x - 1) * x\nEND FUNCTION\n\u0060\u0060\u0060\n\nHowever, not using types explicitly might have a negative impact on performance.\nBetter redefine it using data types. Factorial is usually defined on unsigned integers and also returns an unsigned\ninteger. Also, keep in mind that factorial numbers tends to _grow up very quickly_ (e.g. Factorial of 10 is 3628800),\nso \u0060ULong\u0060 [type](https://github.com/boriel/zxbasic/blob/master/docs/types.md) (32 bits unsigned) seems to be the most suitable for this function.\n\nThis version is faster (just the 1st line is changed):\n\n\u0060\u0060\u0060\nFUNCTION Factorial(x AS Ulong) AS Ulong\n    IF x \u003C 2 THEN RETURN x\n    RETURN Factorial(x - 1) * x\nEND FUNCTION\n\u0060\u0060\u0060\n\n**Memory Optimization**\n\nIf you invoke zxbasic using \u0060-O1\u0060 (or higher) optimization flag the compiler will detect and ignore unused functions\n(thus saving memory space). It will also issue a warning (perhaps you forgot to call it?),\nthat can be ignored.\n\n**See Also**\n\n* [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\n* [ASM](https://github.com/boriel/zxbasic/blob/master/docs/asm.md)\n* [END](https://github.com/boriel/zxbasic/blob/master/docs/end.md)\n* [RETURN](https://github.com/boriel/zxbasic/blob/master/docs/return.md)\n* [ByREF](https://github.com/boriel/zxbasic/blob/master/docs/byref.md)\n* [ByVAL](https://github.com/boriel/zxbasic/blob/master/docs/byval.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/function.md"
    },
    {
        "keyword": "GOTO",
        "description": "Jump to GO TO label\n\n**Example**\n\n\u0060\u0060\u0060\nIF A = 10 GOTO APPLES\nIF A = 0 GOTO NOAPPLE\nAPPLES:\n    PRINT \u0022WE HAVE APPLES\u0022 : STOP\nNOAPPLES:\n    PRINT \u0022NO APPLES\u0022\n\u0060\u0060\u0060\n\n**Remarks**\n- This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/goto.md"
    },
    {
        "keyword": "GOSUB",
        "description": "Jumps to the GO SUB label and continues until the return statement is encountered, which returns flow to the statement following GO SUB\n\n**Example**\n\n\u0060\u0060\u0060\n10 REM \u0022A rearranged guessing game\u0022\n20 INPUT a: CLS\n30 INPUT \u0022Guess the number \u0022,b\n40 IF a=b THEN PRINT \u0022Correct\u0022: STOP\n50 IF a\u003CB THENGO SUB 100\n60 IF A\u003Eb THEN GO SUB 100\n70 GO TO 30\n100 PRINT \u0022Try again\u0022\n110 RETURN\n\u0060\u0060\u0060\n\n**Remarks**\n- This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/gosub.md"
    },
    {
        "keyword": "IF",
        "description": "**IF** is a very powerful control flow sentence that allows you to _make decisions_ under specified contitions.\n\n**Syntax**\n\n\u0060\u0060\u0060\n IF expression [THEN] sentences [: END IF]\n\u0060\u0060\u0060\nor \n\n\u0060\u0060\u0060\n IF expression [THEN]\n    sentences\n [ELSEIF expression [THEN] sentences]\n [ELSEIF expression [THEN] sentences]\n  ...\n [ELSE sentences]\n END IF\n\u0060\u0060\u0060\n*Examples*\n\n\u0060\u0060\u0060\nIF a \u003C 5 THEN PRINT \u0022A is less than five\u0022 ELSE PRINT \u0022A is greater than five\u0022\n\u0060\u0060\u0060\n\n\nSentences might be in multiple lines:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    a = a \u002B 5 \nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\nSince **IF** is a _sentence_, it can be nested; however, remember that _every_ **IF** _must be closed with_ **END IF** when the line is splitted after **THEN** (mutiline **IF**):\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElse If a \u003C 7 Then\n        Print \u0022A is greater or equal to five, but lower than 7\u0022\n    Else\n        Print \u0022A is greater than five\u0022\n    End If\nEnd If\n\u0060\u0060\u0060\n\n\n**Using ELSEIF**\n\nIn the example above, you see that nesting an **IF** inside another one could be somewhat verbose and error prone. It\u0027s better to use \nthe **ELSEIF** construct. So the previous example could be rewritten as:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElseIf a \u003C 7 Then\n    Print \u0022A is greater or equal to five, but lower than 7\u0022\nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This sentence is **extended** allowing now multiline IFs and also compatible with the Sinclair BASIC version.\n* Starting from version 1.8 onwards the trailing **END IF** is not mandatory for single-line IFs, for compatibility with Sinclair BASIC\n* The **THEN** keyword can be omitted, but keep in mind this might reduce code legibility.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/if.md"
    },
    {
        "keyword": "IN",
        "description": "Read ports into variable\n\n**Syntax**\n\nIN *port*\n\n**Remarks**\n- This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/in.md"
    },
    {
        "keyword": "INK",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nINK \u003Cvalue\u003E\n\u0060\u0060\u0060\nor\n\u0060\u0060\u0060\nPRINT INK \u003Cvalue\u003E;\n\u0060\u0060\u0060\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\n\n\n\u0060\u0060\u0060\nINK n\n\u0060\u0060\u0060\nbeing n a number from 0-8, then the subsequent print statements will have a foreground colour based on the number used. As the ZX Spectrum manual states:\n\u0060\u0060\u0060\n 0 - black\n 1 - blue\n 2 - red\n 3 - purple, technically called magenta\n 4 - green\n 5 - pale blue, technically called cyan\n 6 - yellow\n 7 - white\n 8 - transparent (Do not change the paper value in the square being printed)\n 9 - Contrast - currently NOT supported.\n\u0060\u0060\u0060\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\n\n\n\u0060\u0060\u0060\nPrint ink 2; \u0022This is red text\u0022\n\u0060\u0060\u0060\n \nThis format does not change the permanent colour settings and only affects the characters printed within that print statement.\n\n**Remarks**\n\n* This function is Near Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/ink.md"
    },
    {
        "keyword": "INKEY",
        "description": "The \u0060INKEY\u0060 function is used to return a value of a keypress at the moment the function is accessed.\nInkey does not wait for user input. It returns a single character string containing the key pressed.\nUse of Shift or Caps-Lock makes the character upper case. In some cases, a non-printable string may be returned;\nfor example if cursor keys are pressed at the time the function is run. \n\nIf no key is pressed, it returns a null string (\u0060\u0022\u0022\u0060).\n\nFor compatibility with Sinclair Basic, \u0060INKEY$\u0060 is also a valid synonym.\n\n\n\u0060\u0060\u0060\nWHILE INKEY \u003C\u003E CHR(13) : REM CHR(13) is the code for the ENTER key\n PRINT INKEY; : REM PRINTS A KEYPRESS\n WHILE INKEY\u003C\u003E\u0022\u0022\n  REM WAIT Until the key isn\u0027t pressed any more.\n END WHILE\nEND WHILE\n\u0060\u0060\u0060\n\n\nThe above code will echo keys pressed to the screen. Note that the loop has to be held up to wait until the key is no longer pressed, in order to prevent the same character being reprinted many times.\n\n**Remarks**\n\n* This sentence is 100% Sinclair BASIC Compatible\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/inkey.md"
    },
    {
        "keyword": "INPUT",
        "description": "Issues a cursor to the screen, waits for the user to type and returns the user\u0027s input when the user presses ENTER.\n\n**Syntax**\n\n\u0060\u0060\u0060\nvariable = INPUT(max_length)\n\u0060\u0060\u0060\nMax_length is the number of characters the INPUT function will accept as a maximum.\n\n**Requirements**\n\nINPUT is a library function that must be included before it can be used. Use the following directive:\n\n\u0060\u0060\u0060\n#include \u003Cinput.bas\u003E\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is similar, but not equivalent to the INPUT statement available in Sinclair BASIC.\n* Note that this function ALWAYS RETURNS A STRING, which is very different from Sinclair BASIC\u0027s INPUT statement.\n* This function places the Input cursor at the last print position, not at the bottom of the screen. Remember that ZX Basic allows access to all 24 screen lines, so PRINT AT 24,0; sets the PRINT cursor to the bottom of the screen.\n\n**See also**\n\n* [ INKEY ](https://github.com/boriel/zxbasic/blob/master/docs/inkey.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/input.md"
    },
    {
        "keyword": "INT",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nINT(numericExpression)\n\u0060\u0060\u0060\n\n\n**Description**\n\nRounds the given expression by truncation. This function behaves\nexactly like the one in the Sinclair BASIC ROM.\nArgument must be a numeric expression. Returned value is a long (32 bit) number\nthat will be casted (converted) to the required type.\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Round by truncation\nLET a = 1.5\nPRINT \u0022Int value of a is \u0022; INT(a)\nREM \u0027Will print 1\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/int.md"
    },
    {
        "keyword": "INVERSE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nINVERSE \u003Cvalue\u003E\n\u0060\u0060\u0060\n\nor\n\n\u0060\u0060\u0060\nPRINT INVERSE \u003Cvalue\u003E;\n\u0060\u0060\u0060\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\n\n\n\u0060\u0060\u0060\nINVERSE n\n\u0060\u0060\u0060\n\nwhere n is either 0 (false) or 1 (true), then the subsequent print statements will have their\nINK and PAPER values swapped from the current settings for INK and PAPER.\n\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\n\n\u0060\u0060\u0060\nPrint INK 0;PAPER 7; INVERSE 1; \u0022This WHITE text on BLACK background\u0022\n\u0060\u0060\u0060\n\nNote that the INK and PAPER are swapped because of the INVERSE 1\nThis format does not change the permanent colour settings and only\naffects the characters printed within that print statement.\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n* [BRIGHT](https://github.com/boriel/zxbasic/blob/master/docs/bright.md)\n* [FLASH](https://github.com/boriel/zxbasic/blob/master/docs/flash.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/inverse.md"
    },
    {
        "keyword": "ITALIC",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nITALIC \u003Cvalue\u003E\n\u0060\u0060\u0060\n\nor\n\n\u0060\u0060\u0060\nPRINT ITALIC \u003Cvalue\u003E;\n\u0060\u0060\u0060\n\nThis can be used to change the permanent print settings, or the temporary ones.\nWhen used as a direct command:\n\n\u0060\u0060\u0060\nITALIC n\n\u0060\u0060\u0060\n\nwhere n is either 0 (false) or 1 (true), then the subsequent print statements will have their \u0060INK\u0060\npixels slewed left at the top, and right at the bottom, making text appear italicized.\n\nThis command can be used as temporary colours by combining them with a print statement:\n\n\u0060\u0060\u0060\nPrint INK 0;PAPER 7; ITALIC 1; \u0022This is ITALIC BLACK text on WHITE\u0022\n\u0060\u0060\u0060\n\nThis version does not change the permanent colour settings and only affects\nthe characters printed within that print statement.\n\n**Remarks**\n\n* This statement is NOT Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/italic.md"
    },
    {
        "keyword": "LBOUND",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nLBound(\u003Carray variable\u003E)\nLBound(\u003Carray variable\u003E, \u003Cdimension\u003E)\n\u0060\u0060\u0060\n\n\n**Description**\n\nReturns the array lower bound of the given \u003Cdimension\u003E. If the \u003Cdimension\u003E is not specified, it defaults to 0.\nIf the specified \u003Cdimension\u003E is 0, then total number of dimensions is returned.\n\n**Examples**\n\n\u0060\u0060\u0060\nDIM a(3 TO 5, 1 TO 8)\nPRINT LBound(a, 2) : REM Prints 1\nPRINT Lbound(a) : REM Prints 2, the number of dimensions\n\u0060\u0060\u0060\n\nThe result is always a 16bit integer value.\n\n\nIf \u0060\u003Cdimension\u003E\u0060 is 0 the number of dimensions in the array is returned\n(use it to guess the number of dimensions of an array):\n\n\u0060\u0060\u0060\nDIM a(3 TO 5, 2 TO 8)\nPRINT LBound(a, 0): REM Prints 2, since \u0027a\u0027 has 2 dimensions\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function does not exists in Sinclair BASIC.\n\n**See also**\n\n* [DIM](https://github.com/boriel/zxbasic/blob/master/docs/dim.md)\n* [UBOUND](https://github.com/boriel/zxbasic/blob/master/docs/ubound.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/lbound.md"
    },
    {
        "keyword": "LET",
        "description": "Let sentence is used to assign a value to a variable or array element. It can be omitted. E.g.:\n\u0060\u0060\u0060\nLET a = 5\n\u0060\u0060\u0060\nwhich can be also written as:\n\u0060\u0060\u0060\na = 5\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This sentence is 100% Sinclair BASIC Compatible\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/let.md"
    },
    {
        "keyword": "LEN",
        "description": "Returns the length of *string\n\n**Syntax**\n\nLEN string\n\n\ta$ = \u0022Zelion\u0022\n\tPRINT LEN a$ : \u0027 Will print 6\n\n\t a = 5\n\n**Remarks**\n\n- This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/len.md"
    },
    {
        "keyword": "LN",
        "description": "Calculates logarithms to the base e; these are called natural logarithms. To calculate logarithms to any other base, you must divide the natural logarithm by the natural logarithm of the base: \n\n\t a = 5\n\n**Syntax**\n\nLN x\n\n**Example**\n\n\u0060\u0060\u0060logax = LN x/ LN a\u0060\u0060\u0060\n\n**Remarks**\n\n- This function does exist in Sinclair BASIC.",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/ln.md"
    },
    {
        "keyword": "LOAD",
        "description": "#SAVE, LOAD and VERIFY\n\n**Syntax**\n\n\u0060\u0060\u0060\nSAVE \u0022xxx\u0022 CODE START, LENGTH\nSAVE \u0022xxx\u0022 SCREEN$ [Note: This is the functional equivalent of SAVE \u0022xxx\u0022 CODE 16384,6912 ]\nLOAD \u0022xxx\u0022 CODE\nLOAD \u0022xxx\u0022 CODE START\nLOAD \u0022xxx\u0022 CODE START, LENGTH\nLOAD \u0022xxx\u0022 SCREEN$\nVERIFY \u0022xxx\u0022 CODE\nVERIFY \u0022xxx\u0022 SCREEN$\n\u0060\u0060\u0060\nThe above commands work in a manner identical to Sinclair Basic.\n\n\u0060\u0060\u0060\nSAVE \u0022xxx\u0022 DATA \u003Cvarname\u003E( ) \n\u0060\u0060\u0060\nThis behaves like the original Sinclair BASIC, but here you can save/load/verify not only arrays, but single variables.\nParenthesis can be omitted (in Sinclair BASIC they were mandatory). You can also use \u0060LOAD\u0060/\u0060VERIFY\u0060 with this.\n\n\u0060\u0060\u0060\n SAVE \u0022xxx\u0022 DATA \n\u0060\u0060\u0060\n\nWith no varname saves ALL the entire user variable area plus the HEAP memory zone.\nThat is, it saves the entire program state. You can also use \u0060LOAD\u0060/\u0060VERIFY\u0060 with this.\n\n**Remarks**\n\n* The save command should save bytes in a format that is 100% Sinclair BASIC Compatible\n* For \u0060LOAD\u0060 and \u0060VERIFY\u0060, when a R-Tape Loading error occurs, the program will not stop.\n  You have to check PEEK 23610 (ERR_NR) for value 26. If that value exists, then the \u0060LOAD\u0060/\u0060VERIFY\u0060 operation failed.\n* \u0060LOAD\u0060/\u0060SAVE\u0060/\u0060VERIFY\u0060 can be interrupted by the user by pressing BREAK/Space,\n  which cancels the operation (signaling the break in \u0060ERR_NR\u0060 and returning). If you want \u0060LOAD\u0060/\u0060SAVE\u0060/\u0060VERIFY\u0060 to be\n  interrupted and exit also your program (returning to the ROM Basic), compile with \u0060--enable-break\u0060 flag.\n* When using \u0060LOAD \u0022xxx\u0022 DATA...\u0060 you won\u0027t see the message\n  _\u0022Number array:\u0022_ or _\u0022Char array:\u0022_, but _\u0022Bytes:\u0022_ instead.\n  This is because ZX BASIC always uses bytes (\u0060LOAD\u0060/\u0060SAVE ... CODE\u0060) for storing user variables\n  (ZX BASIC is machine code, so the idea of BASIC variables doesn\u0027t apply).\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/load.md"
    },
    {
        "keyword": "LOOP",
        "description": "**DO** ... **LOOP** is a _compound_ statement used to perform loops. The code within the **DO ... LOOP** statement will be repeated if the given condition is _true_. The loop is executed at less once when the loop condition is written at the end, even if the given _condition_ is false at the first iteration.\n\n**Syntax**\n\nThe **DO** ... **LOOP** construct is a very powerful sentence and can be used in up to 5 different ways:\n\n*Infinite loops*\n\nSometimes we want a loop to repeat forever, no matter what, because we need to exit the loop when an external event happens. For example, we want to repeat forever waiting for a key press. Traditionally we use GOTO for this in Sinclair BASIC. Other languages use WHILE (1), etc. The best way to do this in ZX BASIC is this one:\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP: REM This loop repeats forever.\n\u0060\u0060\u0060\n\nThis form **loops forever**. It\u0027s better to use this form instead of using **STEP** 0 in a **FOR** loop, or a **WHILE** 1 condition loop. The generated code is more efficient.\n\n*Looping UNTIL*\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP UNTIL \u003Ccondition\u003E\n\u0060\u0060\u0060\n\n\nThis form repeats _until_ the given condition is met. The loop is guaranteed to execute at least once regardless of loop exit condition - it is only evaluated at the end of the first loop.\n\nYou can also put the condition at the beginning, this way:\n\n\u0060\u0060\u0060\nDO UNTIL \u003Ccondition\u003E\n    [\u003Csentences\u003E]\nLOOP\n\u0060\u0060\u0060\n\n\nIn this case, the condition is checked first, and the program won\u0027t enter to the inner _sentences_ if the condition is not satisfied at first.\n\n####Example using UNTIL\nExample: _Loop until the user press a Key_\n\n\u0060\u0060\u0060\nREM in a single line!\nDO LOOP UNTIL INKEY$ \u003C\u003E \u0022\u0022\n\u0060\u0060\u0060\n\n\n*Looping WHILE*\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP WHILE \u003Ccondition\u003E\n\u0060\u0060\u0060\n\n\nThis form repeats _while_ the given condition is true.\nThe difference with the [WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md) sentence is the latter won\u0027t execute the inner sentences if _condition_ is false at the start. Remember: **DO**...**LOOP** will execute _sentences_ at least once regardless of the condition upon entry to the loop - it is only evaluated at the end of the first loop.\n\nYou can also put the condition at the beginning, this way:\n\n\u0060\u0060\u0060\nDO WHILE \u003Ccondition\u003E\n    [\u003Csentences\u003E]\nLOOP\n\u0060\u0060\u0060\n\n\nIn this case, the condition is checked first, and the program won\u0027t enter to the inner _sentences_ if the condition is not satisfied at first.\n\n####Example using WHILE\nExample: _Loop while there is no key pressed_\n\n\u0060\u0060\u0060\nREM in a single line!\nDO LOOP WHILE INKEY$ = \u0022\u0022\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This statement does not exist in Sinclair Basic.\n* **WHILE** can also be used with [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md) loops.\n\n**See Also**\n\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/do.md"
    },
    {
        "keyword": "NEXT",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n FOR iterator = startvalue TO endvalue [ STEP stepvalue ]\n   [ sentences ]\n NEXT [ iterator ]\n\u0060\u0060\u0060\n**Parameters**\n\n* _iterator_: a variable identifier that is used to iterate from an initial value to an end value.\n* _datatype_: If specified, the variable iterator will automatically be declared with the type datatype.\n* _startvalue_: an expression that denotes the starting value of the iterator.\n* _endvalue_: an expression used to compare with the value of the iterator.\n* _stepvalue_: an expression that is added to the iterator after every iteration.\n\n**Description**\n\nA **For...Next** loop initializes _iterator_ to _startvalue_, then executes the _sentences_, incrementing _iterator_ by \n_stepvalue_ until it reaches or exceeds _endvalue_. If _stepvalue_ is not explicitly given it will set to 1.\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Counts from 1 to 10\nFOR i = 1 TO 10: PRINT i: NEXT\n\u0060\u0060\u0060\n\n*Counts downwards*\n\n\u0060\u0060\u0060\nFOR i = 10 TO 1 STEP -1: PRINT i: NEXT\n\u0060\u0060\u0060\n\n*Loops using odd numbers*\n\n\u0060\u0060\u0060\nFOR i = 1 TO 10 STEP 2: PRINT i: NEXT\n\u0060\u0060\u0060\n\n**Differences From Sinclair Basic**\n\n* The variable name after the NEXT statement is not required.\n\n* Note that variable types can cause issues with ZX Basic For...Next Loops. If the upper limit of the iterator exceeds\nthe upper limit of the variable type, the loop may not complete.\nFor example:\n\u0060\u0060\u0060\nDIM i as UByte\nFOR i = 1 to 300\n    PRINT i\nNEXT i\n\u0060\u0060\u0060\n\nClearly, since the largest value a byte can hold is 255, it\u0027s not possible for i in the above example to exceed 300.\nThe variable will \u0022wrap around\u0022 to 0 and as a result, the loop will not ever terminate.\nThis can happen in much more subtle ways when \u0060STEP\u0060 is used.\nThere has to be \u0022room\u0022 within the variable type for the iterator to exceed the terminator when it is being\nincremented by \u003Cstep\u003E amounts.\n\nFor example, this loop will neved end\n\n\u0060\u0060\u0060\nDIM i as UInteger\nFOR i = 65000 TO 65500 STEP 100\n ...\nNEXT i\n\u0060\u0060\u0060\n\nThis loop will never end. \u0060UInteger\u0060 type allows values in the range \u0060[0..65535]\u0060 so apparently it\u0027s ok, because\n65500 fits in it. However \u0060STEP\u0060 is 100, so 65500 \u002B 100 = 65600 which fall out if such range. There will be an\n_overflow_ and the variable \u0060i\u0060 will take the value 64 and the loop will continue.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n* [Sinclair Basic Manual](http://www.worldofspectrum.org/ZXBasicManual/zxmanchap4.html)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/for.md"
    },
    {
        "keyword": "OVER",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nOVER \u003Cvalue\u003E\n\u0060\u0060\u0060\n\nor\n\n\u0060\u0060\u0060\nPRINT OVER \u003Cvalue\u003E;\n\u0060\u0060\u0060\n\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\n\n\u0060\u0060\u0060\n OVER 0\n OVER 1\n OVER 2\n OVER 3\n\u0060\u0060\u0060\nthen the subsequent print statements will overwrite the previous ones with differing effects. \n\n * After an \u0060OVER 0\u0060 command, the characters are simply replaced, as per usual.\n   This behaves just like the Sinclair Basic OVER 0 command.\n\n * After \u0060OVER 1\u0060, subsequent characters are combined with an Exclusive OR (XOR) - that is\n   to say pixels are flipped by overprinting with another ink pixel, and left alone by overprinting with a paper pixel.\n   This behaves identically to the OVER 1 Sinclair Basic Command.\n\n * After \u0060OVER 2\u0060, subsequent prints are combined using an AND function - that is only \n   pixels will remain where BOTH characters has pixels before. If either had a paper pixel, what is left is a paper pixel.\n   This is not Sinclair Basic compatible, and is an extension.\n\n * After \u0060OVER 3\u0060, Subsequent prints are combined using an OR function - that is pixels remain where EITHER\n   character had pixels before. If either had an ink pixel, what is left there is an ink pixel.\n   This is not Sinclair Basic compatible, and is an extension.\n\nJust as in Sinclair basic, these commands can be used as temporary colours by combining them with a print statement:\n\n\u0060\u0060\u0060\nPrint Over 2; \u0022This is combined as an AND function\u0022\n\u0060\u0060\u0060\n\nThis format does not change the permanent colour settings and only affects the characters\nprinted within that print statement.\n\n**Remarks**\n\n* This function is Sinclair BASIC compatible.\n* This function _extends_ Sinclair BASIC.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/over.md"
    },
    {
        "keyword": "OUT",
        "description": "Sends a byte of value to the specified port\n\n**Syntax**\n\nOUT *port,value*\n\n**Example**\n\n\u0060\u0060\u0060\nOUT 254, 0 : \u0027 sets border to blank, border is on port 254\n\u0060\u0060\u0060\n\n**Remarks**\n\n- This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/out.md"
    },
    {
        "keyword": "PAPER",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nPAPER \u003Cvalue\u003E\n\u0060\u0060\u0060\n\nor\n\n\u0060\u0060\u0060\nPRINT PAPER \u003Cvalue\u003E;\n\u0060\u0060\u0060\nThis can be used to change the permanent print settings, or the temporary ones. When used as a direct command:\n\n\u0060\u0060\u0060\nPAPER n\n\u0060\u0060\u0060\n\nwhere n is a number from 1-8, then the subsequent print statements will have a background colour based on\nthe number used. As the ZX Spectrum manual states:\n\u0060\u0060\u0060\n 0 - black\n 1 - blue\n 2 - red\n 3 - purple, technically called magenta\n 4 - green\n 5 - pale blue, technically called cyan\n 6 - yellow\n 7 - white\n 8 - transparent (do not change the paper value in the square being printed)\n\u0060\u0060\u0060\n\nJust as in Sinclair basic, this command can be used as temporary colours by combining them with a print statement:\n\n\u0060\u0060\u0060\nPrint paper 2; \u0022This is on a red background\u0022\n\u0060\u0060\u0060\n \nThis format does not change the permanent colour settings and only affects the characters printed within\nthat print statement.\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC compatible.\n\n**See also**\n\n* [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/paper.md"
    },
    {
        "keyword": "PAUSE",
        "description": "PAUSE CPU for n frames (0-65535) if n=0 means PAUSE forever until a keypress.\n\n**Syntax**\n\nPAUSE n\n\n**Examples**\n\n\u0060\u0060\u0060\nPAUSE 0 : REM This will wait for a keypress\nPAUSE 1 : REM this will wait 1 frame\n\u0060\u0060\u0060\n\n**Remarks**\n\n- Using PAUSE will call ROM routine which may cause issues writing code for the NEX which can page out any part of memory. Use **WaitRetrace(n)** and **WaitKey()** instead.\n\n- This is compatible with Sinclair Basic",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/pause.md"
    },
    {
        "keyword": "PEEK",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\npeek (address)\npeek (typeToRead, address)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the memory content (byte) stored at _address_ position. If _address_ is not a 16 bit unsigned integer, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to such type before reading the memory.\n\nWhen _typeToRead_ is specified, the given [type](https://github.com/boriel/zxbasic/blob/master/docs/types.md) is read from memory; otherwise the type of the read value is supposed to be _ubyte_ (8 bit unsigned integer).\n\nThe type of the returning value is the _typeToRead_ specified, or _ubyte_ if no type is specified.\n\n**Examples**\n\nThe following example reads a 16 bit unsigned integer at position 23675 (this is the System Variable for \u003Cabbr title=\u0022User Defined Graphics\u0022\u003EUDG\u003C/abbr\u003E in Sinclair BASIC systems):\n\n\u0060\u0060\u0060\nprint \u0022Address of UDG is \u0022; peek(23675) \u002B 256 * peek(23676)\n\u0060\u0060\u0060\n\nBut it\u0027s faster to specify the type of the value:\n\n\u0060\u0060\u0060\nprint \u0022Address of UDG is \u0022; peek(uinteger, 23675)\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is Sinclair BASIC compatible.\n* This function extends the Sinclair BASIC version.\n\n**See also**\n\n* [poke](https://github.com/boriel/zxbasic/blob/master/docs/poke.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/peek.md"
    },
    {
        "keyword": "PI",
        "description": "Returns the value of PI\n\n**Example**\n\n\u0060\u0060\u0060a = PI * 2\u0060\u0060\u0060\n\n**Remarks**\n\n- This function is Sinclair BASIC compatible.",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/pi.md"
    },
    {
        "keyword": "PLOT",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nPLOT x, y\n\u0060\u0060\u0060\n \nor\n\n\u0060\u0060\u0060 \nPLOT \u003CAttribute Modifiers\u003E; x, y\n\u0060\u0060\u0060\nPlots a _pixel_ at coordinates (x, y) (pixel column, pixel row). Coordinate (0, 0) designates bottom-left screen corner.\n\n**PLOT** is enhanced in ZX BASIC to allow plotting in the last two screen rows (this was not possible in Sinclair BASIC). So now we have 16 lines more (192 in total). Sinclair BASIC only used top 176 scan-lines. This means that in Sinclair BASIC\n\n\u0060\u0060\u0060\nPLOT x, y\n\u0060\u0060\u0060\n\nmust be translated to ZX BASIC as\n\n\u0060\u0060\u0060\nPLOT x, y \u002B 16\n\u0060\u0060\u0060\n\nif you want your drawing to appear at the same vertical screen position Sinclair BASIC uses.\n\n*Remarks*\n\n* This function is not strictly Sinclair BASIC compatible since it uses all 192 screen lines instead of top 176. If you translate **PLOT** \u0026 **DRAW** commands from Sinclair BASIC _as is_ your drawing will be _shifted down_ 16 pixels.\n\n*See Also*\n\n* [DRAW](https://github.com/boriel/zxbasic/blob/master/docs/draw.md)\n* [CIRCLE](https://github.com/boriel/zxbasic/blob/master/docs/circle.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/plot.md"
    },
    {
        "keyword": "POKE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\npoke \u003Caddress\u003E, \u003Cvalue\u003E\npoke \u003Ctype\u003E \u003Caddress\u003E, \u003Cvalue\u003E\n\u0060\u0060\u0060\n\n**Description**\n\nStores the given (numeric) _value_ at the specified memory _address_. If _valueType_ is omitted, it is supposed to be _ubyte_ (8 bit unsigned integer).\n\nThe _value_ is [converted](cast.md) to the given _[valueType](zx_basic:types.md)_ and stored at the given _Address_. _Type_ can be any numeric one (like _[float](zx_basic:types#float.md)_ or _[integer](https://github.com/boriel/zxbasic/blob/master/docs/zx_basic:types#integer.md)_). \n\n**Examples**\n\nIt is possible to _poke a decimal value_ (5 bytes) at a memory position:\n\n\u0060\u0060\u0060\npoke float 16384, pi\n\u0060\u0060\u0060\n\nTraditionally, in Sinclair BASIC, to store a 16 bit value the programmer does something like this:\n\n\u0060\u0060\u0060\n10 LET i = 16384\n20 LET value = 65500\n30 POKE i, value - 256 * INT(value / 256) : REM value MOD 256\n40 POKE i \u002B 1, INT(value / 256)\n\u0060\u0060\u0060\n\nThis can be done in a single sentence in ZX BASIC:\n\n\n\u0060\u0060\u0060\npoke uinteger 16384, 65500\n\u0060\u0060\u0060\n\nIt\u0027s faster and the recommended way.\n\n**Remarks**\n\n* This statement is Sinclair BASIC compatible.\n* This statement extends the Sinclair BASIC one.\n* This statement also allows parenthesis and [FreeBASIC syntax](http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgPoke)\n\n**See also**\n\n* [PEEK](https://github.com/boriel/zxbasic/blob/master/docs/peek.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/poke.md"
    },
    {
        "keyword": "PRINT",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n PRINT [\u003Citem\u003E][;]\n\u0060\u0060\u0060\n\n**Description**\n\n\u0060PRINT\u0060 is a sentence used to output information on the screen. The ZX Spectrum screen is divided in 24 rows (numbered\nfrom 0 to 23), and 32 columns (numbered from 0 to 31). So it\u0027s composed of 24 x 32 = 96 cells. Cells are referred by\nits coordinate (row, column), being (0, 0) the top-leftmost cell, and (23, 31) the bottom-rightmost one.\n\nThere\u0027s a _hidden cursor_ on the screen that points to the coordinate where the next character will be printed.\nEach time something is printed, a _carriage return_ is also printed and the screen cursor is advanced to \nthe next line (row):\n\n\u0060\u0060\u0060\nPRINT \u0022I\u0027M ON ONE LINE\u0022\nPRINT \u0022I\u0027M ON THE NEXT ONE\u0022\n\u0060\u0060\u0060\n\nIf you don\u0027t want this to happen, you can add a semicolon (;) at the end of the \u0060PRINT\u0060 sentence, and the next\nprinted expression will still be on the same line:\n\n\u0060\u0060\u0060\nPRINT \u0022I\u0027M ON ONE LINE\u0022;\nPRINT \u0022... AND I\u0027M ALSO ON THE SAME LINE\u0022\nPRINT \u0022AND I\u0027M ON A NEW LINE\u0022\n\u0060\u0060\u0060\nNotice the first \u0060PRINT\u0060 ends with a semicolon to avoid _carriage return_. Executing a single \u0060PRINT\u0060 will just\nadvance the cursor to the next line.\n\n\u003E **NOTE**: when the cursor reaches the end of the screen, it will **scroll upwards** all rows 1 position.\n\nLet\u0027s prints numbers from 0 to 25 and see what happens:\n\n\u0060\u0060\u0060\nCLS: REM Clears screeen and puts the cursor at the top-leftmost corner\nFOR i = 0 TO 25\n  PRINT i\nNEXT i\n\u0060\u0060\u0060\nYou\u0027ll see that number 0 and 1 are gone (they were shifted up and went out of the screen).\n\n\u003E **NOTE**: When the screen is cleared with [CLS](https://github.com/boriel/zxbasic/blob/master/docs/cls.md), the cursor is set to its default position (0, 0),\n\u003E that is, the top-leftmost screen corner.\n    \n\u0060PRINT\u0060 can print everything that is a _single_ expression (also called an _item_).\nThat is, strings (like in the previous example), numbers, variable values, and array elements\n(it can not print an entire array; that\u0027s not a \u0060single\u0060 element but a collection):\n\nFor example:\n\n\u0060\u0060\u0060\nLET a = 5\nPRINT \u0022Variable \u0027a\u0027 contains the value: \u0022;\nPRINT a\n\u0060\u0060\u0060\n\nIndeed, if you want to chain several expressions one after another you can _chain_ them in a single PRINT sentence\nusing semicolons:\n\u0060\u0060\u0060\nLET a = 5\nPRINT \u0022Variable \u0027a\u0027 contains the value: \u0022; a\n\u0060\u0060\u0060\n\n**Changing the print position**\n\nYou can change the current _cursor_ position using the [AT](https://github.com/boriel/zxbasic/blob/master/docs/at.md) modifier:\n\n\u0060\u0060\u0060\nPRINT AT 5, 0; \u0022This message starts at ROW 5\u0022\nPRINT AT 10, 10; \u0022This message starts at ROW 10, COLUMN 10\u0022\n\u0060\u0060\u0060\n\nAgain, you can chain all \u0060PRINT\u0060 _items_ using semicolon:\n\n\u0060\u0060\u0060\nPRINT AT 5, 0; \u0022ROW 5\u0022; AT 10, 10; \u0022ROW 10, COLUMN 10\u0022\n\u0060\u0060\u0060\n\n**Changing appearance**\n\nYou can temporarily override the aspect of the items printed using them inline:\n\n\u0060\u0060\u0060\nCLS\nFOR i = 1 to 7\n  PRINT AT i, 0; PAPER 0; INK i; \u0022PRINT AT ROW \u0022; i; \u0022 WITH INK \u0022; i\nNEXT i\n\u0060\u0060\u0060\n\nSee the related commands section for further info.\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Prints a letter in the 10th row of the screen moving from left to right\nCLS\nFOR i = 0 TO 31\n  PRINT AT 10, i; \u0022A\u0022\n  PAUSE 10\n  PRINT AT 10, i; \u0022 \u0022: REM Erases the letter\nNEXT i\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This sentence is compatible with Sinclair BASIC but _expands_ it, since it allows printing at rows 22 and 23\n  (all 24 rows are available to the programmer). Traditionally, Sinclair BASIC only allows to print at rows 0..21.\n* You can use [ITALIC](italic.md) and [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md) modifiers (not available in Sinclair BASIC)\n\n**See also**\n\n* [CLS](https://github.com/boriel/zxbasic/blob/master/docs/cls.md)\n* [AT](https://github.com/boriel/zxbasic/blob/master/docs/at.md)\n* [PAPER](https://github.com/boriel/zxbasic/blob/master/docs/paper.md)\n* [BORDER](https://github.com/boriel/zxbasic/blob/master/docs/border.md)\n* [INVERSE](https://github.com/boriel/zxbasic/blob/master/docs/inverse.md)\n* [INK](https://github.com/boriel/zxbasic/blob/master/docs/ink.md)\n* [ITALIC](https://github.com/boriel/zxbasic/blob/master/docs/italic.md)\n* [BOLD](https://github.com/boriel/zxbasic/blob/master/docs/bold.md)\n* [OVER](https://github.com/boriel/zxbasic/blob/master/docs/over.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/print.md"
    },
    {
        "keyword": "RANDOMIZE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nRANDOMIZE\nRANDOMIZE \u003Cnumber\u003E\n\u0060\u0060\u0060\n\n**Description**\n\nSets the random seed to the given number. If no number is given, the seed\nis taken from the FRAMES counter (timer) variable.\n\nUsing RANDOMIZE at least once in the program prevents the pseudorandom generated\nsequence to be always the same.\n\nOn the other hand, if a given fixed number is used as a seed, the sequence will be always the same.\nThis is useful to produce predictable sequences (i.e. for testing).\n\n**Example**\n\n\u0060\u0060\u0060\nREM Sets a random sequence\nRANDOMIZE 10\nFOR i = 1 TO 10: PRINT RND * 10; \u0022 \u0022; NEXT i: PRINT\nREM Repeat the pseudorandom sequence\nRANDOMIZE 10\nFOR i = 1 TO 10: PRINT RND * 10; \u0022 \u0022; NEXT i: PRINT\n\u0060\u0060\u0060\n\n**Remarks**\n\nThis instruction is Sinclair BASIC compatible but the pseudorandom sequences\ngenerated are not the same.\n\n**See also**\n\n* [RND](https://github.com/boriel/zxbasic/blob/master/docs/rnd.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/randomize.md"
    },
    {
        "keyword": "READ",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nREAD \u003Cvar or array_elem\u003E[, \u003Cvar or array_elem\u003E, \u003Cvar or array_elem\u003E...] \n\u0060\u0060\u0060\n**READ** gets the next data expression available from a [DATA](https://github.com/boriel/zxbasic/blob/master/docs/data.md) line definition and stores it into a variable (not arrays) or an array element.\nInstead of using INPUT() function or [LET](https://github.com/boriel/zxbasic/blob/master/docs/let.md) assignments, you can write a sequence (or several of them) of **READ** which might result in a compact and more readable code to initialize data variables.\n\n**READ** gets the items one after another. This order can be changed using [RESTORE](https://github.com/boriel/zxbasic/blob/master/docs/restore.md). \n\n**Example**\n\n\u0060\u0060\u0060\nDIM a(9) as UByte\nFOR i = 0 TO 9: REM 0 TO 9 =\u003E 10 elements\n    READ a(i)\n    PRINT a(i)\nNEXT i\nREM notice the a(n) data entries\nDATA 2, 4, 6 * i, 7, 0\nDATA a(0), a(1), a(2), a(3), a(4)\n\u0060\u0060\u0060\n\nThis will output:\n\n\u0060\u0060\u0060\n 2\n 4\n 12\n 7\n 0\n 2\n 4\n 12\n 7\n 0\n\u0060\u0060\u0060\nExpressions are read and evaluated one by one, **when the READ sentence is executed**. When a **DATA** line is finished, the next one in the listing will be read.\nTraditionally if there\u0027s no more data to read, an _OUT of Data_ error happened. In ZX Basic, the read sequence restarts from the beginning.\nThe reading sequence can be altered with [RESTORE](https://github.com/boriel/zxbasic/blob/master/docs/restore.md)\n\n**Remarks**\n\n* This statement is Sinclair BASIC compatible.\n\n**See also**\n\n* [DATA](https://github.com/boriel/zxbasic/blob/master/docs/data.md)\n* [RESTORE](https://github.com/boriel/zxbasic/blob/master/docs/restore.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/read.md"
    },
    {
        "keyword": "REM",
        "description": "**Introduction**\n\nCommenting source code is important as it makes your code more maintainable. You can return back to a code you typed several month ago and recall and understand what it does quickly if your comments are up to date. \n\n**REM lines**\n\nTraditional BASIC dialects (e.g. Sinclair BASIC) uses REM to comment lines. REM is an abbreviation of _REMark_. ZX BASIC allows it: \n\n\n\u0060\u0060\u0060\n10 REM This line has a comment\n20 PRINT \u0022Hello World\u0022: REM The following sentence is ignored: PRINT \u0022Hello Again\u0022\n\u0060\u0060\u0060\n \n\nREM exists for the sake of retrocompatibility with old Sinclair BASIC listings.\n\n**Apostrophe character**\n\nNewer dialects uses the apostrophe character (\u0027) as a shortened REM. ZX BASIC also allows it, so the above listing could be also rewritten this way: \n\n\n\u0060\u0060\u0060\n10 \u0027 This line has a comment\n20 PRINT \u0022Hello World\u0022: \u0027The following sentence is ignored: PRINT \u0022Hello Again\u0022\n\u0060\u0060\u0060\n \n\nEverything beyond the apostrophe char will be ignored. Since line numbers can also be omitted,\nthe above listing could be rewritten as: \n\n\n\u0060\u0060\u0060\n\u0027 This line has a comment\nPRINT \u0022Hello World\u0022 \u0027The following sentence is ignored: PRINT \u0022Hello Again\u0022\n\u0060\u0060\u0060\n\n\nNotice now the missing colon at the end of the [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md) statement. REM, like any other BASIC sentence,\nrequires a colon when it is preceded by another one, whilst apostrophe does not. \n\nThe apostrophe character was used in Sinclair BASIC as a [PRINT](https://github.com/boriel/zxbasic/blob/master/docs/print.md) modifier. But here, in ZX BASIC,\nit is **always** a commenter char. \n\n**Multi-line comments**\n\nMulti-line comments are marked with the tokens \u0060/\u0027\u0060 and \u0060\u0027/\u0060. All text between the two markers is considered\ncomment text and is not compiled. \n\nMulti-line comments can span several lines, and can also be used in the middle of statements.\nAfter the end of the comment, the statement will continue to be parsed as normal (even if the comment crosses\nline breaks).\n\n\n\u0060\u0060\u0060\n/\u0027 Multi-line\ncomment \u0027/\nPrint \u0022Hello\u0022 /\u0027 embedded comment\u0027/ \u0022 world\u0022\n\u0060\u0060\u0060\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/comments.md"
    },
    {
        "keyword": "RESTORE",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nRESTORE [\u003Clabel\u003E]\n\u0060\u0060\u0060\n**RESTORE** statement is used to change the order in which [DATA](https://github.com/boriel/zxbasic/blob/master/docs/data.md) lines are read.\nThe **RESTORE** _label_ statement will make the next [READ](https://github.com/boriel/zxbasic/blob/master/docs/read.md) to get the data from the label line onwards.\nIf no label is specified, the data reading sequence is restarted from the beginning.\n\n\n**Example**\n\n\u0060\u0060\u0060\nRESTORE numbers\nFOR i = 1 TO 3\n    READ a\n    PRINT a\nNEXT i\nREM These will be skipped by the RESTORE above\nstrings:  \nDATA \u0022Hello world!\u0022, \u0022ZX Spectrum\u0022, \u0022ZX Rules!\u0022\nREM This will be read since RESTORE pointed to numbers: label\nnumbers:\nDATA 10, 20, 30\n\u0060\u0060\u0060\n\nThis will output:\n\n\u0060\u0060\u0060\n 10\n 20\n 30\n\u0060\u0060\u0060\nNotice the strings section has been skipped over.\n\n**Remarks**\n\n* This statement is Sinclair BASIC compatible.\n\n**See also**\n\n* [DATA](https://github.com/boriel/zxbasic/blob/master/docs/data.md)\n* [READ](https://github.com/boriel/zxbasic/blob/master/docs/read.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/restore.md"
    },
    {
        "keyword": "RETURN",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nRETURN [\u003Cexpr\u003E]\n\u0060\u0060\u0060\n**RETURN** statement is used in 3 cases:\n\n1. When returning from a [GO SUB](https://github.com/boriel/zxbasic/blob/master/docs/gosub.md) sentence\n2. When returning (exiting) from a [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md) (a subroutine)\n3. When returning (exiting) from a [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md). In this case a return value must be specified.\n\n\nReturns in the global scope (that is, outside any function or sub) are treated as return from [GO SUB](https://github.com/boriel/zxbasic/blob/master/docs/gosub.md).\nOtherwise they are considered as returning from the function or sub they are into.\n\n\u003E **WARNING**: Using RETURN in global scope without a GOSUB will mostly crash your program. \u003Cbr\u003E\n\u003E Use \u0060--stack-check\u0060 if you suspect you have this bug, to detect it.\n\n*Example with GO SUB*\n\n\u0060\u0060\u0060\n10 LET number = 10\n20 GOSUB 1000 : REM calls the subroutine\n30 LET number = 20\n40 GOSUB 1000 : REM calls the subroutine again\n100  END : REM the program must end here to avoid entering the subroutine without using GOSUB\n1000 REM Subroutine that prints number \u002B 1\n1010 PRINT \u0022number \u002B 1 is \u0022; number \u002B 1\n1020 RETURN : REM return to the caller\n\u0060\u0060\u0060\n\nThis will output:\n\n\u0060\u0060\u0060\nnumber \u002B 1 is 11\nnumber \u002B 1 is 21\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This statement is Sinclair BASIC compatible.\n\n**See also**\n\n* [GO SUB](https://github.com/boriel/zxbasic/blob/master/docs/gosub.md)\n* [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md)\n* [SUB](https://github.com/boriel/zxbasic/blob/master/docs/sub.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/return.md"
    },
    {
        "keyword": "RND",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nrnd()\nrnd\n\u0060\u0060\u0060\n\n\n**Description**\n\nReturns a number of type float in the range [0, 1) (i.e. 0 \u003C= RND \u003C 1), based on a random seed (see [RANDOMIZE](https://github.com/boriel/zxbasic/blob/master/docs/randomize.md)).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Function to a random number in the range [first, last), or {first \u003C= x \u003C last}.\nFunction rnd_range (first As Double, last As Double) As Float\n    Function = Rnd * (last - first) \u002B first\nEnd Function\nREM seed the random number generator, so the sequence is not the same each time\nRandomize\nREM prints a random number in the range [0, 1], or {0 \u003C= x \u003C 1}.\nPrint Rnd\nREM prints a random number in the range [0, 10], or  {0 \u003C= x \u003C 10}.\nPrint Rnd * 10\nREM prints a random integer number in the range [1, 11), or  {1 \u003C= x \u003C 11}.\nREM with integers, this is equivalent to [1, 10], or {1 \u003C= n \u003C= 10}.\nPrint Int(Rnd * 10) \u002B 1\nREM prints a random integer number in the range [69, 421], or {69 \u003C= x \u003C 421}.\nREM this is equivalent to [69, 420], or {69 \u003C= n \u003C= 420}.\nPrint Int(rnd_range(69, 421))\n\u0060\u0060\u0060\n\n**Remarks**\n\nZX BASIC RND is much faster than Sinclair BASIC RND, and produces different random sequences.\n\nIts randomness is also much better (try plotting points at random x,y coords,\nand they look really random whilst in Sinclair BASIC diagonal lines begin to appear:\nthis means there\u0027s a correlation between x, y points hence not very random).\n\nAlso, Sinclair BASIC RND has a periodicity of 2^16 (65536), whilst ZX BASIC RND has a periodicity of 2^32 (4,294,967,296).\n\n**See also**\n\n* [RANDOMIZE](https://github.com/boriel/zxbasic/blob/master/docs/randomize.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/rnd.md"
    },
    {
        "keyword": "SAVE",
        "description": "#SAVE, LOAD and VERIFY\n\n**Syntax**\n\n\u0060\u0060\u0060\nSAVE \u0022xxx\u0022 CODE START, LENGTH\nSAVE \u0022xxx\u0022 SCREEN$ [Note: This is the functional equivalent of SAVE \u0022xxx\u0022 CODE 16384,6912 ]\nLOAD \u0022xxx\u0022 CODE\nLOAD \u0022xxx\u0022 CODE START\nLOAD \u0022xxx\u0022 CODE START, LENGTH\nLOAD \u0022xxx\u0022 SCREEN$\nVERIFY \u0022xxx\u0022 CODE\nVERIFY \u0022xxx\u0022 SCREEN$\n\u0060\u0060\u0060\nThe above commands work in a manner identical to Sinclair Basic.\n\n\u0060\u0060\u0060\nSAVE \u0022xxx\u0022 DATA \u003Cvarname\u003E( ) \n\u0060\u0060\u0060\nThis behaves like the original Sinclair BASIC, but here you can save/load/verify not only arrays, but single variables.\nParenthesis can be omitted (in Sinclair BASIC they were mandatory). You can also use \u0060LOAD\u0060/\u0060VERIFY\u0060 with this.\n\n\u0060\u0060\u0060\n SAVE \u0022xxx\u0022 DATA \n\u0060\u0060\u0060\n\nWith no varname saves ALL the entire user variable area plus the HEAP memory zone.\nThat is, it saves the entire program state. You can also use \u0060LOAD\u0060/\u0060VERIFY\u0060 with this.\n\n**Remarks**\n\n* The save command should save bytes in a format that is 100% Sinclair BASIC Compatible\n* For \u0060LOAD\u0060 and \u0060VERIFY\u0060, when a R-Tape Loading error occurs, the program will not stop.\n  You have to check PEEK 23610 (ERR_NR) for value 26. If that value exists, then the \u0060LOAD\u0060/\u0060VERIFY\u0060 operation failed.\n* \u0060LOAD\u0060/\u0060SAVE\u0060/\u0060VERIFY\u0060 can be interrupted by the user by pressing BREAK/Space,\n  which cancels the operation (signaling the break in \u0060ERR_NR\u0060 and returning). If you want \u0060LOAD\u0060/\u0060SAVE\u0060/\u0060VERIFY\u0060 to be\n  interrupted and exit also your program (returning to the ROM Basic), compile with \u0060--enable-break\u0060 flag.\n* When using \u0060LOAD \u0022xxx\u0022 DATA...\u0060 you won\u0027t see the message\n  _\u0022Number array:\u0022_ or _\u0022Char array:\u0022_, but _\u0022Bytes:\u0022_ instead.\n  This is because ZX BASIC always uses bytes (\u0060LOAD\u0060/\u0060SAVE ... CODE\u0060) for storing user variables\n  (ZX BASIC is machine code, so the idea of BASIC variables doesn\u0027t apply).\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/load.md"
    },
    {
        "keyword": "SGN",
        "description": "Is the sign function (sometimes called signum). It is the first function you have seen that has nothing to do with strings, because both its argument and its result are numbers. The result is \u002B1 if the argument is positive, 0 if the argument is zero, and -1 if the argument is negative.\n\n**Example**\n\n\u0060\u0060\u0060SGN a\u0060\u0060\u0060\n\n**Remarks**\n\n- This statement is Sinclair BASIC compatible.",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/sgn.md"
    },
    {
        "keyword": "SHL OR \u0026LT;\u0026LT;",
        "description": "#Bit Shift Instructions\n\n**Syntax**\n\n\u0060\u0060\u0060\n \u003Cexpr\u003E SHL \u003Cdistance\u003E\n\u0060\u0060\u0060\n\u0060\u0060\u0060\n \u003Cexpr\u003E SHR \u003Cdistance\u003E\n\u0060\u0060\u0060\n\n\nBit shifts \u0060\u003Cexpr\u003E\u0060 expression by \u0060\u003Cdistance\u003E\u0060 bits to the left (\u0060SHL\u0060) or to the right (\u0060SHR\u0060).\n\u0060SHR\u0060 can be replaced by \u0060\u003E\u003E\u0060 and \u0060SHL\u0060 by \u0060\u003C\u003C\u0060 for more legibility.\n\nThe \u003Cexpr\u003E argument should be of an integer type: \u0060uByte\u0060, \u0060Byte\u0060, \u0060uInteger\u0060, \u0060Integer\u0060, \u0060uLong\u0060 or \u0060Long\u0060.\nUse of bitshifting with fixed and float gives undefined results.\n\u0060CAST\u0060 or \u0060INT\u0060 should be used to convert floating point numbers into integer type numbers before use of the bit shift instructions.\n\nOwing to the nature of moving bits right and left, \u0060SHL\u0060 n is the equivalent of a multiply by 2\u003Csup\u003En\u003C/sup\u003E, and \u0060SHR\u0060 \nwould be the equivalent of an integer division by 2\u003Csup\u003En\u003C/sup\u003E (destroying any fractional part).\n\n*Examples*\n\n\u0060\u0060\u0060\nPRINT 2 \u003C\u003C 1: REM prints 4\nPRINT 16 SHR 2: REM again 4\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function is not available in Sinclair BASIC.\n* The syntax is similar to C\u0027s \u0060\u003C\u003C\u0060 and \u0060\u003E\u003E\u0060 operators.\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/shl.md"
    },
    {
        "keyword": "SHR OR \u0026GT;\u0026GT;",
        "description": "#Bit Shift Instructions\n\n**Syntax**\n\n\u0060\u0060\u0060\n \u003Cexpr\u003E SHL \u003Cdistance\u003E\n\u0060\u0060\u0060\n\u0060\u0060\u0060\n \u003Cexpr\u003E SHR \u003Cdistance\u003E\n\u0060\u0060\u0060\n\n\nBit shifts \u0060\u003Cexpr\u003E\u0060 expression by \u0060\u003Cdistance\u003E\u0060 bits to the left (\u0060SHL\u0060) or to the right (\u0060SHR\u0060).\n\u0060SHR\u0060 can be replaced by \u0060\u003E\u003E\u0060 and \u0060SHL\u0060 by \u0060\u003C\u003C\u0060 for more legibility.\n\nThe \u003Cexpr\u003E argument should be of an integer type: \u0060uByte\u0060, \u0060Byte\u0060, \u0060uInteger\u0060, \u0060Integer\u0060, \u0060uLong\u0060 or \u0060Long\u0060.\nUse of bitshifting with fixed and float gives undefined results.\n\u0060CAST\u0060 or \u0060INT\u0060 should be used to convert floating point numbers into integer type numbers before use of the bit shift instructions.\n\nOwing to the nature of moving bits right and left, \u0060SHL\u0060 n is the equivalent of a multiply by 2\u003Csup\u003En\u003C/sup\u003E, and \u0060SHR\u0060 \nwould be the equivalent of an integer division by 2\u003Csup\u003En\u003C/sup\u003E (destroying any fractional part).\n\n*Examples*\n\n\u0060\u0060\u0060\nPRINT 2 \u003C\u003C 1: REM prints 4\nPRINT 16 SHR 2: REM again 4\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function is not available in Sinclair BASIC.\n* The syntax is similar to C\u0027s \u0060\u003C\u003C\u0060 and \u0060\u003E\u003E\u0060 operators.\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/shl.md"
    },
    {
        "keyword": "SIN",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nSIN(numericExpression)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the sine value of the given argument.\nArgument must be a numeric expression in radians units. Returned value type is [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Sine value\nPRINT \u0022Sine value of a is \u0022; SIN(a)\n\u0060\u0060\u0060\n \n**Remarks**\n\n*  This function is 100% Sinclair BASIC Compatible\n*  If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n\n**See also**\n\n* [COS](cos.md) and [ACS](https://github.com/boriel/zxbasic/blob/master/docs/acs.md)\n* [TAN](tan.md) and [ATN](https://github.com/boriel/zxbasic/blob/master/docs/atn.md)\n* [ASN](https://github.com/boriel/zxbasic/blob/master/docs/asn.md)\n*  Faster library option for lower accuracy trigonometry for games: [FSIN](https://github.com/boriel/zxbasic/blob/master/docs/library/fsin.bas.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/sin.md"
    },
    {
        "keyword": "SQR",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nSQR(numericExpression)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the square root value of the given argument.\nArgument must be a numeric expression, and is returned as type [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Square Root value\nPRINT \u0022Root of a is \u0022; SQR(a)\n\u0060\u0060\u0060\n \n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n* If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n* This function uses the ZX Spectrum ROM code to calculate. Note that the ZX Spectrum ROM is extremely\n  inefficient at doing this calculation. If speed is an issue, and you can spare a few bytes,\n  there are two functions in this wiki library to speed up square root calculations.\n  [The first](https://github.com/boriel/zxbasic/blob/master/docs/library/fsqrt.bas.md) is exactly as accurate as the ROM routine, but is about 6 times faster.\n  [The second](https://github.com/boriel/zxbasic/blob/master/docs/library/isqrt.bas.md) returns an integer result, and is 50-100 times faster.\n\n**See also**\n\n* [Library](https://github.com/boriel/zxbasic/blob/master/docs/library.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/sqr.md"
    },
    {
        "keyword": "STDCALL",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/stdcall.md"
    },
    {
        "keyword": "STEP",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\n FOR iterator = startvalue TO endvalue [ STEP stepvalue ]\n   [ sentences ]\n NEXT [ iterator ]\n\u0060\u0060\u0060\n**Parameters**\n\n* _iterator_: a variable identifier that is used to iterate from an initial value to an end value.\n* _datatype_: If specified, the variable iterator will automatically be declared with the type datatype.\n* _startvalue_: an expression that denotes the starting value of the iterator.\n* _endvalue_: an expression used to compare with the value of the iterator.\n* _stepvalue_: an expression that is added to the iterator after every iteration.\n\n**Description**\n\nA **For...Next** loop initializes _iterator_ to _startvalue_, then executes the _sentences_, incrementing _iterator_ by \n_stepvalue_ until it reaches or exceeds _endvalue_. If _stepvalue_ is not explicitly given it will set to 1.\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Counts from 1 to 10\nFOR i = 1 TO 10: PRINT i: NEXT\n\u0060\u0060\u0060\n\n*Counts downwards*\n\n\u0060\u0060\u0060\nFOR i = 10 TO 1 STEP -1: PRINT i: NEXT\n\u0060\u0060\u0060\n\n*Loops using odd numbers*\n\n\u0060\u0060\u0060\nFOR i = 1 TO 10 STEP 2: PRINT i: NEXT\n\u0060\u0060\u0060\n\n**Differences From Sinclair Basic**\n\n* The variable name after the NEXT statement is not required.\n\n* Note that variable types can cause issues with ZX Basic For...Next Loops. If the upper limit of the iterator exceeds\nthe upper limit of the variable type, the loop may not complete.\nFor example:\n\u0060\u0060\u0060\nDIM i as UByte\nFOR i = 1 to 300\n    PRINT i\nNEXT i\n\u0060\u0060\u0060\n\nClearly, since the largest value a byte can hold is 255, it\u0027s not possible for i in the above example to exceed 300.\nThe variable will \u0022wrap around\u0022 to 0 and as a result, the loop will not ever terminate.\nThis can happen in much more subtle ways when \u0060STEP\u0060 is used.\nThere has to be \u0022room\u0022 within the variable type for the iterator to exceed the terminator when it is being\nincremented by \u003Cstep\u003E amounts.\n\nFor example, this loop will neved end\n\n\u0060\u0060\u0060\nDIM i as UInteger\nFOR i = 65000 TO 65500 STEP 100\n ...\nNEXT i\n\u0060\u0060\u0060\n\nThis loop will never end. \u0060UInteger\u0060 type allows values in the range \u0060[0..65535]\u0060 so apparently it\u0027s ok, because\n65500 fits in it. However \u0060STEP\u0060 is 100, so 65500 \u002B 100 = 65600 which fall out if such range. There will be an\n_overflow_ and the variable \u0060i\u0060 will take the value 64 and the loop will continue.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n* [Sinclair Basic Manual](http://www.worldofspectrum.org/ZXBasicManual/zxmanchap4.html)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/for.md"
    },
    {
        "keyword": "STOP",
        "description": "STOPs the program and exits \n\n- This function is Sinclair BASIC compatible.",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/stop.md"
    },
    {
        "keyword": "STR",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nSTR(\u003Cnumeric value\u003E)\n\u0060\u0060\u0060\n\n**Description**\n\nConverts the given numeric value to a String. It\u0027s the opposite of [VAL](https://github.com/boriel/zxbasic/blob/master/docs/val.md)\nReturned value type is [String](https://github.com/boriel/zxbasic/blob/master/docs/types.md#UByte).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Convert numeric expression to value\nLET a = -5.2\nPRINT STR(a \u002B 1)\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n\n**See Also**\n\n* [CHR](https://github.com/boriel/zxbasic/blob/master/docs/chr.md)\n* [CODE](https://github.com/boriel/zxbasic/blob/master/docs/code.md)  \n* [VAL](https://github.com/boriel/zxbasic/blob/master/docs/chr.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/str.md"
    },
    {
        "keyword": "SUB",
        "description": "ZX Basic allows function and subroutines declarations. Sinclair Basic does not allow named subroutines, only calls with the GOSUB command.\n\nA subroutine defined with the SUB statement is invoked directly. Unlike a [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md), a SUB does not return a value. This is the fundamental difference between code defined with SUB and code defined with FUNCTION. Other than that, the setup for SUB and FUNCTION are almost identical. \n\n**Syntax**\n\nBasic function declaration is:\n\n\u0060\u0060\u0060\n SUB \u003Csubroutine name\u003E[(\u003Cparamlist\u003E)]\n     \u003Cstatements\u003E\n     ...\n END SUB\n\u0060\u0060\u0060\n\n**Example**\n\n\u0060\u0060\u0060\nSUB printat (y as uByte, x as uByte, data$ as STRING)\n  print at y,x,data$\nEND SUB\n\u0060\u0060\u0060\n\nWhile this is a rather silly example, it shows how parameters can be passed into a SUB, just like a FUNCTION. No parameters are passed back.\n\nA SUB can be exited with the return statement.\n\nA SUB is an excellent way of wrapping machine code or data such that it does not interfere with program execution. Such data can be placed within a SUB but after a RETURN statement:\n\n\n\u0060\u0060\u0060\nSUB setupUDG ()\n DIM i,j as uInteger\n LET j=@udgdata\n FOR i=USR \u0022A\u0022 to USR \u0022A\u0022\u002B7\n  POKE i,PEEK j\n NEXT i\n RETURN\nudgdata:\n ASM\n  defb 1,2,3,4,5,6,7,8\n END ASM\nEND SUB\n\u0060\u0060\u0060\n\n\nAgain, this is a rather silly example - far better to point the UDG system variable at the data than copy it, but it does show how an ASM context can be hidden from the main program, and accessed with an @ label.\n\nFinally, a SUB is an excellent way of running a pure machine code routine. FUNCTION can be used in a similar manner, if you wish to pass data back into the compiled basic, of course.\n\n\u0060\u0060\u0060\nSUB routine ()\n ASM\n  (your asm code goes here)\n END ASM\nEND SUB\n\u0060\u0060\u0060\n\n\n**Memory Optimization**\n\nIf you invoke zxbasic using -O1 (or higher) optimization flag the compiler will detect and ignore unused SUB\u0027s (thus saving memory space).\nIt will also issue a warning (perhaps you forgot to call it?), that can be ignored.\n\n\n**See Also**\n\n* [FUNCTION](https://github.com/boriel/zxbasic/blob/master/docs/function.md)\n* [ASM](https://github.com/boriel/zxbasic/blob/master/docs/asm.md)\n* [END](https://github.com/boriel/zxbasic/blob/master/docs/end.md)\n* [RETURN](https://github.com/boriel/zxbasic/blob/master/docs/return.md)\n\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/sub.md"
    },
    {
        "keyword": "TAN",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nTAN(numericExpression)\n\u0060\u0060\u0060\n \n\n**Description**\n\nReturns the tangent value of the given argument.\nArgument must be a numeric expression in radians units. Returned value type is [float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#Float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Tangent value\nPRINT \u0022Tangent value of a is \u0022; TAN(a)\n\u0060\u0060\u0060\n \n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n* If the given argument type is not float, it will be [converted](https://github.com/boriel/zxbasic/blob/master/docs/cast.md) to float before operating with it.\n\n**See also**\n\n* [SIN](sin.md) and [ASN](https://github.com/boriel/zxbasic/blob/master/docs/asn.md)\n* [COS](cos.md) and [ACS](https://github.com/boriel/zxbasic/blob/master/docs/acs.md)\n* [ATN](https://github.com/boriel/zxbasic/blob/master/docs/atn.md)\n* Faster library option for lower accuracy trigonometry for games: [FTAN](https://github.com/boriel/zxbasic/blob/master/docs/library/fsin.bas.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/tan.md"
    },
    {
        "keyword": "THEN",
        "description": "**IF** is a very powerful control flow sentence that allows you to _make decisions_ under specified contitions.\n\n**Syntax**\n\n\u0060\u0060\u0060\n IF expression [THEN] sentences [: END IF]\n\u0060\u0060\u0060\nor \n\n\u0060\u0060\u0060\n IF expression [THEN]\n    sentences\n [ELSEIF expression [THEN] sentences]\n [ELSEIF expression [THEN] sentences]\n  ...\n [ELSE sentences]\n END IF\n\u0060\u0060\u0060\n*Examples*\n\n\u0060\u0060\u0060\nIF a \u003C 5 THEN PRINT \u0022A is less than five\u0022 ELSE PRINT \u0022A is greater than five\u0022\n\u0060\u0060\u0060\n\n\nSentences might be in multiple lines:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    a = a \u002B 5 \nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\nSince **IF** is a _sentence_, it can be nested; however, remember that _every_ **IF** _must be closed with_ **END IF** when the line is splitted after **THEN** (mutiline **IF**):\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElse If a \u003C 7 Then\n        Print \u0022A is greater or equal to five, but lower than 7\u0022\n    Else\n        Print \u0022A is greater than five\u0022\n    End If\nEnd If\n\u0060\u0060\u0060\n\n\n**Using ELSEIF**\n\nIn the example above, you see that nesting an **IF** inside another one could be somewhat verbose and error prone. It\u0027s better to use \nthe **ELSEIF** construct. So the previous example could be rewritten as:\n\n\u0060\u0060\u0060\nIf a \u003C 5 Then\n    Print \u0022A is less than five\u0022\n    If a \u003E 2 Then\n        Print \u0022A is less than five but greater than 2\u0022\n    End If\nElseIf a \u003C 7 Then\n    Print \u0022A is greater or equal to five, but lower than 7\u0022\nElse\n    Print \u0022A is greater than five\u0022\nEnd If\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This sentence is **extended** allowing now multiline IFs and also compatible with the Sinclair BASIC version.\n* Starting from version 1.8 onwards the trailing **END IF** is not mandatory for single-line IFs, for compatibility with Sinclair BASIC\n* The **THEN** keyword can be omitted, but keep in mind this might reduce code legibility.\n\n**See Also**\n\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/if.md"
    },
    {
        "keyword": "TO",
        "description": "TO can be used with FOR as follows:\n\n**Examples**\n\n\u0060\u0060\u0060\nFOR n = 0 TO 10\nPRINT n\nNEXT n\n\u0060\u0060\u0060\nIt can also be use to select a portion of a string\n\u0060\u0060\u0060\na$ = \u0022ZxSpectrum\u0022\nPRINT a$(0 TO 1) : REM will print \u0022Zx\u0022\nPRINT a$(2 TO ) : REM will print \u0022Spectrum\u0022\n\u0060\u0060\u0060\n\n**Remarks**\n\n- This function is almost 100% Sinclair BASIC Compatible.",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/to.md"
    },
    {
        "keyword": "UBOUND",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nUBound(\u003Carray variable\u003E)\nUBound(\u003Carray variable\u003E, \u003Cdimension\u003E)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the array upper bound of the given \u003Cdimension\u003E. If the \u003Cdimension\u003E is not specified, it defaults to 0.\nIf the specified \u003Cdimension\u003E is 0, then total number of dimensions is returned.\n\n**Examples**\n\n\u0060\u0060\u0060\nDIM a(3 TO 5, 2 TO 8)\nPRINT UBound(a, 2) : REM Prints 8\nPRINT Ubound(a) : REM Prints 2, because it has 2 dimensions\n\u0060\u0060\u0060\n\n\nThe result is always a 16bit integer value.\n\nIf \u0060\u003Cdimension\u003E\u0060 is 0 the number of dimensions in the array is returned\n(use it to guess the number of dimensions of an array):\n\n\u0060\u0060\u0060\nDIM a(3 TO 5, 2 TO 8)\nPRINT UBound(a, 0): REM Prints 2, since \u0027a\u0027 has 2 dimensions\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function does not exists in Sinclair BASIC.\n\n**See also**\n\n* [DIM](https://github.com/boriel/zxbasic/blob/master/docs/dim.md)\n* [LBOUND](https://github.com/boriel/zxbasic/blob/master/docs/lbound.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/ubound.md"
    },
    {
        "keyword": "UNTIL",
        "description": "**DO** ... **LOOP** is a _compound_ statement used to perform loops. The code within the **DO ... LOOP** statement will be repeated if the given condition is _true_. The loop is executed at less once when the loop condition is written at the end, even if the given _condition_ is false at the first iteration.\n\n**Syntax**\n\nThe **DO** ... **LOOP** construct is a very powerful sentence and can be used in up to 5 different ways:\n\n*Infinite loops*\n\nSometimes we want a loop to repeat forever, no matter what, because we need to exit the loop when an external event happens. For example, we want to repeat forever waiting for a key press. Traditionally we use GOTO for this in Sinclair BASIC. Other languages use WHILE (1), etc. The best way to do this in ZX BASIC is this one:\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP: REM This loop repeats forever.\n\u0060\u0060\u0060\n\nThis form **loops forever**. It\u0027s better to use this form instead of using **STEP** 0 in a **FOR** loop, or a **WHILE** 1 condition loop. The generated code is more efficient.\n\n*Looping UNTIL*\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP UNTIL \u003Ccondition\u003E\n\u0060\u0060\u0060\n\n\nThis form repeats _until_ the given condition is met. The loop is guaranteed to execute at least once regardless of loop exit condition - it is only evaluated at the end of the first loop.\n\nYou can also put the condition at the beginning, this way:\n\n\u0060\u0060\u0060\nDO UNTIL \u003Ccondition\u003E\n    [\u003Csentences\u003E]\nLOOP\n\u0060\u0060\u0060\n\n\nIn this case, the condition is checked first, and the program won\u0027t enter to the inner _sentences_ if the condition is not satisfied at first.\n\n####Example using UNTIL\nExample: _Loop until the user press a Key_\n\n\u0060\u0060\u0060\nREM in a single line!\nDO LOOP UNTIL INKEY$ \u003C\u003E \u0022\u0022\n\u0060\u0060\u0060\n\n\n*Looping WHILE*\n\n\u0060\u0060\u0060\nDO\n    [\u003Csentences\u003E]\nLOOP WHILE \u003Ccondition\u003E\n\u0060\u0060\u0060\n\n\nThis form repeats _while_ the given condition is true.\nThe difference with the [WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md) sentence is the latter won\u0027t execute the inner sentences if _condition_ is false at the start. Remember: **DO**...**LOOP** will execute _sentences_ at least once regardless of the condition upon entry to the loop - it is only evaluated at the end of the first loop.\n\nYou can also put the condition at the beginning, this way:\n\n\u0060\u0060\u0060\nDO WHILE \u003Ccondition\u003E\n    [\u003Csentences\u003E]\nLOOP\n\u0060\u0060\u0060\n\n\nIn this case, the condition is checked first, and the program won\u0027t enter to the inner _sentences_ if the condition is not satisfied at first.\n\n####Example using WHILE\nExample: _Loop while there is no key pressed_\n\n\u0060\u0060\u0060\nREM in a single line!\nDO LOOP WHILE INKEY$ = \u0022\u0022\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This statement does not exist in Sinclair Basic.\n* **WHILE** can also be used with [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md) loops.\n\n**See Also**\n\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [WHILE ... END WHILE](https://github.com/boriel/zxbasic/blob/master/docs/while.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/do.md"
    },
    {
        "keyword": "VAL",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nVAL(\u003Cstring value\u003E)\n\u0060\u0060\u0060\n\n**Description**\n\nConverts the given numeric string value into its numeric value. It\u0027s the opposite of [STR](https://github.com/boriel/zxbasic/blob/master/docs/str.md).\nIf the string can be converted into a number, [PEEK](https://github.com/boriel/zxbasic/blob/master/docs/peek.md) 23610 (ROM ERR_NR variable) will return 255 (_Ok_).\n\nOn the other side, if expression cannot be parsed (i.e. it\u0027s not a valid number expression), 0 will be returned,\nand [PEEK](https://github.com/boriel/zxbasic/blob/master/docs/peek.md) 23610 (ROM ERR_NR variable) will return 9 (_Invalid Argument_).\n\nReturned value type is [Float](https://github.com/boriel/zxbasic/blob/master/docs/types.md#float).\n\n**Examples**\n\n\u0060\u0060\u0060\nREM Convert numeric expression to value\nLET a$ = \u0022-55.3e-1\u0022\nPRINT \u0022Value of \u0022; a$; \u0022 is \u0022; VAL(a$)\nLET a$ = \u0022aaa\u0022\nPRINT \u0022Numeric value of \u0022; a$; \u0022 is \u0022; VAL(a$): REM prints 0\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is 100% Sinclair BASIC Compatible\n\n**See Also**\n\n* [CHR](https://github.com/boriel/zxbasic/blob/master/docs/chr.md)\n* [CODE](https://github.com/boriel/zxbasic/blob/master/docs/code.md)  \n* [STR](https://github.com/boriel/zxbasic/blob/master/docs/str.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/val.md"
    },
    {
        "keyword": "VERIFY",
        "description": "#SAVE, LOAD and VERIFY\n\n**Syntax**\n\n\u0060\u0060\u0060\nSAVE \u0022xxx\u0022 CODE START, LENGTH\nSAVE \u0022xxx\u0022 SCREEN$ [Note: This is the functional equivalent of SAVE \u0022xxx\u0022 CODE 16384,6912 ]\nLOAD \u0022xxx\u0022 CODE\nLOAD \u0022xxx\u0022 CODE START\nLOAD \u0022xxx\u0022 CODE START, LENGTH\nLOAD \u0022xxx\u0022 SCREEN$\nVERIFY \u0022xxx\u0022 CODE\nVERIFY \u0022xxx\u0022 SCREEN$\n\u0060\u0060\u0060\nThe above commands work in a manner identical to Sinclair Basic.\n\n\u0060\u0060\u0060\nSAVE \u0022xxx\u0022 DATA \u003Cvarname\u003E( ) \n\u0060\u0060\u0060\nThis behaves like the original Sinclair BASIC, but here you can save/load/verify not only arrays, but single variables.\nParenthesis can be omitted (in Sinclair BASIC they were mandatory). You can also use \u0060LOAD\u0060/\u0060VERIFY\u0060 with this.\n\n\u0060\u0060\u0060\n SAVE \u0022xxx\u0022 DATA \n\u0060\u0060\u0060\n\nWith no varname saves ALL the entire user variable area plus the HEAP memory zone.\nThat is, it saves the entire program state. You can also use \u0060LOAD\u0060/\u0060VERIFY\u0060 with this.\n\n**Remarks**\n\n* The save command should save bytes in a format that is 100% Sinclair BASIC Compatible\n* For \u0060LOAD\u0060 and \u0060VERIFY\u0060, when a R-Tape Loading error occurs, the program will not stop.\n  You have to check PEEK 23610 (ERR_NR) for value 26. If that value exists, then the \u0060LOAD\u0060/\u0060VERIFY\u0060 operation failed.\n* \u0060LOAD\u0060/\u0060SAVE\u0060/\u0060VERIFY\u0060 can be interrupted by the user by pressing BREAK/Space,\n  which cancels the operation (signaling the break in \u0060ERR_NR\u0060 and returning). If you want \u0060LOAD\u0060/\u0060SAVE\u0060/\u0060VERIFY\u0060 to be\n  interrupted and exit also your program (returning to the ROM Basic), compile with \u0060--enable-break\u0060 flag.\n* When using \u0060LOAD \u0022xxx\u0022 DATA...\u0060 you won\u0027t see the message\n  _\u0022Number array:\u0022_ or _\u0022Char array:\u0022_, but _\u0022Bytes:\u0022_ instead.\n  This is because ZX BASIC always uses bytes (\u0060LOAD\u0060/\u0060SAVE ... CODE\u0060) for storing user variables\n  (ZX BASIC is machine code, so the idea of BASIC variables doesn\u0027t apply).\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/load.md"
    },
    {
        "keyword": "WEND",
        "description": "**WHILE** is a _compound_ statement used to perform loops. The code within a **WHILE** statement will repeat _while_ the given condition is _true_.\nIf the given _condition_ is false the first time the inner _sentences_ are _never_ executed.\n\n**Syntax**\n\n\u0060\u0060\u0060\n WHILE expression\n    sentences\n END WHILE\n\u0060\u0060\u0060\nor\n\n\u0060\u0060\u0060\n WHILE expression\n    sentences\n WEND\n\u0060\u0060\u0060\nThe first form is preferred.\n\n**Examples**\n\n\u0060\u0060\u0060\nWhile a \u003C b\n   Let a = a \u002B 1\n   Poke a, 0\nEnd While\n\u0060\u0060\u0060\n\n\nAn infinite loop:\n\u0060\u0060\u0060\nWhile 1\n  REM An infinite loop. This will issue a warning\n  Print \u0022Hello world!\u0022\nEnd While\n\u0060\u0060\u0060\n\n\n**Note**: For infinite loops use [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n\n**Remarks**\n\n* This statement does not exist in Sinclair Basic.\n* **WHILE** can also be used with [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md).\n\n**See Also**\n\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/while.md"
    },
    {
        "keyword": "WHILE",
        "description": "**WHILE** is a _compound_ statement used to perform loops. The code within a **WHILE** statement will repeat _while_ the given condition is _true_.\nIf the given _condition_ is false the first time the inner _sentences_ are _never_ executed.\n\n**Syntax**\n\n\u0060\u0060\u0060\n WHILE expression\n    sentences\n END WHILE\n\u0060\u0060\u0060\nor\n\n\u0060\u0060\u0060\n WHILE expression\n    sentences\n WEND\n\u0060\u0060\u0060\nThe first form is preferred.\n\n**Examples**\n\n\u0060\u0060\u0060\nWhile a \u003C b\n   Let a = a \u002B 1\n   Poke a, 0\nEnd While\n\u0060\u0060\u0060\n\n\nAn infinite loop:\n\u0060\u0060\u0060\nWhile 1\n  REM An infinite loop. This will issue a warning\n  Print \u0022Hello world!\u0022\nEnd While\n\u0060\u0060\u0060\n\n\n**Note**: For infinite loops use [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n\n**Remarks**\n\n* This statement does not exist in Sinclair Basic.\n* **WHILE** can also be used with [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md).\n\n**See Also**\n\n* [IF ... END IF](https://github.com/boriel/zxbasic/blob/master/docs/if.md)\n* [DO ... LOOP](https://github.com/boriel/zxbasic/blob/master/docs/do.md)\n* [FOR ... NEXT](https://github.com/boriel/zxbasic/blob/master/docs/for.md)\n* [EXIT](https://github.com/boriel/zxbasic/blob/master/docs/exit.md)\n* [CONTINUE](https://github.com/boriel/zxbasic/blob/master/docs/continue.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/while.md"
    },
    {
        "keyword": "ASC (LIBRARY FUNCTION)",
        "description": "#ASC\n\nConverts a specified character of a given string into the ASCII code equivalent.\n\n**Syntax**\n\n\u0060\u0060\u0060\nvariable = asc(A$,n)\n\u0060\u0060\u0060\nWhere \u0060A$\u0060 is a string variable and \u0060N\u0060 defines which character in the string we are interested in.\n\n**Requirements**\n\nASC is a library function that must be included before it can be used. Use the following directive:\n\n\u0060\u0060\u0060\n#include \u003Casc.bas\u003E\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function is for FreeBASIC compatibility. See [FreeBasic - ASC](http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgAsc) for details.\n* The return on this function is generally identical to that of \u0060CODE(A$(n))\u0060, though it will return 0, not an error,\nif invoked to return the ascii code of a character beyond the length of the string.\n\n**See also**\n\n* [ CODE ](https://github.com/boriel/zxbasic/blob/master/docs/library/code.md)\n\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/asc.bas.md"
    },
    {
        "keyword": "ATTR (LIBRARY FUNCTION)",
        "description": "**Requirements**\n\nATTR is a library function to be included with the following command:\n\n\u0060\u0060\u0060\n#include \u003Cattr.bas\u003E\n\u0060\u0060\u0060\n\n**Description**\n\n\u0060ATTR(row, col)\u0060\n\nReturns the ATTR (color attribute) of the given screen coordinate at the given row and column.\n\n\n**Sample usage**\n\n\u0060\u0060\u0060\n#include \u003Cattr.bas\u003E\nPRINT AT 9, 10;PAPER 4; \u0022A\u0022\nLET s = ATTR$(9, 10)\nPRINT AT 0, 0; \u0022The attribute of screen position 9, 10 is \u0022; s\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function extends the one in Sinclair BASIC (and it\u0027s compatible with it) since it also allows rows 22 and 23.\n\n\n\n**See also**\n\n* [ CSRLIN ](https://github.com/boriel/zxbasic/blob/master/docs/library/csrlin.md)\n* [ POS](https://github.com/boriel/zxbasic/blob/master/docs/library/pos.md)\n* [ AT ](https://github.com/boriel/zxbasic/blob/master/docs/library/../at.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/attr.md"
    },
    {
        "keyword": "CSRLIN (LIBRARY FUNCTION)",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nCSRLIN()\n\u0060\u0060\u0060\n\n**Description**\n\nReturns the row (line) position of the text cursor (0 means the top line).\n\n**Requirements**\n\nCSRLIN is a library function to be included with the following command:\n\n\u0060\u0060\u0060\n#include \u003Ccsrlin.bas\u003E\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function is not available in Sinclair BASIC.\n\n**See also**\n\n* [ POS](https://github.com/boriel/zxbasic/blob/master/docs/library/pos.md)\n* [ AT ](https://github.com/boriel/zxbasic/blob/master/docs/library/../at.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/csrlin.md"
    },
    {
        "keyword": "HEX (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/hex.md"
    },
    {
        "keyword": "HEX16 (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/hex.md"
    },
    {
        "keyword": "INPUT (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/input.md"
    },
    {
        "keyword": "GETKEY (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/keys.bas.md"
    },
    {
        "keyword": "MULTIKEYS (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/keys.bas.md"
    },
    {
        "keyword": "GETKEYSCANCODE (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/keys.bas.md"
    },
    {
        "keyword": "LCASE (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/lcase.md"
    },
    {
        "keyword": "UCASE (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/ucase.md"
    },
    {
        "keyword": "POINT (LIBRARY FUNCTION)",
        "description": "",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/point.md"
    },
    {
        "keyword": "POS (LIBRARY FUNCTION)",
        "description": "Returns the horizontal (left-right) position of the text cursor (0 means the very left).\n\n**Requirements**\n\nPOS is a library function to be included with the following directive:\n\n\u0060\u0060\u0060\n#include \u003Cpos.bas\u003E\n\u0060\u0060\u0060\n\n\n**Remarks**\n\n* This function is not available in Sinclair BASIC.\n\n**See also**\n\n* [ AT ](https://github.com/boriel/zxbasic/blob/master/docs/library/../at.md)\n* [ CSRLIN](https://github.com/boriel/zxbasic/blob/master/docs/library/csrlin.md)\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/pos.md"
    },
    {
        "keyword": "PRINT42 (LIBRARY SUBROUTINE)",
        "description": "The 42 column printing routine allows text to be 6 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\n\nThis routine has been adopted as an included library - so you may include it with\n\n\u0060\u0060\u0060\n#include \u003Cprint42.bas\u003E\n\u0060\u0060\u0060\n\n**Usage**\n\n\u0060\u0060\u0060\nprintat42(y,x)\n\u0060\u0060\u0060\n\nMoves the print42 system\u0027s print cursor to row Y, column X. Note that \u00600 \u003C= x \u003C= 41\u0060 - that is the range of values\nfor X can be up to 41. The range of values for Y is the normal 0-23.\n\n\u0060\u0060\u0060\nprintat42(STRING)\n\u0060\u0060\u0060\n\nPrints the string to the screen at the current Print42 co-ordinates. It does so in the current permanent colours.\n\nNOTE: The ZX Spectrum\u0027s attribute system is encoded into the hardware as a 32 character grid. Print42 does its best,\nbut changing the \u0060paper\u0060/\u0060bright\u0060/\u0060flash\u0060 colour from the background is likely to look imperfect as the attribute blocks\ncannot line up well with the pixel blocks.\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/print42.bas.md"
    },
    {
        "keyword": "PRINTAT42 (LIBRARY SUBROUTINE)",
        "description": "The 42 column printing routine allows text to be 6 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\n\nThis routine has been adopted as an included library - so you may include it with\n\n\u0060\u0060\u0060\n#include \u003Cprint42.bas\u003E\n\u0060\u0060\u0060\n\n**Usage**\n\n\u0060\u0060\u0060\nprintat42(y,x)\n\u0060\u0060\u0060\n\nMoves the print42 system\u0027s print cursor to row Y, column X. Note that \u00600 \u003C= x \u003C= 41\u0060 - that is the range of values\nfor X can be up to 41. The range of values for Y is the normal 0-23.\n\n\u0060\u0060\u0060\nprintat42(STRING)\n\u0060\u0060\u0060\n\nPrints the string to the screen at the current Print42 co-ordinates. It does so in the current permanent colours.\n\nNOTE: The ZX Spectrum\u0027s attribute system is encoded into the hardware as a 32 character grid. Print42 does its best,\nbut changing the \u0060paper\u0060/\u0060bright\u0060/\u0060flash\u0060 colour from the background is likely to look imperfect as the attribute blocks\ncannot line up well with the pixel blocks.\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/print42.bas.md"
    },
    {
        "keyword": "PRINT64 (LIBRARY SUBROUTINE)",
        "description": "The 64 column printing routine allows text to be 4 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\n\nThis routine has been adopted as an included library - so you may include it with\n\n\u0060\u0060\u0060\n#include \u003Cprint64.bas\u003E\n\u0060\u0060\u0060\n\n**Usage**\n\n\u0060\u0060\u0060\nprintat64(y,x)\n\u0060\u0060\u0060\n\nMoves the print64 system\u0027s print cursor to row Y, column X. Note that \u00600 \u003C= x \u003C= 63\u0060 - that is the range of values\nfor X can be up to 63. The range of values for Y is the normal 0-23.\n\n* Note that the print64 system\u0027s cursor position is independent from that of the ZX Basic Print routine,\nor any other, such as the print42 system.\n\n\u0060\u0060\u0060\nprintat64(STRING)\n\u0060\u0060\u0060\n\n\nPrints the string to the screen at the current Print64 co-ordinates. It does so in the current permanent colours.\n\nNOTE: The ZX Spectrum\u0027s attribute system is encoded into the hardware as a 32 character grid. Print64 does its best,\nbut changing the paper/bright/flash colour from the background is likely to look imperfect as the attribute\nblocks cannot line up well with the pixel blocks.\n\n**CODE**\n\n* There is a version of this code included with the compiler\n(though the version listed here may or may not be more recent). Code converted to ZXBasic by Britlion,\nbased on Andrew Owen\u0027s 64 Character code http://www.worldofspectrum.org/forums/showpost.php?p=167447\u0026postcount=1\n\n\n\u0060\u0060\u0060\nSUB printat64 (y as uByte, x as uByte)\n   IF y\u003C24 AND x\u003C64 then \n     POKE @p64coords,x\n     POKE @p64coords\u002B1,y\n   ELSE\n     asm\n       rst     8               ; error \u00225 \tOut of screen\u0022\n       defb    4\n     end asm\n   END IF\nEND SUB\n\nSUB print64 (characters$ as String)\nASM\n; This frankencode created by Paul Fisher, Andrew Owen, Chris Born and Einar Saukas\n; TODO:\n; * Inverse\n; * Bold (which will use a Second font)\nLD L,(IX\u002B4)\nLD H,(IX\u002B5) ; Get String address of characters$ into HL.\n; Load BC with length of string, and move HL to point to first character.\n        ld c, (hl)               ; 60020 78 \n        inc hl                   ; 60021 35 \n        ld b, (hl)               ; 60022 70 \n        inc hl                   ; 60023 35 \n; Test string length. If Zero, exit.\n        ld a, c                  ; 60024 121\n        or b                     ; 60025 176\n        jp z, p64_END         ; 60026 200\nexamineChar: \n        ld a, (hl)               ; Grab the character\n        cp 128                   ; too high to print?\n        jr nc, nextChar            ; then we go to next.\nnewLine:\n        cp 13                    ; Is this a newline character? 60056 254 13 \n        jr nz, p64_isPrintable   ; If not, hop to testing to see if we can print this 60058 32  13 \n        push hl\n        push bc\n        ld b,0\n        ld hl, p64_coords      ; Get coords 60060 237 91  68  235\n        call BLp64_NEXT_ROW         ; Go to next line.     ; 60064 205 58  235\n        pop bc\n        pop hl\n        ld (p64_coords), de    ; 60067 237 83  68  235\n        jr nextChar              ; 60071 24  11 \np64_isPrintable:\n        cp 31                    ; Bigger than 31? 60073 254 31 \n        jr c, nextChar           ; If not, get the next one. 60075 56  7  \n        \n        push hl                  ; Save position 60077 229\n        push bc                  ; Save Count   60078 197\n        call p64_PrintChar       ; Call Print SubRoutine\n        \n       \n       \n        pop bc                   ; Recover length count  60082 193\n        pop hl                   ; Recover Position 60083 225\nnextChar:\n        inc hl                   ; Point to next character 60084 35 \n        dec bc                   ; Count off this character 60085 11 \n        ld a, b                  ; Did we run out? 60086 120\n        or c                     ; 60087 177\n        jr nz, examineChar       ; If not, examine the next one 60088 32  193\n        jp p64_END               ; Otherwise hop to END. 60090 201\np64_PrintChar:\n; Arrives with A as a byte to print.\n    ld hl,p64_coords\n    push    hl              ; save COL address for later\n    ld      e, a            ; store character value in E\n    ld      b,0\n    ld      c, (hl)         ; store current column in BC\n    ; Check if character font must be rotated, self-modifying the code accordingly\n        xor     c               ; compare BIT 0 from character value and column\n        rra\n        ld      a, 256-(BLp64_END_LOOP-BLp64_SKIP_RLC) ; instruction DJNZ skipping rotation\n        jr      nc, BLp64_NOT_RLC             ; decide based on BIT 0 comparison\n        ld      a, 256-(BLp64_END_LOOP-BLp64_INIT_RLC) ; instruction DJNZ using rotation\nBLp64_NOT_RLC:\n        ld      (BLp64_END_LOOP - 1), a       ; modify DJNZ instruction directly\n; Check the half screen byte to be changed, self-modifying the code accordingly\n        srl     c               ; check BIT 0 from current column\n        ld      a, %00001111    ; mask to change left half of the screen byte\n        jr      nc, BLp64_SCR_LEFT    ; decide based on odd or even column\n        cpl                     ; mask to change right half of the screen byte\nBLp64_SCR_LEFT:\n        ld      (BLp64_SCR_MASK \u002B 1), a   ; modify screen mask value directly\n        cpl\n        ld      (BLp64_FONT_MASK \u002B 1), a  ; modify font mask value directly\n; Calculate location of the first byte to be changed on screen\n; The row value is a 5 bits value (0-23), here represented as %000RRrrr\n; The column value is a 6 bits value (0-63), here represented as %00CCCCCc\n; Formula: 0x4000 \u002B ((row \u0026 0x18) \u003C\u003C 8) \u002B ((row \u0026 0x07) \u003C\u003C 5) \u002B (col \u003E\u003E 1)\n        inc     hl              ; now HL references ROW address\n        ld      a, (hl)         ; now A = %000RRrrr\n        call    0e9eh           ; now HL = %010RR000rrr00000\n        add     hl, bc          ; now HL = %010RR000rrrCCCCC\n        ex      de, hl          ; now DE = %010RR000rrrCCCCC\n                                ; and e=char -\u003E l=char\n; Calculate location of the character font data in p64_charset\n; Formula: p64_charset \u002B 7 * INT ((char-32)/2) - 1\n        ld      h, b            ; now HL = char (because b=0)\n        srl     l               ; now HL = INT (char/2)\n        ld      c, l            ; now BC = INT (char/2)\n        add     hl, hl          ; now HL = 2 * INT (char/2)\n        add     hl, hl          ; now HL = 4 * INT (char/2)\n        add     hl, hl          ; now HL = 8 * INT (char/2)\n        sbc     hl, bc          ; now HL = 7 * INT (char/2)\n        ld      bc, p64_charset - 71h\n        add     hl, bc          ; now HL = p64_charset \u002B 7 * INT (char/2) - 0x71\n\n; Main loop to copy 8 font bytes into screen (1 blank \u002B 7 from font data)\n        xor     a               ; first font byte is always blank\n        ld      b, 8            ; execute loop 8 times\nBLp64_INIT_RLC:\n        rlca                    ; switch position between bits 0-3 and bits 4-7\n        rlca\n        rlca\n        rlca\nBLp64_SKIP_RLC:\n; -----------------------------------------------------------------------------\n; STANDARD OR INVERSE\n;\nBLp64_INV_C:  nop                     ; either \u0027NOP\u0027 or \u0027CPL\u0027 (modified)\n; -----------------------------------------------------------------------------\nBLp64_FONT_MASK:\n        and     %11110000       ; mask half of the font byte\n        ld      c, a            ; store half of the font byte in C\n        ld      a, (de)         ; get screen byte\nBLp64_SCR_MASK:\n        and     %00001111       ; mask half of the screen byte\n        or      c               ; combine half screen and half font\n        ld      (de), a         ; write result back to screen\n        inc     d               ; next screen location\n        inc     hl              ; next font data location\n        ld      a, (hl)         ; store next font byte in A\n        djnz    BLp64_INIT_RLC        ; repeat loop 8 times (this instruction gets modified)\nBLp64_END_LOOP:\n        ; attributes\n        ld de,(p64_coords)       ; grab coords\n        and a                    ; clear carry\n        rr e                     ; divide x by 2 to get bytes instead of nybbles\n        ld a, d                  ; Get Y coord \n        sra a                    ; \n        sra a                    ; \n        sra a                    ; Multiply by 8 60155 203 47\n        add a, 88                ; Add to attrbute base address\n        ld h, a                  ; Put high byte value for attribute into H.\n        ld a, d                  ; get y value again\n        and 7                    ; set within third \n        rrca                     ; \n        rrca                     ; \n        rrca                     ; \n        add a, e                 ; add in x value\n        ld l, a                  ; Put low byte for attribute into l\n        ld a, (23693)            ; Get permanent Colours from System Variable\n        ld (hl), a               ; Write new attribute\n                        \n        pop     hl              ; restore AT_COL address\n        inc     (hl)            ; next column\n        bit     6, (hl)         ; column lower than 64?\n        ret     z               ; return if so\nBLp64_NEXT_ROW:\n        ld      (hl), b         ; reset AT_COL\n        inc     hl              ; store AT_ROW address in HL\n        inc     (hl)            ; next row\n        ld      a, (hl)\n        cp      24              ; row lower than 23?\n        ret     c               ; return if so\n        ld      (hl), b         ; reset AT_ROW\n        ret                     ; done!\n         \nend asm\np64coords:\nasm\np64_coords:\n       defb 0;  X Coordinate store  \n       defb 0;  Y Coordinate Store \np64_charset:         ; 60230\n        DEFB 2,2,2,2,0,2,0                   ; Space !\n        DEFB 80,82,7,2,7,2,0                 ; \u0022 #\n        DEFB 37,113,66,114,20,117,32         ; $ %\n        DEFB 34,84,32,96,80,96,0             ; \u0026 \u0027\n        DEFB 36,66,66,66,66,36,0             ; ( )\n        DEFB 0,82,34,119,34,82,0             ; * \u002B\n        DEFB 0,0,0,7,32,32,64                ; , -\n        DEFB 1,1,2,2,100,100,0               ; . /\n        DEFB 34,86,82,82,82,39,0             ; 0 1\n        DEFB 34,85,18,33,69,114,0            ; 2 3\n        DEFB 87,84,118,17,21,18,0            ; 4 5\n        DEFB 55,65,97,82,84,36,0             ; 6 7\n        DEFB 34,85,37,83,85,34,0             ; 8 9 \n        DEFB 0,2,32,0,34,2,4                 ; : ;\n        DEFB 0,16,39,64,39,16,0              ; \u003C =\n        DEFB 2,69,33,18,32,66,0              ; \u003E ?\n        DEFB 98,149,183,181,133,101,0        ; @ A                  \n        DEFB 98,85,100,84,85,98,0            ; B C\n        DEFB 103,84,86,84,84,103,0           ; D E\n        DEFB 114,69,116,71,69,66,0           ; F G\n        DEFB 87,82,114,82,82,87,0            ; H I \n        DEFB 53,21,22,21,85,37,0             ; J K\n        DEFB 69,71,71,69,69,117,0            ; L M \n        DEFB 82,85,117,117,85,82,0           ; N O\n        DEFB 98,85,85,103,71,67,0            ; P Q\n        DEFB 98,85,82,97,85,82,0             ; R S\n        DEFB 117,37,37,37,37,34,0            ; T U\n        DEFB 85,85,85,87,39,37,0             ; V W\n        DEFB 85,85,37,82,82,82,0             ; X Y\n        DEFB 119,20,36,36,68,119,0           ; Z [\n        DEFB 71,65,33,33,17,23,0             ; \\ ]\n        DEFB 32,112,32,32,32,47,0            ; ^ _\n        DEFB 32,86,65,99,69,115,0            ; \u00A3 a\n        DEFB 64,66,101,84,85,98,0            ; b c\n        DEFB 16,18,53,86,84,35,0             ; d e\n        DEFB 32,82,69,101,67,69,2            ; f g \n        DEFB 66,64,102,82,82,87,0            ; h i\n        DEFB 20,4,53,22,21,85,32             ; j k \n        DEFB 64,69,71,71,85,37,0             ; l m \n        DEFB 0,98,85,85,85,82,0              ; n o \n        DEFB 0,99,85,85,99,65,65             ; p q\n        DEFB 0,99,84,66,65,70,0              ; r s\n        DEFB 64,117,69,69,85,34,0            ; t u\n        DEFB 0,85,85,87,39,37,0              ; v w\n        DEFB 0,85,85,35,81,85,2              ; x y\n        DEFB 0,113,18,38,66,113,0            ; z {\n        DEFB 32,36,34,35,34,36,0             ; | {\n        DEFB 6,169,86,12,6,9,6               ; ~ (c)\np64_END:\nEnd Asm\nEnd Sub\n\u0060\u0060\u0060\n\nThere\u0027s an example of usage here:\n\n\u0060\u0060\u0060\nREM Example\nDIM n,x,y as uInteger\nCLS\nFOR n=1 to 1000\n   y=rnd*23\n   x=rnd*62\n   \n   ink rnd*8\n   printat64(y, x)\n   print64 (\u0022ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0022(n MOD 26 TO n MOD 26))\nNEXT n\nEND\n\u0060\u0060\u0060\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/print64.bas.md"
    },
    {
        "keyword": "PRINTAT64 (LIBRARY SUBROUTINE)",
        "description": "The 64 column printing routine allows text to be 4 pixels wide instead of 8.\nIt is NOT proportional printing, but this is still useful for lining things up in columns.\n\nThis routine has been adopted as an included library - so you may include it with\n\n\u0060\u0060\u0060\n#include \u003Cprint64.bas\u003E\n\u0060\u0060\u0060\n\n**Usage**\n\n\u0060\u0060\u0060\nprintat64(y,x)\n\u0060\u0060\u0060\n\nMoves the print64 system\u0027s print cursor to row Y, column X. Note that \u00600 \u003C= x \u003C= 63\u0060 - that is the range of values\nfor X can be up to 63. The range of values for Y is the normal 0-23.\n\n* Note that the print64 system\u0027s cursor position is independent from that of the ZX Basic Print routine,\nor any other, such as the print42 system.\n\n\u0060\u0060\u0060\nprintat64(STRING)\n\u0060\u0060\u0060\n\n\nPrints the string to the screen at the current Print64 co-ordinates. It does so in the current permanent colours.\n\nNOTE: The ZX Spectrum\u0027s attribute system is encoded into the hardware as a 32 character grid. Print64 does its best,\nbut changing the paper/bright/flash colour from the background is likely to look imperfect as the attribute\nblocks cannot line up well with the pixel blocks.\n\n**CODE**\n\n* There is a version of this code included with the compiler\n(though the version listed here may or may not be more recent). Code converted to ZXBasic by Britlion,\nbased on Andrew Owen\u0027s 64 Character code http://www.worldofspectrum.org/forums/showpost.php?p=167447\u0026postcount=1\n\n\n\u0060\u0060\u0060\nSUB printat64 (y as uByte, x as uByte)\n   IF y\u003C24 AND x\u003C64 then \n     POKE @p64coords,x\n     POKE @p64coords\u002B1,y\n   ELSE\n     asm\n       rst     8               ; error \u00225 \tOut of screen\u0022\n       defb    4\n     end asm\n   END IF\nEND SUB\n\nSUB print64 (characters$ as String)\nASM\n; This frankencode created by Paul Fisher, Andrew Owen, Chris Born and Einar Saukas\n; TODO:\n; * Inverse\n; * Bold (which will use a Second font)\nLD L,(IX\u002B4)\nLD H,(IX\u002B5) ; Get String address of characters$ into HL.\n; Load BC with length of string, and move HL to point to first character.\n        ld c, (hl)               ; 60020 78 \n        inc hl                   ; 60021 35 \n        ld b, (hl)               ; 60022 70 \n        inc hl                   ; 60023 35 \n; Test string length. If Zero, exit.\n        ld a, c                  ; 60024 121\n        or b                     ; 60025 176\n        jp z, p64_END         ; 60026 200\nexamineChar: \n        ld a, (hl)               ; Grab the character\n        cp 128                   ; too high to print?\n        jr nc, nextChar            ; then we go to next.\nnewLine:\n        cp 13                    ; Is this a newline character? 60056 254 13 \n        jr nz, p64_isPrintable   ; If not, hop to testing to see if we can print this 60058 32  13 \n        push hl\n        push bc\n        ld b,0\n        ld hl, p64_coords      ; Get coords 60060 237 91  68  235\n        call BLp64_NEXT_ROW         ; Go to next line.     ; 60064 205 58  235\n        pop bc\n        pop hl\n        ld (p64_coords), de    ; 60067 237 83  68  235\n        jr nextChar              ; 60071 24  11 \np64_isPrintable:\n        cp 31                    ; Bigger than 31? 60073 254 31 \n        jr c, nextChar           ; If not, get the next one. 60075 56  7  \n        \n        push hl                  ; Save position 60077 229\n        push bc                  ; Save Count   60078 197\n        call p64_PrintChar       ; Call Print SubRoutine\n        \n       \n       \n        pop bc                   ; Recover length count  60082 193\n        pop hl                   ; Recover Position 60083 225\nnextChar:\n        inc hl                   ; Point to next character 60084 35 \n        dec bc                   ; Count off this character 60085 11 \n        ld a, b                  ; Did we run out? 60086 120\n        or c                     ; 60087 177\n        jr nz, examineChar       ; If not, examine the next one 60088 32  193\n        jp p64_END               ; Otherwise hop to END. 60090 201\np64_PrintChar:\n; Arrives with A as a byte to print.\n    ld hl,p64_coords\n    push    hl              ; save COL address for later\n    ld      e, a            ; store character value in E\n    ld      b,0\n    ld      c, (hl)         ; store current column in BC\n    ; Check if character font must be rotated, self-modifying the code accordingly\n        xor     c               ; compare BIT 0 from character value and column\n        rra\n        ld      a, 256-(BLp64_END_LOOP-BLp64_SKIP_RLC) ; instruction DJNZ skipping rotation\n        jr      nc, BLp64_NOT_RLC             ; decide based on BIT 0 comparison\n        ld      a, 256-(BLp64_END_LOOP-BLp64_INIT_RLC) ; instruction DJNZ using rotation\nBLp64_NOT_RLC:\n        ld      (BLp64_END_LOOP - 1), a       ; modify DJNZ instruction directly\n; Check the half screen byte to be changed, self-modifying the code accordingly\n        srl     c               ; check BIT 0 from current column\n        ld      a, %00001111    ; mask to change left half of the screen byte\n        jr      nc, BLp64_SCR_LEFT    ; decide based on odd or even column\n        cpl                     ; mask to change right half of the screen byte\nBLp64_SCR_LEFT:\n        ld      (BLp64_SCR_MASK \u002B 1), a   ; modify screen mask value directly\n        cpl\n        ld      (BLp64_FONT_MASK \u002B 1), a  ; modify font mask value directly\n; Calculate location of the first byte to be changed on screen\n; The row value is a 5 bits value (0-23), here represented as %000RRrrr\n; The column value is a 6 bits value (0-63), here represented as %00CCCCCc\n; Formula: 0x4000 \u002B ((row \u0026 0x18) \u003C\u003C 8) \u002B ((row \u0026 0x07) \u003C\u003C 5) \u002B (col \u003E\u003E 1)\n        inc     hl              ; now HL references ROW address\n        ld      a, (hl)         ; now A = %000RRrrr\n        call    0e9eh           ; now HL = %010RR000rrr00000\n        add     hl, bc          ; now HL = %010RR000rrrCCCCC\n        ex      de, hl          ; now DE = %010RR000rrrCCCCC\n                                ; and e=char -\u003E l=char\n; Calculate location of the character font data in p64_charset\n; Formula: p64_charset \u002B 7 * INT ((char-32)/2) - 1\n        ld      h, b            ; now HL = char (because b=0)\n        srl     l               ; now HL = INT (char/2)\n        ld      c, l            ; now BC = INT (char/2)\n        add     hl, hl          ; now HL = 2 * INT (char/2)\n        add     hl, hl          ; now HL = 4 * INT (char/2)\n        add     hl, hl          ; now HL = 8 * INT (char/2)\n        sbc     hl, bc          ; now HL = 7 * INT (char/2)\n        ld      bc, p64_charset - 71h\n        add     hl, bc          ; now HL = p64_charset \u002B 7 * INT (char/2) - 0x71\n\n; Main loop to copy 8 font bytes into screen (1 blank \u002B 7 from font data)\n        xor     a               ; first font byte is always blank\n        ld      b, 8            ; execute loop 8 times\nBLp64_INIT_RLC:\n        rlca                    ; switch position between bits 0-3 and bits 4-7\n        rlca\n        rlca\n        rlca\nBLp64_SKIP_RLC:\n; -----------------------------------------------------------------------------\n; STANDARD OR INVERSE\n;\nBLp64_INV_C:  nop                     ; either \u0027NOP\u0027 or \u0027CPL\u0027 (modified)\n; -----------------------------------------------------------------------------\nBLp64_FONT_MASK:\n        and     %11110000       ; mask half of the font byte\n        ld      c, a            ; store half of the font byte in C\n        ld      a, (de)         ; get screen byte\nBLp64_SCR_MASK:\n        and     %00001111       ; mask half of the screen byte\n        or      c               ; combine half screen and half font\n        ld      (de), a         ; write result back to screen\n        inc     d               ; next screen location\n        inc     hl              ; next font data location\n        ld      a, (hl)         ; store next font byte in A\n        djnz    BLp64_INIT_RLC        ; repeat loop 8 times (this instruction gets modified)\nBLp64_END_LOOP:\n        ; attributes\n        ld de,(p64_coords)       ; grab coords\n        and a                    ; clear carry\n        rr e                     ; divide x by 2 to get bytes instead of nybbles\n        ld a, d                  ; Get Y coord \n        sra a                    ; \n        sra a                    ; \n        sra a                    ; Multiply by 8 60155 203 47\n        add a, 88                ; Add to attrbute base address\n        ld h, a                  ; Put high byte value for attribute into H.\n        ld a, d                  ; get y value again\n        and 7                    ; set within third \n        rrca                     ; \n        rrca                     ; \n        rrca                     ; \n        add a, e                 ; add in x value\n        ld l, a                  ; Put low byte for attribute into l\n        ld a, (23693)            ; Get permanent Colours from System Variable\n        ld (hl), a               ; Write new attribute\n                        \n        pop     hl              ; restore AT_COL address\n        inc     (hl)            ; next column\n        bit     6, (hl)         ; column lower than 64?\n        ret     z               ; return if so\nBLp64_NEXT_ROW:\n        ld      (hl), b         ; reset AT_COL\n        inc     hl              ; store AT_ROW address in HL\n        inc     (hl)            ; next row\n        ld      a, (hl)\n        cp      24              ; row lower than 23?\n        ret     c               ; return if so\n        ld      (hl), b         ; reset AT_ROW\n        ret                     ; done!\n         \nend asm\np64coords:\nasm\np64_coords:\n       defb 0;  X Coordinate store  \n       defb 0;  Y Coordinate Store \np64_charset:         ; 60230\n        DEFB 2,2,2,2,0,2,0                   ; Space !\n        DEFB 80,82,7,2,7,2,0                 ; \u0022 #\n        DEFB 37,113,66,114,20,117,32         ; $ %\n        DEFB 34,84,32,96,80,96,0             ; \u0026 \u0027\n        DEFB 36,66,66,66,66,36,0             ; ( )\n        DEFB 0,82,34,119,34,82,0             ; * \u002B\n        DEFB 0,0,0,7,32,32,64                ; , -\n        DEFB 1,1,2,2,100,100,0               ; . /\n        DEFB 34,86,82,82,82,39,0             ; 0 1\n        DEFB 34,85,18,33,69,114,0            ; 2 3\n        DEFB 87,84,118,17,21,18,0            ; 4 5\n        DEFB 55,65,97,82,84,36,0             ; 6 7\n        DEFB 34,85,37,83,85,34,0             ; 8 9 \n        DEFB 0,2,32,0,34,2,4                 ; : ;\n        DEFB 0,16,39,64,39,16,0              ; \u003C =\n        DEFB 2,69,33,18,32,66,0              ; \u003E ?\n        DEFB 98,149,183,181,133,101,0        ; @ A                  \n        DEFB 98,85,100,84,85,98,0            ; B C\n        DEFB 103,84,86,84,84,103,0           ; D E\n        DEFB 114,69,116,71,69,66,0           ; F G\n        DEFB 87,82,114,82,82,87,0            ; H I \n        DEFB 53,21,22,21,85,37,0             ; J K\n        DEFB 69,71,71,69,69,117,0            ; L M \n        DEFB 82,85,117,117,85,82,0           ; N O\n        DEFB 98,85,85,103,71,67,0            ; P Q\n        DEFB 98,85,82,97,85,82,0             ; R S\n        DEFB 117,37,37,37,37,34,0            ; T U\n        DEFB 85,85,85,87,39,37,0             ; V W\n        DEFB 85,85,37,82,82,82,0             ; X Y\n        DEFB 119,20,36,36,68,119,0           ; Z [\n        DEFB 71,65,33,33,17,23,0             ; \\ ]\n        DEFB 32,112,32,32,32,47,0            ; ^ _\n        DEFB 32,86,65,99,69,115,0            ; \u00A3 a\n        DEFB 64,66,101,84,85,98,0            ; b c\n        DEFB 16,18,53,86,84,35,0             ; d e\n        DEFB 32,82,69,101,67,69,2            ; f g \n        DEFB 66,64,102,82,82,87,0            ; h i\n        DEFB 20,4,53,22,21,85,32             ; j k \n        DEFB 64,69,71,71,85,37,0             ; l m \n        DEFB 0,98,85,85,85,82,0              ; n o \n        DEFB 0,99,85,85,99,65,65             ; p q\n        DEFB 0,99,84,66,65,70,0              ; r s\n        DEFB 64,117,69,69,85,34,0            ; t u\n        DEFB 0,85,85,87,39,37,0              ; v w\n        DEFB 0,85,85,35,81,85,2              ; x y\n        DEFB 0,113,18,38,66,113,0            ; z {\n        DEFB 32,36,34,35,34,36,0             ; | {\n        DEFB 6,169,86,12,6,9,6               ; ~ (c)\np64_END:\nEnd Asm\nEnd Sub\n\u0060\u0060\u0060\n\nThere\u0027s an example of usage here:\n\n\u0060\u0060\u0060\nREM Example\nDIM n,x,y as uInteger\nCLS\nFOR n=1 to 1000\n   y=rnd*23\n   x=rnd*62\n   \n   ink rnd*8\n   printat64(y, x)\n   print64 (\u0022ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0022(n MOD 26 TO n MOD 26))\nNEXT n\nEND\n\u0060\u0060\u0060\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/print64.bas.md"
    },
    {
        "keyword": "SCREEN(LIBRARY FUNCTION)",
        "description": "**Syntax**\n\n\u0060\u0060\u0060\nSCREEN$(row, col)\n\u0060\u0060\u0060\n\n**Description**\n\nReturns a string with the character (if possible) located at the given screen coordinate (row, column).\nThe character in the screen must exactly match the one in the current font character set being used.\n\n**Requirements**\n\nSCREEN is a library function to be included with the following command:\n\n\n\u0060\u0060\u0060\n#include \u003Cscreen.bas\u003E\n\u0060\u0060\u0060\n\n**Sample usage**\n\n\u0060\u0060\u0060\n#include \u003Cscreen.bas\u003E\nPRINT AT 9, 10; \u0022A\u0022\nLET c$ = SCREEN$(9, 10)\nPRINT AT 0, 0; \u0022The character at 9, 10 is \u0022; c$\n\u0060\u0060\u0060\n\n**Remarks**\n\n* This function extends the one in Sinclair BASIC (and it\u0027s compatible with it) since it also allows rows 22 and 23.\n* When using _--sinclair_ cmd line parameter this function is already available (i.e. no _#include \u003Cscreen.bas\u003E_ sentence is needed)\n\n**See also**\n\n* [ CSRLIN ](https://github.com/boriel/zxbasic/blob/master/docs/library/csrlin_.md)\n* [ POS](https://github.com/boriel/zxbasic/blob/master/docs/library/pos_.md)\n* [ AT ](https://github.com/boriel/zxbasic/blob/master/docs/library/../at.md)\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/library/screen.md"
    },
    {
        "keyword": "BAND",
        "description": "Performs the _Bitwise Conjunction_ and returns 1 for every bit if and only if both bits are 1.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  0  | 0  |  0 |\n|  0  | 1  | 0 |\n|  1  | 0  |  0 |\n|  1  | 1  |  1 |\n\n**Example**\n\nBinary \u0022mask\u0022 that will get only the 4 rightmost bits 0 1 2 3 of a number:\n\n\u0060PRINT BIN 01110111 bAND BIN 00001111\u0060 will print 3, which is 0111\u0060\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/bitwiselogic.md"
    },
    {
        "keyword": "BNOT",
        "description": "Performs the _Bitwise Negation_ and returns _1_ if the arguments is _0_ and vice versa.\nBasically it flips all the bits in an integer number.\n\n| a  |result |\n|:----:|:------:|\n|  0  | 1  |\n|  1  | 0  |\n\n**#Example**\n\nInvert the first cell (upper-leftmost) in the screen:\n\n\u0060\u0060\u0060\nPRINT AT 0, 0; \u0022A\u0022;\nFOR i = 0 TO 3\n    POKE 16384 \u002B 256 * i, bNOT PEEK(16384 \u002B 256 * i)\nNEXT\n\u0060\u0060\u0060\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/bitwiselogic.md"
    },
    {
        "keyword": "BOR",
        "description": "Performs the _Bitwise Disjunction_ and returns 1 if any of the arguments is 1.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  0  | 0 |  0 |\n|  0  | 1  | 1 |\n|  1  | 0 |  1 |\n|  1  | 1  |  1 |\n\n**Example**\n\nEnsure an ASCII letter is always in lowercase:\n\n\u0060PRINT CHR$(CODE \u0022A\u0022 OR BIN 10000)\u0060 will print \u0060a\u0060 because lowercase letters have bit 5 set.\n\n,",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/bitwiselogic.md"
    },
    {
        "keyword": "BXOR",
        "description": "Performs a logical XOR and returns 1 if one and only one of the arguments is 1, 0 if both bits are the same.\nIn essence, returns 1 ONLY if one of the arguments is 1. \n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  0  | 0 |  0 |\n|  0  | 1  | 1 |\n|  1  | 0 |  1 |\n|  1  | 1  |  0 |\n---\n**Example**\n\nFlips an ASCII letter from lower to uppercase and vice versa\n\n\u0060PRINT CHR$(CODE \u0022A\u0022 bXOR BIN 10000)\u0060\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/bitwiselogic.md"
    },
    {
        "keyword": "AND",
        "description": "Performs the _Logical Conjunction_ and returns _TRUE_ if and only if both arguments are _TRUE_.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  False  | False |  False |\n|  False  | True  |  False |\n|  True  | False |  False |\n|  True  | True  |  True |\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/operators.md#AND"
    },
    {
        "keyword": "NOT",
        "description": "Performs the _Logical Negation_ and returns _TRUE_ if the arguments is _False_ and vice versa.\n\n| a  | result |\n|:----:|:----:|\n|  False  | True |\n|  True  | False |\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/operators.md#AND"
    },
    {
        "keyword": "OR",
        "description": "Performs the _Logical Disjunction_ and returns _TRUE_ if any of the arguments is _TRUE_.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  False  | False |  False |\n|  False  | True  |  True |\n|  True  | False |  True |\n|  True  | True  |  True |\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/operators.md#AND"
    },
    {
        "keyword": "XOR",
        "description": "Performs a logical XOR and returns TRUE if one of the arguments is true and one of the arguments is false.\nIn essence, returns true if ONLY one of the arguments is true.\n\n| a  | b  | result |\n|:----:|:----:|:------:|\n|  False  | False |  False |\n|  False  | True  |  True |\n|  True  | False |  True |\n|  True  | True  |  False |\n\n",
        "link": "https://github.com/boriel/zxbasic/blob/master/docs/operators.md#AND"
    }
]