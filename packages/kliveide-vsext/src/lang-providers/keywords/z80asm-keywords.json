[{
        "groupName": "8-Bit Load Group",
        "keyword": "LD r, r\u0027",
        "operation": "r, \u2190 r\u0027",
        "opcode": "LD",
        "operands": "r, r\u0027\n01 r r\u0027",
        "conditionBitsAffected": "None.",
        "description": "The contents of any register r\u0027 are loaded to any other register r. r, r\u0027 identifies any of the \nregisters A, B, C, D, E, H, or L, assembled as follows in the object code:\nRegister r, C\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States MHz E.T.\n14 1.0",
        "example": "If the H Register contains the number 8Ah, and the E register contains 10h, the instruction \nLD H, E results in both registers containing 10h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=85"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD r,n",
        "operation": "r \u2190 n",
        "opcode": "LD",
        "operands": "r, n\n00 r 1 1 0\nn",
        "conditionBitsAffected": "None.",
        "description": "The 8-bit integer n is loaded to any register r, in which r identifies registers A, B, C, D, E, \nH, or L, assembled as follows in the object code:\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "Upon the execution of an LD E, A5h instruction, Register E contains A5h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=86"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD r, (HL)",
        "operation": "r \u2190 (HL)",
        "opcode": "LD",
        "operands": "r, (HL)\n01 r 1 1 0",
        "conditionBitsAffected": "None.",
        "description": "The 8-bit contents of memory location (HL) are loaded to register r, in which r identifies \nregisters A, B, C, D, E, H, or L, assembled as follows in the object code:\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If register pair HL contains the number 75A1h, and memory address 75A1h contains byte \n58h, the execution of LD C, (HL) results in 58h in Register C.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=88"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD r, (IX\u002Bd)",
        "operation": "r \u2190 (IX\u002Bd)",
        "opcode": "LD",
        "operands": "r, (IX\u002Bd)\n11011 1 0 1\nDD\n01 r 1 1 0\nd",
        "conditionBitsAffected": "None.",
        "description": "The (IX\u002Bd) operand (i.e., the contents of Index Register IX summed with two\u2019s-comple-\nment displacement integer d) is loaded to register r, in which r identifies registers A, B, C, \nD, E, H, or L, assembled as follows in the object code:\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3, 5, 2.50\n3)",
        "example": "If Index Register IX contains the number 25AFh, the instruction LD B, (IX\u002B19h) allows \nthe calculation of the sum 25AFh \u002B 19h, which points to memory location 25C8h. If this \naddress contains byte 39h, the instruction results in Register B also containing 39h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=89"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD r, (IY\u002Bd)",
        "operation": "r \u2190 (IY\u002BD)",
        "opcode": "LD",
        "operands": "r, (lY\u002Bd)\nFD\n11111 1 0 1\n01 r 1 1 0\nd",
        "conditionBitsAffected": "None.",
        "description": "The operand (lY\u002Bd) loads the contents of Index Register IY summed with two\u2019s-comple-\nment displacement integer, d, to register r, in which r identifies registers A, B, C, D, E, H, \nor L, assembled as follows in the object code:\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If Index Register IY contains the number 25AFh, the instruction LD B, (IY\u002B19h) allows \nthe calculation of the sum 25AFh \u002B 19h, which points to memory location 25C8h. If this \naddress contains byte 39h, the instruction results in Register B also containing 39h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=91"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (HL), r",
        "operation": "(HL) \u2190 r",
        "opcode": "LD",
        "operands": "(HL), r\n01101 r",
        "conditionBitsAffected": "None.",
        "description": "The contents of register r are loaded to the memory location specified by the contents of \nthe HL register pair. The r symbol identifies registers A, B, C, D, E, H, or L, assembled as \nfollows in the object code:\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If the contents of register pair HL specify memory location 2146h and Register B contains \nbyte 29h, then upon the execution of an LD (HL), B instruction, memory address 2146h \nalso contains 29h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=93"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (IX\u002Bd), r",
        "operation": "(IX\u002Bd) \u2190 r",
        "opcode": "LD",
        "operands": "(IX\u002Bd), r \nDD\n11011 1 0 1\n01101 r\nd",
        "conditionBitsAffected": "None.",
        "description": "The contents of register r are loaded to the memory address specified by the contents of \nIndex Register IX summed with d, a two\u2019s-complement displacement integer. The r sym-\nbol identifies registers A, B, C, D, E, H, or L, assembled as follows in the object code:\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the C register contains byte 1Ch, and Index Register IX contains 3100h, then the \ninstruction LID (IX \u002B 6h), C performs the sum 3100h \u002B 6h and loads 1Ch to memory \nlocation 3106h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=95"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (IY\u002Bd), r",
        "operation": "(lY\u002Bd) \u2190 r",
        "opcode": "LD",
        "operands": "(lY\u002Bd), r\nFD\n11111 1 0 1\n01101 r\nd",
        "conditionBitsAffected": "None.",
        "description": "The contents of resister r are loaded to the memory address specified by the sum of the \ncontents of Index Register IY and d, a two\u2019s-complement displacement integer. The r sym-\nbol is specified according to the following table.\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the C register contains byte 48h, and Index Register IY contains 2A11h, then the \ninstruction LD (IY \u002B 4h), C performs the sum 2A11h \u002B 4h, and loads 48h to memory \nlocation 2A15.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=97"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (HL), n",
        "operation": "(HL) \u2190 n",
        "opcode": "LD",
        "operands": "(HL), n\n36\n00101 1 1 0\nn",
        "conditionBitsAffected": "None.",
        "description": "The n integer is loaded to the memory address specified by the contents of the HL register \npair.\nM Cycles T States 4 MHz E.T.\n3 10 (4, 3, 3) 2.50",
        "example": "If the HL register pair contains 4444h, the instruction LD (HL), 28h results in the mem-\nory location 4444h containing byte 28h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=99"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (IX\u002Bd), n",
        "operation": "(IX\u002Bd) \u2190 n",
        "opcode": "LD",
        "operands": "(IX\u002Bd), n\nDD\n11011 1 0 1\n36\n00101 1 1 0\nd\nn",
        "conditionBitsAffected": "None.",
        "description": "The n operand is loaded to the memory address specified by the sum of Index Register IX \nand the two\u2019s complement displacement operand d.\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3,5,3) 4.75",
        "example": "If Index Register IX contains the number 219Ah, then upon execution of an LD (IX\u002B5h), \n5Ah instruction, byte 5Ah is contained in memory address 219Fh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=100"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (IY\u002Bd), n",
        "operation": "(lY\u002Bd) \u2190 n",
        "opcode": "LD",
        "operands": "(lY\u002Bd), n\nFD\n11111 1 0 1\n36\n00101 1 1 0\nd\nn",
        "conditionBitsAffected": "None.",
        "description": "The n integer is loaded to the memory location specified by the contents of Index Register \nsummed with the two\u2019s-complement displacement integer, d.\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3, 5, 3) 2.50",
        "example": "If Index Register IY contains the number A940h, the instruction LD (IY\u002B10h), 97h \nresults in byte 97h in memory location A950h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=101"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD A, (BC)",
        "operation": "A \u2190 (BC)",
        "opcode": "LD",
        "operands": "A, (BC)\n0A\n00010 0 1 0",
        "conditionBitsAffected": "None.",
        "description": "The contents of the memory location specified by the contents of the BC register pair are \nloaded to the Accumulator.\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If the BC register pair contains the number 4747h, and memory address 4747h contains \nbyte 12h, then the instruction LD A, (BC) results in byte 12h in Register A.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=102"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD A, (DE)",
        "operation": "A \u2190 (DE)",
        "opcode": "LD",
        "operands": "A, (DE)\n1A\n00011 0 1 0",
        "conditionBitsAffected": "None.",
        "description": "The contents of the memory location specified by the register pair DE are loaded to the \nAccumulator.\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If the DE register pair contains the number 30A2h and memory address 30A2h contains \nbyte 22h, then the instruction LD A, (DE) results in byte 22h in Register A.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=103"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD A, (nn)",
        "operation": "A \u2190 (nn)",
        "opcode": "LD",
        "operands": "A, (nn)\n3A\n00111 0 1 0\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of the memory location specified by the operands nn are loaded to the Accu-\nmulator. The first n operand after the op code is the low-order byte of a 2-byte memory \naddress.\nM Cycles T States 4 MHz E.T.\n4 13 (4, 3, 3, 3) 3.25",
        "example": "If nn contains 8832h and memory address 8832h contains byte 04h, then upon the execu-\ntion of an LD A, (nn) instruction, the 04h byte is in the Accumulator.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=104"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (BC), A",
        "operation": "(BC) \u2190 A",
        "opcode": "LD",
        "operands": "(BC), A\n02\n00000 0 1 0",
        "conditionBitsAffected": "None.",
        "description": "The contents of the Accumulator are loaded to the memory location specified by the con-\ntents of the register pair BC.\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If the Accumulator contains 7Ah and the BC register pair contains 1212h the instruction \nLD (BC), A results in 7Ah in memory location 1212h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=105"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (DE), A",
        "operation": "(DE) \u2190 A",
        "opcode": "LD",
        "operands": "(DE), A\n12\n00001 0 1 0",
        "conditionBitsAffected": "None.",
        "description": "The contents of the Accumulator are loaded to the memory location specified by the con-\ntents of the DE register pair.\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If register pair DE contains 1128h and the Accumulator contains byte A0h, then the exe-\ncution of a LD (DE), A instruction results in A0h being stored in memory location 1128h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=106"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD (nn), A",
        "operation": "(nn) \u2190 A",
        "opcode": "LD",
        "operands": "(nn), A\n32\n00101 0 1 0\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of the Accumulator are loaded to the memory address specified by the oper-\nand nn. The first n operand after the op code is the low-order byte of nn.\nM Cycles T States 4 MHz E.T.\n4 13 (4, 3, 3, 3) 3.25",
        "example": "If the Accumulator contains byte D7h, then executing an LD (3141h), AD7h instruction \nresults in memory location 3141h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=107"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD A, I",
        "operation": "A \u2190 1",
        "opcode": "LD",
        "operands": "A, I\nED\n11110 1 0 1\n57\n01001 1 1 1",
        "conditionBitsAffected": "S is set if the I Register is negative; otherwise, it is reset.\nZ is set if the I Register is 0; otherwise, it is reset.\nH is reset.\nP/V contains contents of IFF2.\nN is reset.\nC is not affected.\nIf an interrupt occurs during execution of this instruction, the Parity flag contains a 0.",
        "description": "The contents of the Interrupt Vector Register I are loaded to the Accumulator.\nM Cycles T States MHz E.T.\n2 9 (4, 5) 2.25",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=108"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD A, R",
        "operation": "A \u2190 R",
        "opcode": "LD",
        "operands": "A, R\nED\n11110 1 0 1\n5F\n01011 1 1 1",
        "conditionBitsAffected": "S is set if, R-Register is negative; otherwise, it is reset.\nZ is set if the R Register is 0; otherwise, it is reset.\nH is reset.\nP/V contains contents of IFF2.\nN is reset.\nC is not affected.\nIf an interrupt occurs during execution of this instruction, the parity flag contains a 0.",
        "description": "The contents of Memory Refresh Register R are loaded to the Accumulator.\nM Cycles T States MHz E.T.\n2 9 (4, 5) 2.25",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=109"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD I,A",
        "operation": "I \u2190 A",
        "opcode": "LD",
        "operands": "I, A\nED\n11110 1 0 1\n47\n01000 1 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of the Accumulator are loaded to the Interrupt Control Vector Register, I.\nM Cycles T States MHz E.T.\n2 9 (4, 5) 2.25",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=110"
    },
    {
        "groupName": "8-Bit Load Group",
        "keyword": "LD R, A",
        "operation": "R \u2190 A",
        "opcode": "LD",
        "operands": "R, A\nED\n11110 1 0 1\n4F\n01010 1 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of the Accumulator are loaded to the Memory Refresh register R.\nM Cycles T States MHz E.T.\n2 9 (4, 5) 2.25",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=111"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD dd, nn",
        "operation": "dd \u2190 nn",
        "opcode": "LD",
        "operands": "dd, nn\n00d0d 0 0 1\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The 2-byte integer nn is loaded to the dd register pair, in which dd defines the BC, DE, \nHL, or SP register pairs, assembled as follows in the object code:\nPair dd\nBC 00\nDE 01\nHL 10\nSP 11\nThe first n operand after the op code is the low-order byte.\nM Cycles T States 4 MHz E.T.\n2 10 (4, 3, 3) 2.50",
        "example": "Upon the execution of an LD HL, 5000h instruction, the HL register pair contains 5000h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=113"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD IX, nn",
        "operation": "IX \u2190 nn",
        "opcode": "LD",
        "operands": "IX, nn\nDD\n11011 1 0 1\n21\n00100 0 0 1\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The n integer is loaded to Index Register IX. The first n operand after the op code is the \nlow-order byte.\nM Cycles T States 4 MHz E.T.\n4 14 (4, 4, 3, 3) 3.50",
        "example": "Upon the execution of an LD IX, 45A2h instruction, the index register contains integer \n45A2h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=114"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD IY, nn",
        "operation": "IY \u2190 nn",
        "opcode": "LD",
        "operands": "IY, nn\nFD\n11111 1 0 1\n21\n00100 0 0 1\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The nn integer is loaded to Index Register IY. The first n operand after the op code is the \nlow-order byte.\nM Cycles T States 4 MHz E.T.\n4 14 (4, 4, 3, 3) 3.50",
        "example": "Upon the execution of a LD IY, 7733h instruction, Index Register IY contains the integer \n7733h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=115"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD HL, (nn)",
        "operation": "H \u2190 (nn \u002B 1), L \u2190 (nn)",
        "opcode": "LD",
        "operands": "HL, (nn)\n00110 0 1 0 2A\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of memory address (nn) are loaded to the low-order portion of register pair \nHL (Register L), and the contents of the next highest memory address (nn \u002B 1) are loaded \nto the high-order portion of HL (Register H). The first n operand after the op code is the \nlow-order byte of nn.\nM Cycles T States 4 MHz E.T.\n5 16 (4, 3, 3, 3, 3) 4.00",
        "example": "If address 4545h contains 37h and address 4546h contains A1h, then upon the execution \nof an LD HL, (4545h) instruction, the HL register pair contains A137h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=116"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD dd, (nn)",
        "operation": "ddh \u2190 (nn \u002B 1) ddl \u2190 (nn)",
        "opcode": "LD",
        "operands": "dd, (nn)\nED\n11110 1 0 1\n01d1d 0 1 1\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of address (nn) are loaded to the low-order portion of register pair dd, and the \ncontents of the next highest memory address (nn \u002B 1) are loaded to the high-order portion \nof dd. Register pair dd defines BC, DE, HL, or SP register pairs, assembled as follows in \nthe object code:\nPair dd\nBC 00\nDE 01\nHL 10\nSP 11\nThe first n operand after the op code is the low-order byte of (nn).\nM Cycles T States 4 MHz E.T.\n6 20 (4, 4, 3, 3, 3, 3) 5.00",
        "example": "If Address 2130h contains 65h and address 2131h contains 78h, then upon the execution \nof an LD BC, (2130h) instruction, the BC register pair contains 7865h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=117"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD IX, (nn)",
        "operation": "IXh \u2190 (nn \u002B 1), IXI \u2190 (nn)",
        "opcode": "LD",
        "operands": "IX, (nn)\nDD\n11011 1 0 1\n00110 0 1 0 2A\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of the address (nn) are loaded to the low-order portion of Index Register IX, \nand the contents of the next highest memory address (nn \u002B 1) are loaded to the high-order \nportion of IX. The first n operand after the op code is the low-order byte of nn.\nM Cycles T States 4 MHz E.T.\n6 20 (4, 4, 3, 3, 3, 3) 5.00",
        "example": "If address 6666h contains 92h, and address 6667h contains DAh, then upon the execution \nof an LD IX, (6666h) instruction, Index Register IX contains DA92h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=119"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD IY, (nn)",
        "operation": "IYh \u2190 (nn \u002B 1), IYI \u2190 nn)",
        "opcode": "LD",
        "operands": "IY, (nn)\nFD\n11111 1 0 1\n00110 0 1 0 2A\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of address (nn) are loaded to the low-order portion of Index Register IY, and \nthe contents of the next highest memory address (nn \u002B 1) are loaded to the high-order por-\ntion of IY. The first n operand after the op code is the low-order byte of nn.\nM Cycles T States 4 MHz E.T.\n6 20 (4, 4, 3, 3, 3, 3) 5.00",
        "example": "If address 6666h contains 92h, and address 6667h contains DAh, then upon the execution \nof an LD IY, (6666h) instruction, Index Register IY contains DA92h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=120"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD (nn), HL",
        "operation": "(nn \u002B 1) \u2190 H, (nn) \u2190 L",
        "opcode": "LD",
        "operands": "(nn), HL\n00100 0 1 0 22\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The contents of the low-order portion of register pair HL (Register L) are loaded to mem-\nory address (nn), and the contents of the high-order portion of HL (Register H) are loaded \nto the next highest memory address (nn \u002B 1). The first n operand after the op code is the \nlow-order byte of nn.\nM Cycles T States 4 MHz E.T.\n5 16 (4, 3, 3, 3, 3) 4.00",
        "example": "If register pair HL contains 483Ah, then upon the execution of an LD (B2291 \u2013 1), HL \ninstruction, address B229h contains 3Ah and address B22Ah contains 48h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=121"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD (nn), dd",
        "operation": "(nn \u002B 1) \u2190 ddh, (nn) \u2190 ddl",
        "opcode": "LD",
        "operands": "(nn), dd\nED\n11110 1 0 1\n01d0d 0 1 1\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The low-order byte of register pair dd is loaded to memory address (nn); the upper byte is \nloaded to memory address (nn \u002B 1). Register pair dd defines either BC, DE, HL, or SP, \nassembled as follows in the object code:\nPair dd\nBC 00\nDE 01\nHL 10\nSP 11\nThe first n operand after the op code is the low-order byte of a two byte memory address.\nM Cycles T States 4 MHz E.T.\n6 20 (4, 4, 3, 3, 3, 3) 5.00",
        "example": "If register pair BC contains the number 4644h, the instruction LD (1000h), BC results in \n44h in memory location 1000h, and 46h in memory location 1001h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=122"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD (nn), IX",
        "operation": "(nn \u002B 1) \u2190 IXh, (nn) \u2190 IXI",
        "opcode": "LD",
        "operands": "(nn), IX\nDD\n11011 1 0 1\n00100 0 1 0 22\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The low-order byte in Index Register IX is loaded to memory address (nn); the upper order \nbyte is loaded to the next highest address (nn \u002B 1). The first n operand after the op code is \nthe low-order byte of nn.\nM Cycles T States 4 MHz E.T.\n6 20 (4, 4, 3, 3, 3, 3) 5.00",
        "example": "If Index Register IX contains 5A30h, then upon the execution of an LD (4392h), IX \ninstruction, memory location 4392h contains number 30h and location 4393h contains \n5Ah.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=124"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD (nn), IY",
        "operation": "(nn \u002B 1) \u2190 IYh, (nn) \u2190 IYI",
        "opcode": "LD",
        "operands": "(nn), IY\nFD\n11111 1 0 1\n00100 0 1 0 22\nn\nn",
        "conditionBitsAffected": "None.",
        "description": "The low-order byte in Index Register IY is loaded to memory address (nn); the upper order \nbyte is loaded to memory location (nn \u002B 1). The first n operand after the op code is the low-\norder byte of nn.\nM Cycles T States 4 MHz E.T.\n6 20 (4, 4, 3, 3, 3, 3) 5.00",
        "example": "If Index Register IY contains 4174h, then upon the execution of an LD (8838h), IY \ninstruction, memory location 8838h contains 74h and memory location 8839h contains \n41h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=125"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD SP, HL",
        "operation": "SP \u2190 HL",
        "opcode": "LD",
        "operands": "SP, HL\n11111 0 0 1 F9",
        "conditionBitsAffected": "None.",
        "description": "The contents of the register pair HL are loaded to the Stack Pointer (SP).\nM Cycles T States 4 MHz E.T.\n16 1.5",
        "example": "If the register pair HL contains 442Eh, then upon the execution of an LD SP, HL instruc-\ntion, the Stack Pointer also contains 442Eh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=126"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD SP, IX",
        "operation": "SP \u2190 IX",
        "opcode": "LD",
        "operands": "SP, IX\nDD\n11011 1 0 1\nF9\n11111 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The 2-byte contents of Index Register IX are loaded to the Stack Pointer (SP).\nM Cycles T States 4 MHz E.T.\n2 10 (4, 6) 2.50",
        "example": "If Index Register IX contains 98DAh, then upon the execution of an LD SP, IX instruction, \nthe Stack Pointer also contains 98DAh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=127"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "LD SP, IY",
        "operation": "SP \u2190 IY",
        "opcode": "LD",
        "operands": "SP, IY\nFD\n11111 1 0 1\nF9\n11111 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The 2-byte contents of Index Register IY are loaded to the Stack Pointer SP.\nM Cycles T States 4 MHz E.T.\n2 10 (4, 6) 2.50",
        "example": "If Index Register IY contains the integer A227h, then upon the execution of an LD SP, IY \ninstruction, the Stack Pointer also contains A227h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=128"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "PUSH qq",
        "operation": "(SP \u2013 2) \u2190 qqL, (SP \u2013 1) \u2190 qqH",
        "opcode": "PUSH",
        "operands": "qq\n11q0q 1 0 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of the register pair qq are pushed to the external memory last-in, first-out \n(LIFO) stack. The Stack Pointer (SP) Register pair holds the 16-bit address of the current \ntop of the Stack. This instruction first decrements SP and loads the high-order byte of reg-\nister pair qq to the memory address specified by the SP. The SP is decremented again and \nloads the low-order byte of qq to the memory location corresponding to this new address \nin the SP. The operand qq identifies register pair BC, DE, HL, or AF, assembled as follows \nin the object code:\nPair qq\nBC 00\nDE 01\nHL 10\nAF 11\nM Cycles T States 4 MHz E.T.\n3 11 (5, 3, 3) 2.75",
        "example": "If the AF Register pair contains 2233h and the Stack Pointer contains 1007h, then upon \nthe execution of a PUSH AF instruction, memory address 1006h contains 22h, memory \naddress 1005h contains 33h, and the Stack Pointer contains 1005h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=129"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "PUSH IX",
        "operation": "(SP \u2013 2) \u2190 IXL, (SP \u2013 1) \u2190 IXH",
        "opcode": "PUSH",
        "operands": "IX\nDD\n11011 1 0 1\nE5\n11100 1 0 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of Index Register IX are pushed to the external memory last-in, first-out \n(LIFO) stack. The Stack Pointer (SP) Register pair holds the 16-bit address of the current \ntop of the Stack. This instruction first decrements SP and loads the high-order byte of IX \nto the memory address specified by SP; then decrements SP again and loads the low-order \nbyte to the memory location corresponding to this new address in SP.\nM Cycles T States 4 MHz E.T.\n4 15 (4, 5, 3, 3) 3.75",
        "example": "If Index Register IX contains 2233h and the Stack Pointer contains 1007h, then upon the \nexecution of a PUSH IX instruction, memory address 1006h contains 22h, memory \naddress 1005h contains 33h, and the Stack Pointer contains 1005h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=131"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "PUSH IY",
        "operation": "(SP \u2013 2) \u2190 IYL, (SP \u2013 1) \u2190 IYH",
        "opcode": "PUSH",
        "operands": "IY\nFD\n11111 1 0 1\nE5\n11100 1 0 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of Index Register IY are pushed to the external memory last-in, first-out \n(LIFO) stack. The Stack Pointer (SP) Register pair holds the 16-bit address of the current \ntop of the Stack. This instruction first decrements the SP and loads the high-order byte of \nIY to the memory address specified by SP; then decrements SP again and loads the low-\norder byte to the memory location corresponding to this new address in SP.\nM Cycles T States 4 MHz E.T.\n4 15 (4, 5, 3, 3) 3.75",
        "example": "If Index Register IY contains 2233h and the Stack Pointer contains 1007h, then upon the \nexecution of a PUSH IY instruction, memory address 1006h contains 22h, memory \naddress 1005h contains 33h, and the Stack Pointer contains 1005h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=132"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "POP qq",
        "operation": "qqH \u2190 (SP\u002B1), qqL \u2190 (SP)",
        "opcode": "POP",
        "operands": "qq\n11q0q 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The top two bytes of the external memory last-in, first-out (LIFO) stack are popped to reg-\nister pair qq. The Stack Pointer (SP) Register pair holds the 16-bit address of the current \ntop of the Stack. This instruction first loads to the low-order portion of qq, the byte at the \nmemory location corresponding to the contents of SP; then SP is incremented and the con-\ntents of the corresponding adjacent memory location are loaded to the high-order portion \nof qq and the SP is now incremented again. The operand qq identifies register pair BC, \nDE, HL, or AF, assembled as follows in the object code:\nPair r\nBC 00\nDE 01\nHL 10\nAF 11\nM Cycles T States 4 MHz E.T.\n3 10 (4, 3, 3) 2.50",
        "example": "If the Stack Pointer contains 1000h, memory location 1000h contains 55h, and location \n1001h contains 33h, the instruction POP HL results in register pair HL containing 3355h, \nand the Stack Pointer containing 1002h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=133"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "POP IX",
        "operation": "IXH \u2190 (SP\u002B1), IXL \u2190 (SP)",
        "opcode": "POP",
        "operands": "IX\nDD\n11011 1 0 1\nE1\n11100 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The top two bytes of the external memory last-in, first-out (LIFO) stack are popped to \nIndex Register IX. The Stack Pointer (SP) Register pair holds the 16-bit address of the \ncurrent top of the Stack. This instruction first loads to the low-order portion of IX the byte \nat the memory location corresponding to the contents of SP; then SP is incremented and \nthe contents of the corresponding adjacent memory location are loaded to the high-order \nportion of IX. The SP is incremented again.\nM Cycles T States 4 MHz E.T.\n4 14 (4, 4, 3, 3) 3.50",
        "example": "If the Stack Pointer contains 1000h, memory location 1000h contains 55h, and location \n1001h contains 33h, the instruction POP IX results in Index Register IX containing \n3355h, and the Stack Pointer containing 1002h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=135"
    },
    {
        "groupName": "16-Bit Load Group",
        "keyword": "POP IY",
        "operation": "IYH \u2190 (SP \u2013 X1), IYL \u2190 (SP)",
        "opcode": "POP",
        "operands": "IY\nFD\n11111 1 0 1\nE1\n11100 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The top two bytes of the external memory last-in, first-out (LIFO) stack are popped to \nIndex Register IY. The Stack Pointer (SP) Register pair holds the 16-bit address of the cur-\nrent top of the Stack. This instruction first loads to the low-order portion of IY the byte at \nthe memory location corresponding to the contents of SP; then SP is incremented and the \ncontents of the corresponding adjacent memory location are loaded to the high-order por-\ntion of IY. The SP is incremented again.\nM Cycles T States 4 MHz E.T.\n4 14 (4, 4, 3, 3) 3.50",
        "example": "If the Stack Pointer Contains 1000h, memory location 1000h contains 55h, and location \n1001h contains 33h, the instruction POP IY results in Index Register IY containing \n3355h, and the Stack Pointer containing 1002h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=136"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "EX DE, HL",
        "operation": "DE \u2194 HL",
        "opcode": "EX",
        "operands": "DE, HL\n11110 0 1 1 EB",
        "conditionBitsAffected": "None.",
        "description": "The 2-byte contents of register pairs DE and HL are exchanged.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If register pair DE contains 2822h and register pair HL contains 499Ah, then upon the \nexecution of an EX DE, HL instruction, register pair DE contains 499Ah and register pair \nHL contains 2822h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=138"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "EX AF, AF\u0027",
        "operation": "AF \u2194 AF\u0027",
        "opcode": "EX",
        "operands": "AF, AF\u0027\n00010 0 0 0 08",
        "conditionBitsAffected": "None.",
        "description": "The 2-byte contents of the register pairs AF and AF\u0027 are exchanged. Register pair AF con-\nsists of registers A\u0027 and F\u0027.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If register pair AF contains 9900h and register pair AF\u0027 contains 5944h, the contents of \nAF are 5944h and the contents of AF\u0027 are 9900h upon execution of the EX AF, AF\u0027 \ninstruction.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=139"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "EXX",
        "operation": "(BC) \u2194 (BC\u0027), (DE) \u2194 (DE\u0027), (HL) \u2194 (HL\u0027)",
        "opcode": "EXX",
        "operands": "None.\n11011 0 0 1 D9",
        "conditionBitsAffected": "None.",
        "description": "Each 2-byte value in register pairs BC, DE, and HL is exchanged with the 2-byte value in \nBC\u0027, DE\u0027, and HL\u0027, respectively.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If register pairs BC, DE, and HL contain 445Ah, 3DA2h, and 8859h, respectively, and \nregister pairs BC\u2019, DE\u2019, and HL\u2019 contain 0988h, 9300h, and 00E7h, respectively, then \nupon the execution of an EXX instruction, BC contains 0988h; DE contains 9300h; HL \ncontains 00E7h; BC\u2019 contains 445Ah; DE\u2019 contains 3DA2h; and HL\u2019 contains 8859h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=140"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "EX (SP), HL",
        "operation": "H \u2194 (SP\u002B1), L \u2194 (SP)",
        "opcode": "EX",
        "operands": "(SP), HL\nE3\n11100 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The low-order byte contained in register pair HL is exchanged with the contents of the \nmemory address specified by the contents of register pair SP (Stack Pointer), and the high-\norder byte of HL is exchanged with the next highest memory address (SP\u002B1).\nM Cycles T States 4 MHz E.T.\n5 19 (4, 3, 4, 3, 5) 4.75",
        "example": "If the HL register pair contains 7012h, the SP register pair contains 8856h, the memory \nlocation 8856h contains byte 11h, and memory location 8857h contains byte 22h, then \nthe instruction EX (SP), HL results in the HL register pair containing number 2211h, \nmemory location 8856h containing byte 12h, memory location 8857h containing byte \n70h and Stack Pointer containing 8856h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=141"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "EX (SP), IX",
        "operation": "IXH \u2194 (SP\u002B1), IXL \u2194 (SP)",
        "opcode": "EX",
        "operands": "(SP), IX\nDD\n11011 1 0 1\nE3\n11100 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The low-order byte in Index Register IX is exchanged with the contents of the memory \naddress specified by the contents of register pair SP (Stack Pointer), and the high-order \nbyte of IX is exchanged with the next highest memory address (SP\u002B1).\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 4, 3, 5) 5.75",
        "example": "If Index Register IX contains 3988h, the SP register pair Contains 0100h, memory loca-\ntion 0100h contains byte 90h, and memory location 0101h contains byte 48h, then the \ninstruction EX (SP), IX results in the IX register pair containing number 4890h, memory \nlocation 0100h containing 88h, memory location 0101h containing 39h, and the Stack \nPointer containing 0100h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=142"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "EX (SP), IY",
        "operation": "IYH \u2194 (SP\u002B1), IYL \u2194 (SP)",
        "opcode": "EX",
        "operands": "(SP), IY\nFD\n11111 1 0 1\nE3\n11100 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The low-order byte in Index Register IY is exchanged with the contents of the memory \naddress specified by the contents of register pair SP (Stack Pointer), and the high-order \nbyte of IY is exchanged with the next highest memory address (SP\u002B1).\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 4, 3, 5) 5.75",
        "example": "If Index Register IY contains 3988h, the SP register pair contains 0100h, memory loca-\ntion 0100h contains byte 90h, and memory location 0101h contains byte 48h, then the \ninstruction EX (SP), IY results in the IY register pair containing number 4890h, memory \nlocation 0100h containing 88h, memory location 0101h containing 39h, and the Stack \nPointer containing 0100h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=143"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "LDI",
        "operation": "(DE) \u2190 (HL), DE \u2190 DE \u002B 1, HL \u2190 HL \u002B 1, BC \u2190 BC \u2013 1",
        "opcode": "LDI",
        "operands": "None\nED\n11110 1 0 1\nA0\n10100 0 0 0",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is set if BC \u2013 1 \u2260 0; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "A byte of data is transferred from the memory location addressed, by the contents of the \nHL register pair to the memory location addressed by the contents of the DE register pair. \nThen both these register pairs are incremented and the Byte Counter (BC) Register pair is \ndecremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "If the HL register pair contains 1111h, memory location 1111h contains byte 88h, the DE \nregister pair contains 2222h, the memory location 2222h contains byte 66h, and the BC \n\r\nregister pair contains 7h, then the instruction LDI results in the following contents in reg-\nister pairs and memory addresses:\nHL contains 1112h\n(1111h) contains 88h\nDE contains 2223h\n(2222h) contains  88h\nBC contains  6H",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=144"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "LDIR",
        "operation": "repeat {(DE) \u2190 (HL), DE \u2190 DE \u002B 1, HL \u2190 HL \u002B 1, BC \u2190 BC \u2013 1} while (BC \u2260 0)",
        "opcode": "LDIR",
        "operands": "None\nED\n11110 1 0 1\nB0\n10101 0 0 0",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\n\r\nP/V is set if BC \u2013 1 \u2260 0; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "This 2-byte instruction transfers a byte of data from the memory location addressed by the \ncontents of the HL register pair to the memory location addressed by the DE register pair. \nBoth these register pairs are incremented and the Byte Counter (BC) Register pair is dec-\nremented. If decrementing allows the BC to go to 0, the instruction is terminated. If BC is \nnot 0, the program counter is decremented by two and the instruction is repeated. Inter-\nrupts are recognized and two refresh cycles are executed after each data transfer. When the \nBC is set to 0 prior to instruction execution, the instruction loops through 64 KB.\nFor BC \u2260 0:\nM Cycles T States 4 MHz E.T.\n5 21 (4, 4, 3, 5, 5) 5.25\nFor BC = 0:\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "The HL register pair contains 11111h, the DE register pair contains 2222h, the BC regis-\nter pair contains 0003h, and memory locations contain the following data.\n(1111h) contains 88h (2222h) contains 66h\n(1112h) contains 36h (2223h) contains 59h\n(1113h) contains A5h (2224h) contains C5h\nUpon the execution of an LDIR instruction, the contents of register pairs and memory \nlocations now contain:\nHL contains 1114h\nDE contains 2225h\nBC contains 0000h\n(1111h) contains 88h (2222h) contains  88h\n(1112h) contains 36h (2223h) contains  36h\n(1113h) contains A5h (2224h) contains  A5h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=146"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "LDD",
        "operation": "(DE) \u2190 (HL), DE \u2190 DE \u2013 1, HL \u2190 HL\u2013 1, BC \u2190 BC\u2013 1",
        "opcode": "LDD",
        "operands": "None.\nED\n11110 1 0 1\nA8\n10110 0 0 0",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is set if BC \u2013 1 \u2260 0; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "This 2-byte instruction transfers a byte of data from the memory location addressed by the \ncontents of the HL register pair to the memory location addressed by the contents of the \nDE register pair. Then both of these register pairs including the Byte Counter (BC) Regis-\nter pair are decremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "If the HL register pair contains 1111h, memory location 1111h contains byte 88h, the DE \nregister pair contains 2222h, memory location 2222h contains byte 66h, and the BC reg-\n\r\nister pair contains 7h, then instruction LDD results in the following contents in register \npairs and memory addresses:\nHL contains 1110h\n(1111h) contains 88h\nDE contains 2221h\n(2222h) contains 88h\nBC contains 6h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=148"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "LDDR",
        "operation": "(DE) \u2190 (HL), DE \u2190 DE \u2013 1, HL \u2190 HL \u2013 1, BC \u2190 BC \u2013 1",
        "opcode": "LDDR",
        "operands": "None.\nED\n11110 1 0 1\nB8\n10111 0 0 0",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is reset.\nN is reset.",
        "description": "This 2-byte instruction transfers a byte of data from the memory location addressed by the \ncontents of the HL register pair to the memory location addressed by the contents of the \nDE register pair. Then both of these registers, and the BC (Byte Counter), are decre-\nmented. If decrementing causes BC to go to 0, the instruction is terminated. If BC is not 0, \nthe program counter is decremented by two and the instruction is repeated. Interrupts are \nrecognized and two refresh cycles execute after each data transfer. \nWhen the BC is set to 0, prior to instruction execution, the instruction loops through \n64 KB.\nFor BC \u2260 0:\nM Cycles T States 4 MHz E.T.\n5 21 (4, 4, 3, 5, 5) 5.25\nFor BC = 0:\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "The HL register pair contains 1114h, the DE register pair contains 2225h, the BC register \npair contains 0003h, and memory locations contain the following data.\n(1114h) contains A5h (2225h) contains  C5h\n(1113h) contains 36h (2224h) contains  59h\n(1112h) contains 88h (2223h) contains  66h\nUpon the execution of an LDDR instruction, the contents of the register pairs and memory \nlocations now contain:\nHL contains 1111h\nDE contains 2222h\nDC contains 0000h\n(1114h) contains A5h (2225h) contains  A5h\n(1113h) contains 36h (2224h) contains  36h\n(1112h) contains 88h (2223h) contains  88h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=150"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "CPI",
        "operation": "A \u2013 (HL), HL \u2190 HL \u002B1, BC \u2190 BC \u2013 1",
        "opcode": "CPI",
        "operands": "None.\nED\n11110 1 0 1\nA1\n10100 0 0 1",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if A is (HL); otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is set if BC \u2013 1 is not 0; otherwise, it is reset.\nN is set.\nC is not affected.",
        "description": "The contents of the memory location addressed by the HL register is compared with the \ncontents of the Accumulator. With a true compare, a condition bit is set. Then HL is incre-\nmented and the Byte Counter (register pair BC) is decremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "If the HL register pair contains 1111h, memory location 1111h contains 3Bh, the Accu-\nmulator contains 3Bh, and the Byte Counter contains 0001h. Upon the execution of a CPI \ninstruction, the Byte Counter contains 0000h, the HL register pair contains 1112h, the Z \nflag in the F register is set, and the P/V flag in the F Register is reset. There is no effect on \nthe contents of the Accumulator or to address 1111h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=152"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "CPIR",
        "operation": "A \u2013 (HL), HL \u2190 HL\u002B1, BC \u2190 BC \u2013 1",
        "opcode": "CPIR",
        "operands": "None.\nED\n11110 1 0 1\nB1\n10101 0 0 1",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if A equals (HL); otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is set if BC \u2013 1 does not equal 0; otherwise, it is reset.\nN is set.\nC is not affected.",
        "description": "The contents of the memory location addressed by the HL register pair is compared with \nthe contents of the Accumulator. During a compare operation, a condition bit is set. HL is \nincremented and the Byte Counter (register pair BC) is decremented. If decrementing \ncauses BC to go to 0 or if A = (HL), the instruction is terminated. If BC is not 0 and A \u2260 \n(HL), the program counter is decremented by two and the instruction is repeated. Inter-\nrupts are recognized and two refresh cycles are executed after each data transfer.\nIf BC is set to 0 before instruction execution, the instruction loops through 64 KB if no \nmatch is found.\nFor BC \u2260 0 and A \u2260 (HL):\nM Cycles T States 4 MHz E.T.\n5 21 (4, 4, 3, 5, 5) 5.25\nFor BC = 0 and A = (HL):\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "If the HL register pair contains 1111h, the Accumulator contains F3h, the Byte Counter \ncontains 0007h, and memory locations contain the following data.\n(1111h) contains 52h\n(1112h) contains 00h\n(1113h) contains F3h\nUpon the execution of a CPIR instruction, register pair HL contains 1114h, the Byte \nCounter contains 0004h, the P/V flag in the F Register is set, and the Z flag in the F Reg-\nister is set.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=153"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "CPD",
        "operation": "A \u2013 (HL), HL \u2190 HL \u2013 1, BC \u2190 BC \u2013 1",
        "opcode": "CPD",
        "operands": "None.\nED\n11110 1 0 1\nA9\n10110 0 0 1",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if A equals (HL); otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is set if BC \u2013 1\u2260 0; otherwise, it is reset.\nN is set.\nC is not affected.",
        "description": "The contents of the memory location addressed by the HL register pair is compared with \nthe contents of the Accumulator. During a compare operation, a condition bit is set. The \nHL and Byte Counter (register pair BC) are decremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "If the HL register pair contains 1111h, memory location 1111h contains 3Bh, the Accu-\nmulator contains 3Bh, and the Byte Counter contains 0001h. Upon the execution of a \nCPD instruction, the Byte Counter contains 0000h, the HL register pair contains 1110h, \nthe flag in the F Register is set, and the P/V flag in the F Register is reset. There is no \neffect on the contents of the Accumulator or address 1111h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=155"
    },
    {
        "groupName": "Exchange, Block Transfer, and Search Group",
        "keyword": "CPDR",
        "operation": "A \u2013 (HL), HL \u2190 HL \u2013 1, BC \u2190 BC \u2013 1",
        "opcode": "CPDR",
        "operands": "None.\nED\n11110 1 0 1\nB9\n10111 0 0 1",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if A = (HL); otherwise, it is reset.\nH is set if borrow form bit 4; otherwise, it is reset.\n\r\nP/V is set if BC \u2013 1 \u2260 0; otherwise, it is reset.\nN is set.\nC is not affected.",
        "description": "The contents of the memory location addressed by the HL register pair is compared with \nthe contents of the Accumulator. During a compare operation, a condition bit is set. The \nHL and Byte Counter (BC) Register pairs are decremented. If decrementing allows the BC \nto go to 0 or if A = (HL), the instruction is terminated. If BC is not 0 and A = (HL), the \nprogram counter is decremented by two and the instruction is repeated. Interrupts are rec-\nognized and two refresh cycles execute after each data transfer. When the BC is set to 0, \nprior to instruction execution, the instruction loops through 64 KB if no match is found.\nFor BC \u2260 0 and A \u2260 (HL):\nM Cycles T States 4 MHz E.T.\n5 21 (4, 4, 3, 5, 5) 5.25\nFor BC = 0 and A = (HL):\nM Cycles T States 4 MHz E.T.\n4 16 (4, 4, 3, 5) 4.00",
        "example": "The HL register pair contains 1118h, the Accumulator contains F3h, the Byte Counter \ncontains 0007h, and memory locations contain the following data.\n(1118h) contains 52h\n(1117h) contains 00h\n(1116h) contains F3h\nUpon the execution of a CPDR instruction, register pair HL contains 1115h, the Byte \nCounter contains 0004h, the P/V flag in the F Register is set, and the Z flag in the F Reg-\nister is set.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=156"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "ADD A, r",
        "operation": "A \u2190 A \u002B r",
        "opcode": "ADD",
        "operands": "A, r\n10000 r",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\n\r\nP/V is set if overflow; otherwise, it is reset.\nN is reset.\nC is set if carry from bit 7; otherwise, it is reset.",
        "description": "The contents of register r are added to the contents of the Accumulator, and the result is \nstored in the Accumulator. The r symbol identifies the registers A, B, C, D, E, H, or L, \nassembled as follows in the object code:\nRegister r\nA111\nB000\nC001\nD010\nE011\nH100\nL101\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If the Accumulator contains 44h and Register C contains 11h, then upon the execution of \nan ADD A, C instruction, the Accumulator contains 55h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=159"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "ADD A, n",
        "operation": "A \u2190 A \u002B n",
        "opcode": "ADD",
        "operands": "A, n\nC6\n11000 1 1 0\nn",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset. \nP/V is set if overflow; otherwise, it is reset. \nN is reset. \nC is set if carry from bit 7; otherwise, it is reset.",
        "description": "The n integer is added to the contents of the Accumulator, and the results are stored in the \nAccumulator.\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If the Accumulator contains 23h, then upon the execution of an ADD A, 33h instruction, \nthe Accumulator contains 56h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=161"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "ADD A, (HL)",
        "operation": "A \u2190 A \u002B (HL)",
        "opcode": "ADD",
        "operands": "A, (HL)\n86\n10000 1 1 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is reset.\nC is set if carry from bit 7; otherwise, it is reset.",
        "description": "The byte at the memory address specified by the contents of the HL register pair is added \nto the contents of the Accumulator, and the result is stored in the Accumulator.\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "If the Accumulator contains A0h, register pair HL contains 2323h, and memory location \n2323h contains byte 08h, then upon the execution of an ADD A, (HL) instruction, the \nAccumulator contains A8h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=162"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "ADD A, (IX \u002B d)",
        "operation": "A \u2190 A \u002B (IX\u002Bd)",
        "opcode": "ADD",
        "operands": "A, (IX \u002B d)\nDD\n11011 1 0 1\n10000 1 1 0 86\nd",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is reset.\nC is set if carry from bit 7; otherwise, it is reset.",
        "description": "The contents of the Index (register pair IX) Register is added to a two\u2019s complement dis-\nplacement d to point to an address in memory. The contents of this address is then added to \nthe contents of the Accumulator and the result is stored in the Accumulator.\nM Cycles T States 4 MHz E.T.\n5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contains 11h, Index Register IX contains 1000h, and memory location \n1005h contains 22h, then upon the execution of an ADD A, (IX \u002B 5h) instruction, the \nAccumulator contains 33h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=163"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "ADD A, (IY \u002B d)",
        "operation": "A \u2190 A \u002B (IY\u002Bd)",
        "opcode": "ADD",
        "operands": "A, (IY \u002B d)\nFD\n11111 1 0 1\n10000 1 1 0 86\nd",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3: otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is reset.\nC is set if carry from bit 7; otherwise, it is reset.",
        "description": "The contents of the Index (register pair IY) Register is added to a two\u2019s complement dis-\nplacement d to point to an address in memory. The contents of this address is then added to \nthe contents of the Accumulator, and the result is stored in the Accumulator.\nM Cycles T States 4 MHz E.T.\n5 19(4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contains 11h, Index Register IY contains 1000h, and memory location \n1005h contains 22h, then upon the execution of an ADD A, (IY \u002B 5h) instruction, the \nAccumulator contains 33h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=164"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "ADC A, s",
        "operation": "A \u2190 A \u002B s \u002B CY",
        "opcode": "ADC",
        "operands": "A, s\nThis s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd) as defined for the analogous ADD \ninstruction. These possible op code/operand combinations are assembled as follows in the \nobject code:\nADC A,r 10010 r*\nCE\n11010 1 1 0\nADC A,n\nn\nADC A, (HL) 8E\n10010 1 1 0\nDD\nADC A, (IX\u002Bd) 11011 1 1 0\n8E\n10010 1 1 0\nd\nFD\nADC A, (IY\u002Bd) 11111 1 0 1\n8E\n10010 1 1 0\nd\n\r\nr identifies registers B, C, D, E, H, L, or A, assembled as follows in the object code field:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is reset.\nC is set if carry from bit 7: otherwise, it is reset.",
        "description": "The s operand, along with the Carry Flag (C in the F Register) is added to the contents of \nthe Accumulator, and the result is stored in the Accumulator.\nInstruction M Cycle T States 4 MHz E.T.\nADC A, r 1 4 1.00\nADC A, n 2 7 (4, 3) 1.75\nADC A, (HL) 2 7 (4, 3) 1.75\nADC A, (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nADC A, (lY\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contents are 16h, the Carry Flag is set, the HL register pair contains \n6666h, and address 6666h contains 10h, then upon the execution of an ADC A, (HL) \ninstruction, the Accumulator contains 27h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=165"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "SUB s",
        "operation": "A \u2190 A \u2013 s",
        "opcode": "SUB",
        "operands": "s\nThis s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd) as defined for the analogous ADD \ninstruction. These possible op code/operand combinations are assembled as follows in the \nobject code:\nSUB r 10001 r*\nD6\n11001 1 1 0\nSUB n\nn\nSUB (HL) 96\n10001 1 1 0\nDD\nSUB (IX\u002Bd) 11011 1 0 1\n96\n10001 1 1 0\nd\nFD\nSUB (IY\u002Bd) 11111 1 0 1\n96\n10001 1 1 0\nd\n\r\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is set.\nC is set if borrow; otherwise, it is reset.",
        "description": "The s operand is subtracted from the contents of the Accumulator, and the result is stored \nin the Accumulator.\nInstruction M Cycle T States 4 MHz E.T.\nSUB r 1 4 1.00\nSUB n 2 7 (4, 3) 1.75\nSUB (HL) 2 7 (4, 3) 1.75\nSUB (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nSUB (lY\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contents are 29h, and the D Register contains 11h, then upon the exe-\ncution of a SUB D instruction, the Accumulator contains 18h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=167"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "SBC A, s",
        "operation": "A \u2190 A \u2013 s \u2013 CY",
        "opcode": "SBC",
        "operands": "A, s\nThe s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd) as defined for the analogous ADD \ninstructions. These possible op code/operand combinations are assembled as follows in \nthe object code.\nSBC A, r 10011 r*\nDE\n11011 1 1 0\nSBC A, n\nn\nSBC A, (HL) 9E\n10011 1 1 0\nDD\nSBC A, (IX\u002Bd) 11011 1 0 1\n9E\n10011 1 1 0\nd\nFD\nSBC A, (IY\u002Bd) 11111 1 0 1\n9E\n10011 1 1 0\nd\n\r\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB000\nC001\nD010\nE011\nH100\nL101\nA111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is reset if overflow; otherwise, it is reset.\nN is set.\nC is set if borrow; otherwise, it is reset.",
        "description": "The s operand, along with the Carry flag (C in the F Register) is subtracted from the con-\ntents of the Accumulator, and the result is stored in the Accumulator.\nInstruction M Cycles T States 4 MHz E.T.\nSBC A, r 1 4 1.00\nSBC A, n 2 7(4, 3) 1.75\nSBC A, (HL) 2 7 (4, 3) 1.75\nSBC A, (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nSBC A, (lY\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contains 16h, the carry flag is set, the HL register pair contains 3433h, \nand address 3433h contains 05h, then upon the execution of an SBC A, (HL) instruction, \nthe Accumulator contains 10h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=169"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "AND s",
        "operation": "A \u2190 A \u02C4 s",
        "opcode": "AND",
        "operands": "s\nThe s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous ADD \ninstructions. These possible op code/operand combinations are assembled as follows in \nthe object code:\nAND r* 10100 r*\nE6\n11100 1 1 0\nAND n\nnn\nAND (HL) A6\n10100 1 1 0\nDD\nAND (IX\u002Bd) 11011 1 0 1\nA6\n10100 1 1 0\nd\nFD\nAND (IY\u002Bd) 11111 1 0 1\nA6\n10100 1 1 0\nd\n\r\nr identifies registers B, C, D, E, H, L, or A specified in the assembled object code field, as \nfollows:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set.\nP/V is reset if overflow; otherwise, it is reset.\nN is reset.\nC is reset.",
        "description": "A logical AND operation is performed between the byte specified by the s operand and the \nbyte contained in the Accumulator; the result is stored in the Accumulator.\nInstruction M Cycles T States 4 MHz E.T.\nAND r 1 4 1.00\nAND n 2 7 (4, 3) 1.75\nAND (HL) 2 7 (4, 3) 1.75\nAND (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nAND (IX\u002Bd) 5 19 (4, 4, 3. 5, 3) 4.75",
        "example": "If Register B contains 7Bh (0111 1011) and the Accumulator contains C3h (1100 0011), \nthen upon the execution of an AND B instruction, the Accumulator contains 43h (0100 \n0011).",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=171"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "OR s",
        "operation": "A \u2190 A \u02C5 s",
        "opcode": "OR",
        "operands": "s\nThe s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous ADD \ninstructions. These possible op code/operand combinations are assembled as follows in \nthe object code:\nOR r* 10101 r*\nF6\n11101 1 1 0\nOR n\nn\nOR (HL) B6\n10101 1 1 0\nDD\nOR (IX\u002Bd) 11011 1 0 1\nB6\n10101 1 1 0\nd\nFD\nOR (IY\u002Bd) 11111 1 0 1\nB6\n10101 1 1 0\nd\n\r\nr identifies registers B, C\u2013, D, E, H, L, or A specified in the assembled object code field, \nas follows:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is reset.\nC is reset.",
        "description": "A logical OR operation is performed between the byte specified by the s operand and the \nbyte contained in the Accumulator; the result is stored in the Accumulator.\nInstruction M Cycles T States 4 MHz E.T.\nOR r 1 4 1.00\nOR n 2 7 (4, 3) 1.75\nOR (HL) 2 7 (4, 3) 1.75\nOR (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nOR (lY\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the H Register contains 48h (0100 0100), and the Accumulator contains 12h (0001 \n0010), then upon the execution of an OR H instruction, the Accumulator contains 5Ah \n(0101 1010).",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=173"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "XOR s",
        "operation": "A \u2190 A  \u2295 s",
        "opcode": "XOR",
        "operands": "s\nThe s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous ADD \ninstructions. These possible Op Code/operand combinations are assembled as follows in \nthe object code:\nXOR r* 10110 r*\nEE\n11110 1 1 0\nXOR n\nn\nXOR (HL) AE\n10110 1 1 0\nDD\nXOR (IX\u002Bd) 11011 1 0 1\nAE\n10110 1 1 0\nd\nFD\nXOR (IY\u002Bd) 11111 1 0 1\nAE\n10110 1 1 0\nd\n\r\nr identifies registers B, C, D, E, H, L, or A specified in the assembled object code field, as \nfollows:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 1l1",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\nC is reset.",
        "description": "The logical exclusive-OR operation is performed between the byte specified by the s oper-\nand and the byte contained in the Accumulator; the result is stored in the Accumulator.\nInstruction M Cycles T States 4 MHz E.T.\nXOR r 141.00\nXOR n 2 7 (4, 3) 1.75\nXOR (HL) 2 7 (4, 3) 1.75\nXOR (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nXOR (lY\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contains 96h (1001 0110), then upon the execution of an XOR 5Dh \n(5Dh = 0101 1101) instruction, the Accumulator contains CBh (1100 1011).",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=175"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "CP s",
        "operation": "A \u2013 s",
        "opcode": "CP",
        "operands": "s\nThe s operand is any of r, n, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous ADD \ninstructions. These possible op code/operand combinations are assembled as follows in \nthe object code:\nCP r* 10111 r*\nFE\n11111 1 1 0\nCP n\nn\nCP (HL) BE\n10111 1 1 0\nDD\nCP (IX\u002Bd) 11011 1 0 1\nBE\n10111 1 1 0\nd\nFD\nCP (IY\u002Bd) 11111 1 0 1\nBE\n10111 1 1 0\nd\n\r\nr identifies registers B, C, D, E, H, L, or A specified in the assembled object code field, as \nfollows:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\nN is set.\nC is set if borrow; otherwise, it is reset.",
        "description": "The contents of the s operand are compared with the contents of the Accumulator. If there \nis a true compare, the Z flag is set. The execution of this instruction does not affect the \ncontents of the Accumulator.\nInstruction M Cycles T States 4 MHz E.T.\nCP r 1 4 1.00\nCP n 2 7(4, 3) 1.75\nCP (HL) 2 7 (4, 3) 1.75\nCP (IX\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75\nCP (lY\u002Bd) 5 19 (4, 4, 3, 5, 3) 4.75",
        "example": "If the Accumulator contains 63h, the HL register pair contains 6000h, and memory loca-\ntion 6000h contains 60h, the instruction CP (HL) results in the PN flag in the F Register \nresetting.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=177"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "INC r",
        "operation": "r \u2190 r \u002B 1",
        "opcode": "INC",
        "operands": "r\n00 r 1 0 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\nP/V is set if r was 7Fh before operation; otherwise, it is reset.\n\r\nN is reset.\nC is not affected.",
        "description": "Register r is incremented and register r identifies any of the registers A, B, C, D, E, H, or \nL, assembled as follows in the object code.\nRegister r\nA 111\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If the D Register contains 28h, then upon the execution of an INC D instruction, the D \nRegister contains 29h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=179"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "INC (HL)",
        "operation": "(HL) \u2190 (HL) \u002B 1",
        "opcode": "INC",
        "operands": "(HL)\n34\n00101 1 0 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset. \nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset. \nP/V is set if (HL) was 7Fh before operation; otherwise, it is reset. \nN is reset. \nC is not affected.",
        "description": "The byte contained in the address specified by the contents of the HL register pair is incre-\nmented.\nM Cycles T States 4 MHz E.T.\n3 11 (4, 4, 3) 2.75",
        "example": "If the HL register pair contains 3434h and address 3434h contains 82h, then upon the \nexecution of an INC (HL) instruction, memory location 3434h contains 83h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=181"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "INC (IX\u002Bd)",
        "operation": "(IX\u002Bd) \u2190 (IX\u002Bd) \u002B 1",
        "opcode": "INC",
        "operands": "(IX\u002Bd)\nDD\n11011 1 0 1\n34\n00101 1 0 0\nd",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\nP/V is set if (IX\u002Bd) was 7Fh before operation; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "The contents of Index Register IX (register pair IX) are added to the two\u2019s-complement \ndisplacement integer, d, to point to an address in memory. The contents of this address are \nthen incremented.\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "If Index Register pair IX contains 2020h and memory location 2030h contains byte 34h, \nthen upon the execution of an INC (IX\u002B10h) instruction, memory location 2030h con-\ntains 35h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=182"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "INC (IY\u002Bd)",
        "operation": "(lY\u002Bd) \u2190 (lY\u002Bd) \u002B 1",
        "opcode": "INC",
        "operands": "(lY\u002Bd)\nFD\n11111 1 0 1\n34\n00101 1 0 0\nd",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 3; otherwise, it is reset.\nP/V is set if (lY\u002Bd) was 7Fh before operation; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "The contents of Index Register IY (register pair IY) are added to the two\u2019s-complement \ndisplacement integer, d, to point to an address in memory. The contents of this address are \nthen incremented.\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "If Index Register IY are 2020h and memory location 2030h contains byte 34h, then upon \nthe execution of an INC (IY\u002B10h) instruction, memory location 2030h contains 35h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=183"
    },
    {
        "groupName": "8-Bit Arithmetic Group",
        "keyword": "DEC m",
        "operation": "m \u2190 m \u2013 1",
        "opcode": "DEC",
        "operands": "m\nThe m operand is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous INC \ninstructions. These possible op code/operand combinations are assembled as follows in \nthe object code:\nDEC r*\n00 r 1 0 1\n35\nDEC (HL) 00101 1 0 1\nDD\nDEC (IX\u002Bd) 11011 1 0 1\n35\n00101 1 0 1\nd\nFD\nDEC (IY\u002Bd)\n11111 1 0 1\n35\n00101 1 0 1\nd\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if borrow from bit 4, otherwise, it is reset.\nP/V is set if m was 80h before operation; otherwise, it is reset.\nN is set.\nC is not affected.",
        "description": "The byte specified by the m operand is decremented.\nInstruction M Cycles T States 4 MHz E.T.\nDEC r 1 4 1.00\nDEC (HL) 3 11 (4, 4, 3) 2.75\nDEC (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nDEC (lY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "If the D Register contains byte 2Ah, then upon the execution of a DEC D instruction, the D \nRegister contains 29h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=184"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "DAA",
        "operation": "@",
        "opcode": "DAA\n27\n00100 1 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is set if most-significant bit of the Accumulator is 1 after an operation; otherwise, it is \nreset.\nZ is set if the Accumulator is 0 after an operation; otherwise, it is reset.\nH: see the DAA instruction table on the previous page.\nP/V is set if the Accumulator is at even parity after an operation; otherwise, it is reset.\nN is not affected.\nC: see the DAA instruction table on the previous page.",
        "description": "This instruction conditionally adjusts the Accumulator for BCD addition and subtraction \noperations. For addition (ADD, ADC, INC) or subtraction (SUB, SBC, DEC, NEG), the \nfollowing table indicates the operation being performed:\nHex Value Hex Value \nIn Upper In Lower Number\nC Before Digit H Before Digit Added To C After\nOperation DAA (Bits 7\u20134) DAA (Bits 3\u20130) Byte DAA\n09\u20130 00\u20139 00 0\n0 0\u20138 0 A\u2013F 06 0\n00\u20139 10\u20133 06 0\nADD 0 A\u2013F 0 0\u20139 60 1\nADC 0 9\u2013F 0 A\u2013F 66 1\nINC 0 A\u2013F 1 0\u20133 66 1\n10\u20132 00\u20139 60 1\n1 0\u20132 0 A\u2013F 66 1\n10\u20133 10\u20133 66 1\nSUB 0 0\u20139 0 0\u20139 00 0\nSBC 0 0\u20138 1 6\u2013F FA 0\nDEC 1 7\u2013F 0 0\u20139 A0 1\nNEG 1 6\u20137 1 6\u2013F 9A 1\n\r\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "An addition operation is performed between 15 (BCD) and 27 (BCD); simple decimal \narithmetic provides the following result:\n15\n\u002B 27\n42\nThe binary representations are added in the Accumulator according to standard binary \narithmetic, as follows:\n0001 0101\n\u002B 0010 0111\n0011 1100 = 3C\nThe sum is ambiguous. The DAA instruction adjusts this result so that the correct BCD \nrepresentation is obtained, as follows:\n0011 1100\n\u002B 0000 0110\n0100 0010 = 42",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=187"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "CPL",
        "operation": "A \u2190 A",
        "opcode": "CPL\n2F\n00110 1 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is not affected. \nZ is not affected.\nH is set.\nP/V is not affected. \nN is set. \nC is not affected.",
        "description": "The contents of the Accumulator (Register A) are inverted (one\u2019s complement).\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If the Accumulator contains 1011 0100, then upon the execution of a CPL instruction, the \nAccumulator contains 0100 1011.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=189"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "NEG",
        "operation": "A \u2190 0 \u2013 A",
        "opcode": "NEG\nED\n11110 1 0 1\n44\n01000 1 0 0",
        "operands": "None.",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if borrow from bit 4; otherwise, it is reset.\nP/V is set if Accumulator was 80h before operation; otherwise, it is reset.\nN is set.\nC is set if Accumulator was not 00h before operation; otherwise, it is reset.",
        "description": "The contents of the Accumulator are negated (two\u2019s complement). This method is the \nsame as subtracting the contents of the Accumulator from zero. \nNote: The 80h address remains unchanged.\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": "The Accumulator contains the following data:\n10011 0 0 0\nUpon the execution of a NEG instruction, the Accumulator contains:\n01110 0 0 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=190"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "CCF",
        "operation": "CY \u2190 CY",
        "opcode": "CCF\n3F\n00111 1 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH, previous carry is copied.\nP/V is not affected.\nN is reset.\nC is set if CY was 0 before operation; otherwise, it is reset.",
        "description": "The Carry flag in the F Register is inverted.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=192"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "SCF",
        "operation": "CY \u2190 1",
        "opcode": "SCF\n37\n00101 1 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is not affected.\nN is reset.\nC is set.",
        "description": "The Carry flag in the F Register is set.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=193"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "NOP",
        "operation": "\u2014",
        "opcode": "NOP\n00\n00000 0 0 0",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "The CPU performs no operation during this machine cycle.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=194"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "HALT",
        "operation": "\u2014",
        "opcode": "HALT\n76\n01101 1 1 0",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "The HALT instruction suspends CPU operation until a subsequent interrupt or reset is \nreceived. While in the HALT state, the processor executes NOPs to maintain memory \nrefresh logic.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=195"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "DI",
        "operation": "IFF \u2190 0",
        "opcode": "DI\nF3\n11101 0 1 1",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "DI disables the maskable interrupt by resetting the interrupt enable flip-flops (IFF1 and \nIFF2). \nNote: This instruction disables the maskable interrupt during its execution.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "When the CPU executes the instruction DI the maskable interrupt is disabled until it is \nsubsequently re-enabled by an EI instruction. The CPU does not respond to an Interrupt \nRequest (INT) signal.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=196"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "EI",
        "operation": "IFF \u2190 1",
        "opcode": "EI\nFB\n11111 0 1 1",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "The enable interrupt instruction sets both interrupt enable flip flops (IFFI and IFF2) to a \nlogic 1, allowing recognition of any maskable interrupt. \nNote: During the execution of this instruction and the following instruction, maskable interrupts \nare disabled.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "When the CPU executes an EI RETI instruction, the maskable interrupt is enabled then \nupon the execution of an the RETI instruction.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=197"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "IM 0",
        "operation": "Set Interrupt Mode 0",
        "opcode": "IM",
        "operands": "0\nED\n11110 1 0 1\n46\n01000 1 1 0",
        "conditionBitsAffected": "None.",
        "description": "The IM 0 instruction sets Interrupt Mode 0. In this mode, the interrupting device can insert \nany instruction on the data bus for execution by the CPU. The first byte of a multi-byte \ninstruction is read during the interrupt acknowledge cycle. Subsequent bytes are read in by \na normal memory read sequence.\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=198"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "IM 1",
        "operation": "Set Interrupt Mode 1",
        "opcode": "IM",
        "operands": "1\nED\n11110 1 0 1\n56\n01001 1 1 0",
        "conditionBitsAffected": "None.",
        "description": "The IM 1 instruction sets Interrupt Mode 1. In this mode, the processor responds to an \ninterrupt by executing a restart at address 0038h.\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=199"
    },
    {
        "groupName": "General-Purpose Arithmetic and CPU",
        "keyword": "IM 2",
        "operation": "Set Interrupt Mode 2",
        "opcode": "IM",
        "operands": "2\nED\n11110 1 0 1\n5E\n01011 1 1 0",
        "conditionBitsAffected": "None.",
        "description": "The IM 2 instruction sets the vectored Interrupt Mode 2. This mode allows an indirect call \nto any memory location by an 8-bit vector supplied from the peripheral device. This vector \nthen becomes the least-significant eight bits of the indirect pointer, while the I Register in \nthe CPU provides the most-significant eight bits. This address points to an address in a \nvector table that is the starting address for the interrupt service routine.\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=200"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "ADD HL, ss",
        "operation": "HL \u2190 HL \u002B ss",
        "opcode": "ADD\nOperands\nHL, ss\n00s1s 0 0 1\nDescription\nThe contents of register pair ss (any of register pairs BC, DE, HL, or SP) are added to the \ncontents of register pair HL and the result is stored in HL. In the assembled object code,",
        "operands": "HL, ss\n00s1s 0 0 1",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is set if carry from bit 11; otherwise, it is reset.\nP/V is not affected.\nN is reset.\n\r\nC is set if carry from bit 15; otherwise, it is reset.",
        "description": "The contents of register pair ss (any of register pairs BC, DE, HL, or SP) are added to the \ncontents of register pair HL and the result is stored in HL. In the assembled object code, \noperand ss is specified as follows:\nRegister\nPair ss\nBC 00\nDE 01\nHL 10\nSP 11\nM Cycles T States 4 MHz E.T.\n3 11 (4, 4, 3) 2.75",
        "example": "If register pair HL contains the integer 4242h and register pair DE contains 1111h, then \nupon the execution of an ADD HL, DE instruction, the HL register pair contains 5353h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=202"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "ADC HL, ss",
        "operation": "HL \u2190 HL \u002B ss \u002B CY",
        "opcode": "ADC",
        "operands": "HL, ss\nED\n11110 1 0 1\n01s1s 0 1 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if carry from bit 11; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\n\r\nN is reset.\nC is set if carry from bit 15; otherwise, it is reset.",
        "description": "The contents of register pair ss (any of register pairs BC, DE, HL, or SP) are added with \nthe Carry flag (C flag in the F Register) to the contents of register pair HL, and the result is \nstored in HL. In the assembled object code, operand ss is specified as follows:\nRegister \nPair ss\nBC\n00\nDE\n01\nHL\n10\nSP\n11\nM Cycles T States 4 MHz E.T.\n4 15 (4, 4, 4, 3) 3.75",
        "example": "If register pair BC contains 2222h, register pair HL contains 5437h, and the Carry Flag is \nset, then upon the execution of an ADC HL, BC instruction, HL contains 765Ah.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=204"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "SBC HL, ss",
        "operation": "HL \u2190 HL \u2013 ss \u2013 CY",
        "opcode": "SBC",
        "operands": "HL, ss\nED\n11110 1 0 1\n01s0s 0 1 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is set if borrow from bit 12; otherwise, it is reset.\nP/V is set if overflow; otherwise, it is reset.\n\r\nN is set.\nC is set if borrow; otherwise, it is reset.",
        "description": "The contents of the register pair ss (any of register pairs BC, DE, HL, or SP) and the Carry \nFlag (C flag in the F Register) are subtracted from the contents of register pair HL, and the \nresult is stored in HL. In the assembled object code, operand ss is specified as follows:\nRegister \nPair ss\nBC\n00\nDE\n01\nHL\n10\nSP\n11\nM Cycles T States 4 MHz E.T.\n4 15 (4, 4, 4, 3) 3.75",
        "example": "If the HL register pair contains 9999h, register pair DE contains 1111h, and the Carry \nflag is set, then upon the execution of an SBC HL, DE instruction, HL contains 8887h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=206"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "ADD IX, pp",
        "operation": "IX \u2190 IX \u002B pp",
        "opcode": "ADD",
        "operands": "IX, pp\nDD\n11011 1 0 1\n00p1p 0 0 1",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is set if carry from bit 11; otherwise, it is reset.\nP/V is not affected.\n\r\nN is reset.\nC is set if carry from bit 15; otherwise, it is reset.",
        "description": "The contents of register pair pp (any of register pairs BC, DE, IX, or SP) are added to the \ncontents of Index Register IX, and the results are stored in IX. In the assembled object \ncode, operand pp is specified as follows:\nRegister \nPair ss\nBC\n00\nDE\n01\nIX\n10\nSP\n11\nM Cycles T States 4 MHz E.T.\n4 15 (4, 4, 4, 3) 3.75",
        "example": "If Index Register IX contains 333h and register pair BC contains 5555h, then upon the \nexecution of an ADD IX, BC instruction, IX contains 8888h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=208"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "ADD IY, rr",
        "operation": "IY \u2190 IY \u002B rr",
        "opcode": "ADD",
        "operands": "IY, rr\nFD\n11111 1 0 1\n00r1r 0 0 1",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is set if carry from bit 11; otherwise, it is reset.\nP/V is not affected.\n\r\nN is reset.\nC is set if carry from bit 15; otherwise, it is reset.",
        "description": "The contents of register pair rr (any of register pairs BC, DE, IY, or SP) are added to the \ncontents of Index Register IY, and the result is stored in IY. In the assembled object code, \nthe rr operand is specified as follows:\nRegister \nPair ss\nBC\n00\nDE\n01\nIY\n10\nSP\n11\nM Cycles T States 4 MHz E.T.\n4 15 (4, 4, 4, 3) 3.75",
        "example": "If Index Register IY contains 333h and register pair BC contains 555h, then upon the exe-\ncution of an ADD IY, BC instruction, IY contains 8888h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=210"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "INC ss",
        "operation": "ss \u2190 ss \u002B 1",
        "opcode": "INC",
        "operands": "ss\n00s0s 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of register pair ss (any of register pairs BC, DE, HL, or SP) are incremented. \nIn the assembled object code, operand ss is specified as follows:\nRegister \nPair ss\nBC\n00\nDE\n01\nHL\n10\nSP\n11\nM Cycles T States 4 MHz E.T.\n16 1.50",
        "example": "If the register pair contains 1000h, then upon the execution of an INC HL instruction, HL \ncontains 1001h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=212"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "INC IX",
        "operation": "IX \u2190 IX \u002B 1",
        "opcode": "INC",
        "operands": "IX\nDD\n11011 1 0 1\n23\n00100 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of Index Register IX are incremented.\nM Cycles T States 4 MHz E.T.\n2 10 (4, 6) 2.50",
        "example": "If Index Register IX contains the integer 3300h, then upon the execution of an INC IX \ninstruction, Index Register IX contains 3301h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=213"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "INC IY",
        "operation": "IY \u2190 IY \u002B 1",
        "opcode": "INC",
        "operands": "IY\nFD\n11111 1 0 1\n23\n00100 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of Index Register IY are incremented.\nM Cycles T States 4 MHz E.T.\n2 10 (4, 6) 2.50",
        "example": "If the index register contains 2977h, then upon the execution of an INC IY instruction, \nIndex Register IY contains 2978h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=214"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "DEC ss",
        "operation": "ss \u2190 ss \u2013 1",
        "opcode": "DEC",
        "operands": "ss\n00s1s 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of register pair ss (any of the register pairs BC, DE, HL, or SP) are decre-\nmented. In the assembled object code, operand ss is specified as follows:\nRegister\nPair ss\nBC\n00\nDE\n01\nHL\n10\nSP\n11\nM Cycles T States 4 MHz E.T.\n16 1.50",
        "example": "If register pair HL contains 1001h, then upon the execution of an DEC HL instruction, HL \ncontains 1000h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=215"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "DEC IX",
        "operation": "IX \u2190 IX \u2013 1",
        "opcode": "DEC",
        "operands": "IX\nDD\n11011 1 0 1\n2B\n00110 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of Index Register IX are decremented.\nM Cycles T States 4 MHz E.T.\n2 10 (4, 6) 2.50",
        "example": "If Index Register IX contains 2006h, then upon the execution of a DEC IX instruction, \nIndex Register IX contains 2005h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=216"
    },
    {
        "groupName": "16-Bit Arithmetic Group",
        "keyword": "DEC IY",
        "operation": "IY \u2190 IY\u2013 1",
        "opcode": "DEC",
        "operands": "IY\nFD\n11111 1 0 1\n2B\n00110 0 1 1",
        "conditionBitsAffected": "None.",
        "description": "The contents of Index Register IY are decremented.\nM Cycles T States 4 MHz E.T.\n2 10 (4, 6) 2.50",
        "example": "If Index Register IY contains 7649h, then upon the execution of a DEC IY instruction, \nIndex Register IY contains 7648h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=217"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLCA",
        "operation": "70\nCY\nA",
        "opcode": "RLCA",
        "operands": "None.\n07\n00000 1 1 1",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is not affected.\nN is reset.\nC is data from bit 7 of Accumulator.",
        "description": "The contents of the Accumulator (Register A) are rotated left 1 bit position. The sign bit \n(bit 7) is copied to the Carry flag and also to bit 0. Bit 0 is the least-significant bit.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "The Accumulator contains the following data:\n76534 2 1 0\n10010 0 0 0\nUpon the execution of an RLCA instruction, the Accumulator and Carry flag contains:\nC 76534 2 1 0\n1\n00001 0 0 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=219"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLA",
        "operation": "",
        "opcode": "RLA",
        "operands": "None.\n17\n00001 1 1 1",
        "conditionBitsAffected": "Condition Bits Affected.\nS is not affected.\nZ is not affected.\nH is reset.\nP/V is not affected.\nN is reset.\nC is data from bit 7 of Accumulator.",
        "description": "The contents of the Accumulator (Register A) are rotated left 1 bit position through the \nCarry flag. The previous contents of the Carry flag are copied to bit 0. Bit 0 is the least-\nsignificant bit.\nM Cycles T States 4 MHz E.T.\n14 1.00\nCondition Bits Affected",
        "example": "The Accumulator and the Carry flag contains the following data:\nC 76534 2 1 0\n1\n01101 1 1 0\nUpon the execution of an RLA instruction, the Accumulator and the Carry flag contains:\nC 76534 2 1 0\n0\n11110 1 0 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=221"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RRCA",
        "operation": "7 0\nCY\nA",
        "opcode": "RRCA",
        "operands": "None.\n0F\n00010 1 1 1",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is not affected.\nN is reset.\nC is data from bit 0 of Accumulator.",
        "description": "The contents of the Accumulator (Register A) are rotated right 1 bit position. Bit 0 is cop-\nied to the Carry flag and also to bit 7. Bit 0 is the least-significant bit.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "The Accumulator contains the following data.\n\r\n6453 210\n7\n0 1\n00100 0\nUpon the execution of an RRCA instruction, the Accumulator and the Carry flag now con-\ntain:\nC\n7 6453 210\n1 1\n00101 0 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=223"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RRA",
        "operation": "7 0\nCY\nA",
        "opcode": "RRA",
        "operands": "None.\n1F\n00011 1 1 1",
        "conditionBitsAffected": "S is not affected.\nZ is not affected.\nH is reset.\nP/V is not affected.\nN is reset.\nC is data from bit 0 of Accumulator.",
        "description": "The contents of the Accumulator (Register A) are rotated right 1 bit position through the \nCarry flag. The previous contents of the Carry flag are copied to bit 7. Bit 0 is the least-\nsignificant bit.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "The Accumulator and the Carry Flag contain the following data:\n76534 2 1 0 C\n0\n111 0 00 0 1\nUpon the execution of an RRA instruction, the Accumulator and the Carry flag now con-\ntain:\n76534 2 1 0 C\n1\n011 1 00 0 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=225"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLC r",
        "operation": "CY 70\nr",
        "opcode": "RLC",
        "operands": "r\nCB\n11010 0 1 1\n00000\nr",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\nC is data from bit 7 of source register.",
        "description": "The contents of register r are rotated left 1 bit position. The contents of bit 7 are copied to \nthe Carry flag and also to bit 0. In the assembled object code, operand r is specified as fol-\nlows:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": "Register r contains the following data.\n76534 2 1 0\n100 0 10 0 0\nUpon the execution of an RLC r instruction, register r and the Carry flag now contain:\n76534 2 1 0\nC\n1\n00001 0 0 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=227"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLC (HL)",
        "operation": "70\nCY\n(HL)",
        "opcode": "RLC",
        "operands": "(HL)\nCB\n11010 0 1 1\n06\n00000 1 1 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\nC is data from bit 7 of source register.",
        "description": "The contents of the memory address specified by the contents of register pair HL are \nrotated left 1 bit position. The contents of bit 7 are copied to the Carry flag and also to bit \n0. Bit 0 is the least-significant bit.\nM Cycles T States 4 MHz E.T.\n4 15 (4, 4, 4, 3) 3.75",
        "example": "The HL register pair contains 2828h and the contents of memory location 2828h are:\n76534 2 1 0\n10010 0 0 0\nUpon the execution of an RLC(HL) instruction, memory location 2828h and the Carry \nflag now contain:\nC 76534 2 1 0\n1\n00001 0 0 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=229"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLC (IX\u002Bd)",
        "operation": "70\nCY\n(IX\u002Bd)",
        "opcode": "RLC",
        "operands": "(IX\u002Bd)\nDD\n11011 1 0 1\nCB\n11010 0 1 1\nd\n06\n00000 1 1 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\n\r\nC is data from bit 7 of source register.",
        "description": "The contents of the memory address specified by the sum of the contents of Index Register \nIX and the two\u2019s-complement displacement integer, d, are rotated left 1 bit position. The \ncontents of bit 7 are copied to the Carry flag and also to bit 0. Bit 0 is the least-significant \nbit.\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Index Register IX contains 1000h and memory location 1022h contains the following \ndata.\n76534 2 1 0\n10010 0 0 0\nUpon the execution of an RLC (IX\u002B2h) instruction, memory location 1002h and the \nCarry flag now contain:\nC 76534 2 1 0\n1\n00001 0 0 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=231"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLC (IY\u002Bd)",
        "operation": "70\nCY\n(IY\u002Bd)",
        "opcode": "RLC",
        "operands": "(lY\u002Bd)\nFD\n11111 1 0 1\nCB\n11010 0 1 1\nd\n06\n00000 1 1 0",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\n\r\nC is data from bit 7 of source register.",
        "description": "The contents of the memory address specified by the sum of the contents of Index Register \nIY and the two\u2019s-complement displacement integer, d, are rotated left 1 bit position. The \ncontents of bit 7 are copied to the Carry flag and also to bit 0. Bit 0 is the least-significant \nbit.\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Index Register IY contains 1000h and memory location 1002h contain the following \ndata:\n76534 2 1 0\n10010 0 0 0\nUpon the execution of an RLC (IY\u002B2h) instruction, memory location 1002h and the \nCarry flag now contain:\nC 76534 2 1 0\n1\n00001 0 0 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=233"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RL m",
        "operation": "70\nCY\nm",
        "opcode": "RL",
        "operands": "m\nThe m operand is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous RLC \ninstructions. In the assembled object code, the possible op code/operand combinations are \nspecified as follows:\nCB\n11010 0 1 1\nRL r*\n00001\nr*\nRL (HL) CB\n11010 0 1 1\n16\n00001 1 1 0\nDD\nRL (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\n16\n00001 1 1 0\nFD\nRL (IY\u002Bd)\n11111 1 0 1\nCB\n11010 0 1 1\nd\n16\n00001 1 1 0\n\r\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB\n000\nC\n001\nD\n010\nE\n011\nH\n100\nL\n101\nA\n111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\nC is data from bit 7 of source register.",
        "description": "The contents of the m operand are rotated left 1 bit position. The contents of bit 7 are cop-\nied to the Carry flag, and the previous contents of the Carry flag are copied to bit 0.\nInstruction M Cycles T States 4 MHz E.T.\nRL r 2 8 (4, 4) 2.00\nRL (HL) 4 15(4, 4, 4, 3) 3.75\nRL (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nRL (IY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "The D Register and the Carry flag contain the following data.\nC 76534 2 1 0\n0\n10010 1 1 1\n\r\nUpon the execution of an RL D instruction, the D Register and the Carry flag now contain:\nC 76534 2 1 0\n1\n00011 1 1 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=235"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RRC m",
        "operation": "",
        "opcode": "RRC",
        "operands": "m\nThe m operand is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous RLC \ninstructions. In the assembled object code, the possible op code/operand combinations are \nspecified as follows:\n\r\nCB\n11010 0 1 1\nRRC r*\n00010\nr*\nCB\nRRC (HL)\n11010 0 1 1\nOE\n00010 1 1 0\nDD\nRRC (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\nOE\n00010 1 1 0\nFD\nRRC (IY\u002Bd)\n11111 1 0 1\nCB\n11010 0 1 1\nd\nOE\n00010 1 1 0\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\nC is data from bit 0 of source register.",
        "description": "The contents of the m operand are rotated right 1 bit position. The contents of bit 0 are \ncopied to the Carry flag and also to bit 7. Bit 0 is the least-significant bit.\n\r\nInstruction M Cycles T States 4 MHz E.T.\nRRC r 2 8 (4, 4) 2.00\nRRC (HL) 4 15 (4, 4, 4, 3) 3.75\nRRC (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nRRC (lY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Register A contains the following data.\n76534 2 1 0\n00101 0 0 1\nUpon the execution of an RRC A instruction, Register A and the Carry flag now contain:\n76534 2 1 0\nC\n1\n100 1 10 0 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=238"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RR m",
        "operation": "",
        "opcode": "RR",
        "operands": "m\nThe m operand is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous RLC \ninstructions. In the assembled object code, the possible op code/operand combinations are \nspecified as follows:\n\r\nCB\n11010 0 1 1\nRR r*\n00010\nr*\nCB\nRR (HL)\n11010 0 1 1\n1E\n00011 1 1 0\nDD\nRR (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\n1E\n00011 1 1 0\nFD\nRR (IY\u002Bd)\n11111 1 0 1\nCB\n11010 0 1 1\nd\n1E\n00011 1 1 0\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity even; otherwise, it is reset.\nN is reset.\nC is data from bit 0 of source register.",
        "description": "The contents of operand m are rotated right 1 bit position through the Carry flag. The con-\ntents of bit 0 are copied to the Carry flag and the previous contents of the Carry flag are \ncopied to bit 7. Bit 0 is the least-significant bit.\n\r\nInstruction M Cycles T States 4 MHz E.T.\nRR r 2 8 (4, 4) 2.00\nRR (HL) 4 15 (4, 4, 4, 3) 3.75\nRR (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nRR (lY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "The HL register pair contains 4343h and memory location 4343h and the Carry flag con-\ntain the following data.\n76534 2 1 0 C\n0\n101 1 11 0 1\nUpon the execution of an RR (HL) instruction, location 4343h and the Carry flag now \ncontain:\n76534 2 1 0 C\n1\n011 0 11 1 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=241"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "SLA m",
        "operation": "70\nCY 0\nm",
        "opcode": "SLA",
        "operands": "m\nThe m operand is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous RLC \ninstructions. In the assembled object code, the possible op code/operand combinations are \nspecified as follows:\nCB\n11010 0 1 1\nSLA r*\n00100\nr*\nCB\nSLA (HL)\n11010 0 1 1\n26\n00100 1 1 0\nDD\nSLA (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\n26\n00100 1 1 0\nFD\nSLA (IY\u002Bd)\n11111 1 0 1\nCB\n11010 0 1 1\nd\n26\n00100 1 1 0\n\r\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB\n000\nC\n001\nD\n010\nE\n011\nH\n100\nL\n101\nA\n111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity is even; otherwise, it is reset.\nN is reset.\nC is data from bit 7.",
        "description": "An arithmetic shift left 1 bit position is performed on the contents of operand m. The con-\ntents of bit 7 are copied to the Carry flag. Bit 0 is the least-significant bit.\nInstruction M Cycles T States 4 MHz E.T.\nSLA r 2 8 (4, 4) 2.00\nSLA (HL) 4 15 (4, 4, 4, 3) 3.75\nSLA (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nSLA (IY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Register L contains the following data.\n76534 2 1 0\n10101 0 0 1\n\r\nUpon the execution of an SLA L instruction, Register L and the Carry flag now contain:\nC 76534 2 1 0\n1\n01100 0 1 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=244"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "SRA m",
        "operation": "7 0\nCY\nm",
        "opcode": "SRA",
        "operands": "m\nThe m operand is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous RLC \ninstructions. In the assembled object code, the possible op code/operand combinations are \nspecified as follows:\nCB\n11010 0 1 1\nSRA r*\n00110 r*\nSRA (HL) CB\n11010 0 1 1\n2E\n00110 1 1 0\nDD\nSRA (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\n2E\n00110 1 1 0\nFD\nSRA (IY\u002Bd)\n11111 1 0 1\nCB\n11010 0 1 1\nd\n2E\n00110 1 1 0\n\r\nr identifies registers B, C, D, E, H, L, or A assembled as follows in the object code field:\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111",
        "conditionBitsAffected": "S is set if result is negative; otherwise, it is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity is even; otherwise, it is reset.\nN is reset.\nC is data from bit 0 of source register.",
        "description": "An arithmetic shift right 1 bit position is performed on the contents of operand m. The \ncontents of bit 0 are copied to the Carry flag and the previous contents of bit 7 remain \nunchanged. Bit 0 is the least-significant bit.\nInstruction M Cycles T States 4 MHz E.T.\nSRA r 2 8 (4, 4) 2.00\nSRA (HL) 4 15 (4, 4, 4, 3) 3.75\nSRA (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nSRA (lY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Index Register IX contains 1000h and memory location 1003h contains the following \ndata.\n76534 2 1 0\n10111 0 0 0\n\r\nUpon the execution of an SRA (IX\u002B3h) instruction, memory location 1003h and the \nCarry flag now contain:\n76534 2 1 0 C\n0\n101 1 11 0 0",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=247"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "SRL m",
        "operation": "7 0 CY\n0\nm",
        "opcode": "SRL",
        "operands": "m\nThe operand m is any of r, (HL), (IX\u002Bd), or (lY\u002Bd), as defined for the analogous RLC \ninstructions. In the assembled object code, the possible op code/operand combinations are \nspecified as follows:\nCB\n11010 0 1 1\nSRL r*\n00111\nr*\nCB\nSRL (HL)\n11010 0 1 1\n3E\n00111 1 1 0\nDD\nSRL (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\n3E\n00111 1 1 0\nFD\nSRL (IY\u002Bd)\n11111 1 0 1\nCB\n11010 0 1 1\nd\n3E\n00111 1 1 0\n\r\nr identifies registers B, C, D, E, H, L, or A.",
        "conditionBitsAffected": "S is reset.\nZ is set if result is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity is even; otherwise, it is reset.\nN is reset.\nC is data from bit 0 of source register.",
        "description": "The contents of operand m are shifted right 1 bit position. The contents of bit 0 are copied \nto the Carry flag, and bit 7 is reset. Bit 0 is the least-significant bit.\nInstruction M Cycles T States 4 MHz E.T.\nSRL r 2 8 (4, 4) 2.00\nSRL (HL) 4 15 (4, 4, 4, 3) 3.75\nSRL (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nSRL (lY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Register B contains the following data.\n76534 2 1 0\n10010 1 1 1\nUpon the execution of an SRL B instruction, Register B and the Carry flag now contain:\n76534 2 1 0 C\n1\n001 0 01 1 1",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=250"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RLD",
        "operation": "A 7 4 3 0 7 4 3 0",
        "opcode": "RLD",
        "operands": "ED\n11110 1 0 1\n6F\n01110 1 1 1",
        "conditionBitsAffected": "S is set if the Accumulator is negative after an operation; otherwise, it is reset.\nZ is set if the Accumulator is 0 after an operation; otherwise, it is reset.\nH is reset.\n\r\nP/V is set if the parity of the Accumulator is even after an operation; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "The contents of the low-order four bits (bits 3, 2, 1, and 0) of the memory location (HL) \nare copied to the high-order four bits (7, 6, 5, and 4) of that same memory location; the \nprevious contents of those high-order four bits are copied to the low-order four bits of the \nAccumulator (Register A); and the previous contents of the low-order four bits of the \nAccumulator are copied to the low-order four bits of memory location (HL). The contents \nof the high-order bits of the Accumulator are unaffected.\nNote: (HL) refers to the memory location specified by the contents of the HL register pair.\nM Cycles T States 4 MHz E.T.\n5 18 (4, 4, 3, 4, 3) 4.50",
        "example": "The HL register pair contains 5000h and the Accumulator and memory location 5000h \ncontain the following data.\n76534 2 1 0\n01111 0 1 0 Accumulator\n76534 2 1 0\n00101 0 0 1 (5000h)\nUpon the execution of an RLD instruction, the Accumulator and memory location 5000h \nnow contain:\n76534 2 1 0\n01101 0 1 1 Accumulator\n76534 2 1 0\n00011 0 1 0 (5000h)",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=252"
    },
    {
        "groupName": "Rotate and Shift Group",
        "keyword": "RRD",
        "operation": "A 7 4 3 0 7 4 3 0\n(HL)",
        "opcode": "RRD",
        "operands": "ED\n11110 1 0 1\n67\n01100 1 1 1",
        "conditionBitsAffected": "S is set if the Accumulator is negative after an operation; otherwise, it is reset.\nZ is set if the Accumulator is 0 after an operation; otherwise, it is reset.\nH is reset.\n\r\nP/V is set if the parity of the Accumulator is even after an operation; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "The contents of the low-order four bits (bits 3, 2, 1, and 0) of memory location (HL) are \ncopied to the low-order four bits of the Accumulator (Register A). The previous contents \nof the low-order four bits of the Accumulator are copied to the high-order four bits (7, 6, 5, \nand 4) of location (HL); and the previous contents of the high-order four bits of (HL) are \ncopied to the low-order four bits of (HL). The contents of the high-order bits of the Accu-\nmulator are unaffected. \nNote: (HL) refers to the memory location specified by the contents of the HL register pair.\nM Cycles T States 4 MHz E.T.\n5 18 (4, 4, 3, 4, 3) 4.50",
        "example": "The HL register pair contains 5000h and the Accumulator and memory location 5000h \ncontain the following data.\n76534 2 1 0\n10000 1 0 0 Accumulator\n76534 2 1 0\n00100 0 0 0\n(5000h)\nUpon the execution of an RRD instruction, the Accumulator and memory location 5000h \nnow contain:\n76534 2 1 0\n10000 0 0 0 Accumulator\n76534 2 1 0\n01000 0 1 0\n(5000h)",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=254"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "BIT b, r",
        "operation": "Z \u2190 rb",
        "opcode": "BIT",
        "operands": "b, r\nCB\n11010 0 1 1\n01 b r",
        "conditionBitsAffected": "S is unknown.\nZ is set if specified bit is 0; otherwise, it is reset.\n\r\nH is set.\nP/V is unknown.\nN is reset.\nC is not affected.",
        "description": "This instruction tests bit b in register r and sets the Z flag accordingly. In the assembled \nobject code, operands b and r are specified as follows:\nBit Tested b Register r\n0 000 B 000\n1 001 C 001\n2 010 D 010\n3 011 E 011\n4 100 H 100\n5 101 L 101\n6 110 A 111\n7 111\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 4.50",
        "example": "If bit 2 in Register B contains 0, then upon the execution of a BIT 2, B instruction, the Z \nflag in the F Register contains 1, and bit 2 in Register B remains at 0. Bit 0 in Register B is \nthe least-significant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=257"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "BIT b, (HL)",
        "operation": "Z \u2190 (HL)b",
        "opcode": "BIT",
        "operands": "b, (HL)\nCB\n11010 0 1 1\n01 b 1 1 0",
        "conditionBitsAffected": "S is unknown.\n\r\nZ is set if specified bit is 0; otherwise, it is reset.\nH is set.\nP/V is unknown.\nH is reset.\nC is not affected.",
        "description": "This instruction tests bit b in the memory location specified by the contents of the HL reg-\nister pair and sets the Z flag accordingly. In the assembled object code, operand b is speci-\nfied as follows:\nBit Tested b\n0 000\n1 001\n2 010\n3 011\n4 100\n5 101\n6 110\n1 111\nM Cycles T States 4 MHz E.T.\n3 12 (4, 4, 4) 4 3.00",
        "example": "If the HL register pair contains 4444h, and bit 4 in the memory location 444h contains 1, \nthen upon the execution of a BIT 4, (HL) instruction, the Z flag in the F Register contains \n0, and bit 4 in memory location 4444h remains at 1. Bit 0 in memory location 4444h is \nthe least-significant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=259"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "BIT b, (IX\u002Bd)",
        "operation": "Z \u2190 (IX\u002Bd)b",
        "opcode": "BIT",
        "operands": "b, (IX\u002Bd)\nDD\n11011 1 0 1\n11010 0 1 1 CB\nd\n01 b 101",
        "conditionBitsAffected": "S is unknown.\nZ is set if specified bit is 0; otherwise, it is reset.\nH is set.\nP/V is unknown.\nN is reset.\nC is not affected.",
        "description": "This instruction tests bit b in the memory location specified by the contents of register pair \nIX combined with the two\u2019s complement displacement d and sets the Z flag accordingly. \nIn the assembled object code, operand b is specified as follows:\nBit Tested b\n0 000\n1 001\n2 010\n3 011\n4 100\n5 101\n6 110\n7 111\nM Cycles T States 4 MHz E.T.\n5 20 (4, 4, 3, 5, 4) 5.00",
        "example": "If Index Register IX contains 2000h and bit 6 in memory location 2004h contains 1, then \nupon the execution of a BIT 6, (IX\u002B4h) instruction, the Z flag in the F Register contains a \n0 and bit 6 in memory location 2004h still contains a 1. Bit 0 in memory location 2004h \nis the least-significant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=261"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "BIT b, (IY\u002Bd)",
        "operation": "Z \u2190 (IY\u002Bd)b",
        "opcode": "BIT",
        "operands": "b, (lY\u002Bd)\nFD\n11111 1 0 1\n11010 0 1 1 CB\nd\n01 b 101",
        "conditionBitsAffected": "S is unknown.\nZ is set if specified bit is 0; otherwise, it is reset.\nH is set.\nP/V is unknown.\nH is reset.\nC is not affected.",
        "description": "This instruction tests bit b in the memory location specified by the contents of register pair \nIY combined with the two\u2019s complement displacement d and sets the Z flag accordingly. \nIn the assembled object code, operand b is specified as follows.\nBit Tested b\n0 000\n1 001\n2 010\n3 011\n4 100\n5 101\n6 110\n7 111\nM Cycles T States 4 MHz E.T.\n5 20 (4, 4, 3, 5, 4) 5.00",
        "example": "If Index Register contains 2000h and bit 6 in memory location 2004h contains a 1, then \nupon the execution of a BIT 6, (IY\u002B4h) instruction, the Z flag and the F Register still con-\ntains a 0, and bit 6 in memory location 2004h still contains a 1. Bit 0 in memory location \n2004h is the least-significant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=263"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "SET b, r",
        "operation": "rb \u2190 1",
        "opcode": "SET",
        "operands": "b, r\nCB\n11010 0 1 1\n11 b r",
        "conditionBitsAffected": "None.",
        "description": "Bit b in register r (any of registers B, C, D, E, H, L, or A) is set. In the assembled object \ncode, operands b and r are specified as follows:\nBit b Register r\n0 000 B 000 \n1 001 C 001 \n2 010 D 010 \n3 011 E 011 \n4 100 H 100 \n5 101 L 101 \n6 110 A 111 \n7 111\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": "Upon the execution of a SET 4, A instruction, bit 4 in Register A is set. Bit 0 is the least-\nsignificant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=265"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "SET b, (HL)",
        "operation": "(HL)b \u2190 1",
        "opcode": "SET",
        "operands": "b, (HL)",
        "conditionBitsAffected": "None.",
        "description": "Bit b in the memory location addressed by the contents of register pair HL is set. In the \nassembled object code, operand b is specified as follows:\nBit Tested b\n0 000\n1 001\n2 010\n3 011\n4 100\n5 101\n6 110\n7 111\nM Cycles T States 4 MHz E.T.\n4 15 (4, 4, 4, 3) 3.75",
        "example": "If the HL register pair contains 3000h, then upon the execution of a SET 4, (HL) instruc-\ntion, bit 4 in memory location 3000h is 1. Bit 0 in memory location 3000h is the least-sig-\nnificant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=267"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "SET b, (IX\u002Bd)",
        "operation": "(IX\u002Bd)b \u2190 1",
        "opcode": "SET",
        "operands": "b, (IX\u002Bd)",
        "conditionBitsAffected": "None.",
        "description": "Bit b in the memory location addressed by the sum of the contents of the IX register pair \nand the two\u2019s complement integer d is set. In the assembled object code, operand b is spec-\nified as follows:\nBit Tested b\n0 000\n1 001\n2 010\n3 011\n4 100\n5 101\n6 110\n7 111\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "If the index register contains 2000h, then upon the execution of a SET 0, (IX \u002B 3h) \ninstruction, bit 0 in memory location 2003h is 1. Bit 0 in memory location 2003h is the \nleast-significant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=269"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "SET b, (IY\u002Bd)",
        "operation": "(IY \u002B d) b \u2190 1",
        "opcode": "SET",
        "operands": "b, (IY \u002B d)\nFD\n11111 1 0 1\n11010 0 1 1 CB\nd\n11 b 101",
        "conditionBitsAffected": "None.",
        "description": "Bit b in the memory location addressed by the sum of the contents of the IY register pair \nand the two\u2019s complement displacement d is set. In the assembled object code, operand b \nis specified as follows:\nBit Tested b\n0 000\n1 001\n2 010\n3 011\n4 100\n5 101\n6 110\n7 111\nM Cycles T States 4 MHz E.T.\n6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "If Index Register IY contains 2000h, then upon the execution of a Set 0, (IY\u002B3h) instruc-\ntion, bit 0 in memory location 2003h is 1. Bit 0 in memory location 2003h is the least-sig-\nnificant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=271"
    },
    {
        "groupName": "Bit Set, Reset, and Test Group",
        "keyword": "RES b, m",
        "operation": "sb \u2190 0",
        "opcode": "RES",
        "operands": "b, m\nThe b operand represents any bit (7 through 0) of the contents of the m operand, (any of r, \n(HL), (IX\u002Bd), or (lY\u002Bd)) as defined for the analogous SET instructions. These possible op \ncode/operand combinations are assembled as follows in the object code:\nCB\n11010 0 1 1\nRES b, rn\nr\n10 b\nRES b, (HL) CB\n11010 0 1 1\n10 b 101\nDD\nRES b, (IX\u002Bd) 11011 1 0 1\nCB\n11010 0 1 1\nd\n10 b 101\nFD\nRES b, (IY\u002Bd) 11111 1 0 1\nCB\n11010 0 1 1\nd\n10 b 101\n\r\nBit b Register r\n0 000 B 000\n1 001 C 001\n2 010 D 010\n3 011 E 011\n4 100 H 100\n5 101 L 101\n6 110 A 111\n7 111",
        "conditionBitsAffected": "None.",
        "description": "Bit b in operand m is reset.\nInstruction M Cycles T States 4 MHz E.T.\nRES r 4 8 (4, 4) 2.00\nRES (HL) 4 15 (4, 4, 4, 3) 3.75\nRES (IX\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75\nRES (lY\u002Bd) 6 23 (4, 4, 3, 5, 4, 3) 5.75",
        "example": "Upon the execution of a RES 6, D instruction, bit 6 in register 0 is reset. Bit 0 in the D \nRegister is the least-significant bit.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=273"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JP nn",
        "operation": "PC \u2190 nn",
        "opcode": "JP\nOperand\nnn\nC3\n11000 0 1 1\nn\nn\nNote: The first operand in this assembled object code is the low-order byte of a two-byte address.\nDescription",
        "operands": "nn\nC3\n11000 0 1 1\nn\nn\nNote: The first operand in this assembled object code is the low-order byte of a two-byte address.",
        "conditionBitsAffected": "None.",
        "description": "Operand nn is loaded to register pair Program Counter (PC). The next instruction is \nfetched from the location designated by the new contents of the PC.\nM Cycles T States 4 MHz E.T.\n3 10 (4, 3, 3) 2.50",
        "example": null,
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=276"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JP cc, nn",
        "operation": "IF cc true, PC \u2190 nn",
        "opcode": "JP",
        "operands": "cc, nn\nThe first n operand in this assembled object code is the low-order byte of a 2-byte memory \naddress.",
        "conditionBitsAffected": "None.",
        "description": "If condition cc is true, the instruction loads operand nn to register pair Program Counter \n(PC), and the program continues with the instruction beginning at address nn. If condition \ncc is false, the Program Counter is incremented as usual, and the program continues with \nthe next sequential instruction. Condition cc is programmed as one of eight statuses that \ncorrespond to condition bits in the Flag Register (Register F). These eight statuses are \ndefined in the following table, which specifies the corresponding cc bit fields in the \nassembled object code.\nRelevant\ncc Condition Flag\n000 Non-Zero (NZ) Z\n001 Zero (Z) Z\n010 No Carry (NC) C\n011 Carry (C) C\n100 Parity Odd (PO) P/V\n101 Parity Even (PE) P/V\n110 Sign Positive (P) S\n111 Sign Negative (M) S\n\r\nM Cycles T States 4 MHz E.T.\n3 10 (4, 3, 3) 2.50",
        "example": "If the Carry flag (i.e., the C flag in F Register) is set and address 1520h contains 03h, then \nupon the execution of a JP C, 1520h instruction, the Program Counter contains 1520h \nand, on the next machine cycle, the CPD fetches byte 03h from address 1520h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=277"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JR e",
        "operation": "PC \u2190 PC \u002B e",
        "opcode": "JR",
        "operands": "e\n18\n00011 0 0 0\ne\u20132",
        "conditionBitsAffected": "None.",
        "description": "This instruction provides for unconditional branching to other segments of a program. The \nvalue of displacement e is added to the Program Counter (PC) and the next instruction is \nfetched from the location designated by the new contents of the PC. This jump is mea-\nsured from the address of the instruction op code and contains a range of \u2013126 to \u002B129 \nbytes. The assembler automatically adjusts for the twice incremented PC.\nM Cycles T States 4 MHz E.T.\n3 12 (4, 3, 5) 3.00",
        "example": "To jump forward five locations from address 480, the following assembly language state-\nment is used: \nJR $\u002B5 \nThe resulting object code and final Program Counter value is shown in the following table:\n\r\nLocation Instruction\n480 18\n481 03\n482 \u2013\n483 \u2013\n484 \u2013\n485 \u2190 PC after jump",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=279"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JR C, e",
        "operation": "If C = 0, continue \nIf C = 1, PC \u2190 PC\u002B e",
        "opcode": "JR",
        "operands": "C, e\n00111 0 0 0 38\ne\u20132",
        "conditionBitsAffected": "None.",
        "description": "This instruction provides for conditional branching to other segments of a program \ndepending on the results of a test on the Carry Flag. If the flag = 1, the value of displace-\nment e is added to the Program Counter (PC) and the next instruction is fetched from the \nlocation designated by the new contents of the PC. The jump is measured from the address \nof the instruction op code and contains a range of \u2013126 to \u002B129 bytes. The assembler auto-\nmatically adjusts for the twice incremented PC.\nIf the flag = 0, the next instruction executed is taken from the location following this \ninstruction. If condition is met\nM Cycles T States 4 MHz E.T.\n3 12 (4, 3, 5) 3.00\nIf condition is not met:\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "The Carry flag is set and it is required to jump back four locations from 480. The assembly \nlanguage statement is JR C, $\u20134\nThe resulting object code and final Program Counter value is shown in the following table:\nLocation Instruction\n47C \u2190 PC after jump\n47D \u2013\n47E \u2013\n47F \u2013\n480 38\n481 FA (two\u2019s \ncomplement \u2013 6)",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=281"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JR NC, e",
        "operation": "If C = 1, continue \nIf C = 0, PC \u2190 PC \u002B e",
        "opcode": "JR",
        "operands": "NC, e\n00101 0 0 0 30\ne\u20132",
        "conditionBitsAffected": "None.",
        "description": "This instruction provides for conditional branching to other segments of a program \ndepending on the results of a test on the Carry Flag. If the flag is equal to 0, the value of \ndisplacement e is added to the Program Counter (PC) and the next instruction is fetched \nfrom the location designated by the new contents of the PC. The jump is measured from \nthe address of the instruction op code and contains a range of \u2013126 to \u002B129 bytes. The \nassembler automatically adjusts for the twice incremented PC.\nIf the flag = 1, the next instruction executed is taken from the location following this \ninstruction.\nIf the condition is met:\nM Cycles T States 4 MHz E.T.\n3 12 (4, 3, 5) 3.00\nIf the condition is not met:\nM Cycles T States 4 MHz E.T.\n7 7 (4, 3) 1.75",
        "example": "The Carry Flag is reset and it is required to repeat the jump instruction. The assembly lan-\nguage statement is JR NC, $\nThe resulting object code and Program Counter after the jump are:\nLocation Instruction\n480 30 \u2190 PC after jump\n481 00",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=283"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JR Z, e",
        "operation": "If Z = 0, continue \nIf Z = 1, PC \u2190 PC \u002B e",
        "opcode": "JR",
        "operands": "Z, e\n28\n00110 0 0 0\ne\u20132",
        "conditionBitsAffected": "None.",
        "description": "This instruction provides for conditional branching to other segments of a program \ndepending on the results of a test on the Zero Flag. If the flag = 1, the value of displace-\nment e is added to the Program Counter (PC) and the next instruction is fetched from the \nlocation designated by the new contents of the PC. The jump is measured from the address \nof the instruction op code and contains a range of \u2013126 to \u002B129 bytes. The assembler auto-\nmatically adjusts for the twice-incremented PC.\nIf the Zero Flag = 0, the next instruction executed is taken from the location following this \ninstruction. \nIf this condition is met, the following data results:\nM Cycles T States 4 MHz E.T.\n3 12 (4, 3, 5) 3.00\nIf this condition is not met, the following data results:\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "The Zero Flag is set and it is required to jump forward five locations from address 300. \nThe following assembly language statement is used:\nJR Z ,$ \u002B 5\nThe resulting object code and final Program Counter value are:\nLocation Instruction\n300 28\n301 03\n302 \u2013\n303 \u2013\n304 \u2013\n305 \u2190 PC after jump",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=285"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JR NZ, e",
        "operation": "If Z = 1, continue \nIf Z = 0, PC \u2190 pc \u002B e",
        "opcode": "JR",
        "operands": "NZ, e\n00100 0 0 0 20\ne\u20132",
        "conditionBitsAffected": "None.",
        "description": "This instruction provides for conditional branching to other segments of a program \ndepending on the results of a test on the Zero Flag. If the flag = 0, the value of displace-\nment e is added to the Program Counter (PC) and the next instruction is fetched from the \nlocation designated by the new contents of the PC. The jump is measured from the address \nof the instruction op code and contains a range of \u2013126 to \u002B129 bytes. The assembler auto-\nmatically adjusts for the twice incremented PC.\nIf the Zero Flag = 1, the next instruction executed is taken from the location following this \ninstruction.\nIf the condition is met:\nM Cycles T States 4 MHz E.T.\n3 12 (4, 3, 5) 3.00\nIf the condition is not met:\nM Cycles T States 4 MHz E.T.\n2 7 (4, 3) 1.75",
        "example": "The Zero Flag is reset and it is required to jump back four locations from 480. The assem-\nbly language statement is JR NZ, $\u20134\nThe resulting object code and final Program Counter value is:\nLocation Instruction\n47C \u2190 PC after jump\n47D \u2013\n47E \u2013\n47F \u2013\n480 20\n481 FA (two\u2019s \ncomplement \u2013 6)",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=287"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JP (HL)",
        "operation": "PC \u2190 HL",
        "opcode": "JP",
        "operands": "(HL)\nE9\n11110 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The Program Counter (PC) is loaded with the contents of the HL register pair. The next \ninstruction is fetched from the location designated by the new contents of the PC.\nM Cycles T States 4 MHz E.T.\n14 1.00",
        "example": "If the Program Counter contains 1000h and the HL register pair contains 4800h, then \nupon the execution of a JP (HL) instruction, the Program Counter contains 4800h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=289"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JP (IX)",
        "operation": "pc \u2190 IX",
        "opcode": "JP",
        "operands": "(IX)\nDD\n11011 1 0 1\nE9\n11110 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The Program Counter (PC) is loaded with the contents of the IX register pair. The next \ninstruction is fetched from the location designated by the new contents of the PC.\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": "If the Program Counter contains 1000h and the IX register pair contains 4800h, then \nupon the execution of a JP (IX) instruction, the Program Counter contains 4800h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=290"
    },
    {
        "groupName": "Jump Group",
        "keyword": "JP (IY)",
        "operation": "PC \u2190 IY",
        "opcode": "JP",
        "operands": "(IY)\nFD\n11111 1 0 1\nE9\n11110 0 0 1",
        "conditionBitsAffected": "None.",
        "description": "The Program Counter (PC) is loaded with the contents of the IY register pair. The next \ninstruction is fetched from the location designated by the new contents of the PC.\nM Cycles T States 4 MHz E.T.\n2 8 (4, 4) 2.00",
        "example": "If the Program Counter contains 1000h and the IY register pair contains 4800h, then \nupon the execution of a JP (IY) instruction, the Program Counter contains 4800h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=291"
    },
    {
        "groupName": "Jump Group",
        "keyword": "DJNZ, e",
        "operation": "B \u2190 B \u2013 1\nIf B = 0, continue\nIf B \u2260 0, PC \u2190 PC \u002B e",
        "opcode": "DJNZ",
        "operands": "e\n10\n00001 0 0 0\ne\u20132",
        "conditionBitsAffected": "None.",
        "description": "This instruction is similar to the conditional jump instructions except that a register value \nis used to determine branching. Register B is decremented, and if a nonzero value remains, \nthe value of displacement e is added to the Program Counter (PC). The next instruction is \nfetched from the location designated by the new contents of the PC. The jump is measured \nfrom the address of the instruction op code and contains a range of \u2013126 to \u002B129 bytes. \nThe assembler automatically adjusts for the twice incremented PC.\nIf the result of decrementing leaves B with a zero value, the next instruction executed is \ntaken from the location following this instruction.\nif B \u2260 0:\nM Cycles T States 4 MHz E.T.\n3 13 (5,3, 5) 3.25\nIf B = 0:\nM Cycles T States 4 MHz E.T.\n2 8 (5, 3) 2.00",
        "example": "A typical software routine is used to demonstrate the use of the DJNZ instruction. This \nroutine moves a line from an input buffer (INBUF) to an output buffer (OUTBUF). It \nmoves the bytes until it finds a CR, or until it has moved 80 bytes, whichever occurs first.\nLD 8, 80 ;Set up counter\nLD HL, Inbuf ;Set up pointers\nLD DE, Outbuf\nLOOP: LID A, (HL) ;Get next byte from\n;input buffer\nLD (DE), A ;Store in output buffer\nCP ODH ;Is it a CR?\nJR Z, DONE ;Yes finished\nINC HL ;Increment pointers\nINC DE\nDJNZ LOOP ;Loop back if 80\n;bytes have not\n;been moved\nDONE:",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=292"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "CALL nn",
        "operation": "(SP \u2013 1) \u2190 PCH, (SP \u2013 2) \u2190 PCL, PC \u2190 nn",
        "opcode": "CALL",
        "operands": "nn\nCD\n11010 1 0 1\nn\nn\nThe first of the two n operands in the assembled object code above is the least-significant \nbyte of a 2-byte memory address.",
        "conditionBitsAffected": "None.",
        "description": "The current contents of the Program Counter (PC) are pushed onto the top of the external \nmemory stack. The operands nn are then loaded to the PC to point to the address in mem-\nory at which the first op code of a subroutine is to be fetched. At the end of the subroutine, \na RETurn instruction can be used to return to the original program flow by popping the top \nof the stack back to the PC. The push is accomplished by first decrementing the current \ncontents of the Stack Pointer (register pair SP), loading the high-order byte of the PC con-\ntents to the memory address now pointed to by the SP; then decrementing SP again, and \nloading the low-order byte of the PC contents to the top of stack. \nBecause this process is a 3-byte instruction, the Program Counter was incremented by \nthree before the push is executed.\nM Cycles T States 4 MHz E.T.\n5 17 (4, 3, 4, 3, 3) 4.25",
        "example": "The Program Counter contains 1A47h, the Stack Pointer contains 3002h, and memory \nlocations contain the following data.\nLocation Contents\n1A47h CDh\nIA48h 35h\n1A49h 21h\nIf an instruction fetch sequence begins, the 3-byte instruction CD 3521h is fetched to the \nCPU for execution. The mnemonic equivalent of this instruction is CALL 2135h. Upon \nthe execution of this instruction, memory address 3001h contains 1Ah, address 3000h \ncontains 4Ah, the Stack Pointer contains 3000h, and the Program Counter contains \n2135h, thereby pointing to the address of the first op code of the next subroutine to be \nexecuted.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=295"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "CALL cc, nn",
        "operation": "IF cc true: (sp \u2013 1) \u2190 PCH\n(sp \u2013 2) \u2190 PCL, pc \u2190 nn",
        "opcode": "CALL",
        "operands": "cc, nn\ncc\n11 100\nn\nn\nThe first of the two n operands in the assembled object code above is the least-significant \nbyte of the 2-byte memory address.",
        "conditionBitsAffected": "None.",
        "description": "If condition cc is true, this instruction pushes the current contents of the Program Counter \n(PC) onto the top of the external memory stack, then loads the operands nn to PC to point \nto the address in memory at which the first op code of a subroutine is to be fetched. At the \nend of the subroutine, a RETurn instruction can be used to return to the original program \nflow by popping the top of the stack back to PC. If condition cc is false, the Program \nCounter is incremented as usual, and the program continues with the next sequential \ninstruction. The stack push is accomplished by first decrementing the current contents of \nthe Stack Pointer (SP), loading the high-order byte of the PC contents to the memory \naddress now pointed to by SP; then decrementing SP again, and loading the low-order \nbyte of the PC contents to the top of the stack.\nBecause this process is a 3-byte instruction, the Program Counter was incremented by \nthree before the push is executed. \nCondition cc is programmed as one of eight statuses that corresponds to condition bits in \nthe Flag Register (Register F). These eight statuses are defined in the following table, \nwhich also specifies the corresponding cc bit fields in the assembled object code.\n\r\nRelevant\ncc Condition Flag\n000 Non-Zero (NZ) Z\n001 Zero (Z) Z\n010 Non Carry (NC) C\n011 Carry (C) Z\n100 Parity Odd (PO) P/V\n101 Parity Even (PE) P/V\n110 Sign Positive (P) S\n111 Sign Negative (M) S\nIf cc is true:\nM Cycles T States 4 MHz E.T.\n5 17 (4, 3, 4, 3, 3) 4.25\nIf cc is false:\nM Cycles T States 4 MHz E.T.\n3 10 (4, 3, 3) 2.50",
        "example": "The C Flag in the F Register is reset, the Program Counter contains 1A47h, the Stack \nPointer contains 3002h, and memory locations contain the following data.\nLocation Contents\n1A47h D4h\n1448h 35h\n1A49h 21h\nIf an instruction fetch sequence begins, the 3-byte instruction D43521h is fetched to the \nCPU for execution. The mnemonic equivalent of this instruction is CALL NC, 2135h. \nUpon the execution of this instruction, memory address 3001h contains 1Ah, address \n3000h contains 4Ah, the Stack Pointer contains 3000h, and the Program Counter contains \n2135h, thereby pointing to the address of the first op code of the next subroutine to be \nexecuted.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=297"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "RET",
        "operation": "pCL \u2190 (sp), pCH \u2190 (sp\u002B1)",
        "opcode": "RET\nC9\n11010 0 0 1",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "The byte at the memory location specified by the contents of the Stack Pointer (SP) Regis-\nter pair is moved to the low-order eight bits of the Program Counter (PC). The SP is now \nincremented and the byte at the memory location specified by the new contents of this \ninstruction is fetched from the memory location specified by the PC. This instruction is \nnormally used to return to the main line program at the completion of a routine entered by \na CALL instruction.\nM Cycles T States 4 MHz E.T.\n3 10 (4, 3, 3) 2.50",
        "example": "The Program Counter contains 3535h, the Stack Pointer contains 2000h, memory loca-\ntion 2000h contains B5h, and memory location 2001h contains 18h. Upon the execution \nof a RET instruction, the Stack Pointer contains 2002h and the Program Counter contains \n18B5h, thereby pointing to the address of the next program op code to be fetched.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=299"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "RET cc",
        "operation": "If cc true: PCL \u2190 (sp), pCH \u2190 (sp\u002B1)",
        "opcode": "RET",
        "operands": "cc\ncc\n11 000",
        "conditionBitsAffected": "None.",
        "description": "If condition cc is true, the byte at the memory location specified by the contents of the \nStack Pointer (SP) Register pair is moved to the low-order eight bits of the Program Coun-\nter (PC). The SP is incremented and the byte at the memory location specified by the new \ncontents of the SP are moved to the high-order eight bits of the PC. The SP is incremented \nagain. The next op code following this instruction is fetched from the memory location \nspecified by the PC. This instruction is normally used to return to the main line program at \nthe completion of a routine entered by a CALL instruction. If condition cc is false, the PC \nis simply incremented as usual, and the program continues with the next sequential \ninstruction. Condition cc is programmed as one of eight status that correspond to condition \nbits in the Flag Register (Register F). These eight status are defined in the following table, \nwhich also specifies the corresponding cc bit fields in the assembled object code.\nRelevant\ncc Condition Flag\n000 Non-Zero (NZ) Z\n001 Zero (Z) Z\n010 Non Carry (NC) C\n011 Carry (C) C\n100 Parity Odd (PO) P/V\n101 Parity Even (PE) P/V\n110 Sign Positive (P) S\n111 Sign Negative (M) S\n\r\nIf cc is true, then the following data is returned:\nM Cycles T States 4 MHz E.T.\n3 11 (5, 3, 3) 2.75\nIf cc is false, then the following data is returned:\nM Cycles T States 4 MHz E.T.\n15 1.25",
        "example": "The S flag in the F Register is set, the Program Counter contains 3535h, the Stack Pointer \ncontains 2000h, memory location 2000h contains B5h, and memory location 2001h con-\ntains 18h. Upon the execution of a RET M instruction, the Stack Pointer contains 2002h \nand the Program Counter contains 18B5h, thereby pointing to the address of the next pro-\ngram op code to be fetched.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=300"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "RETI",
        "operation": "Return from Interrupt",
        "opcode": "RETI\nED\n11110 1 0 1\n4D\n01010 1 0 1",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "This instruction is used at the end of a maskable interrupt service routine to:\n\u2022 Restore the contents of the Program Counter (analogous to the RET instruction)\n\u2022 Signal an I/O device that the interrupt routine is completed. The RETI instruction also \nfacilitates the nesting of interrupts, allowing higher priority devices to temporarily \nsuspend service of lower priority service routines. However, this instruction does not \nenable interrupts that were disabled when the interrupt routine was entered. Before \ndoing the RETI instruction, the enable interrupt instruction (EI) should be executed to \nallow recognition of interrupts after completion of the current service routine.\nM Cycles T States 4 MHz E.T.\n4 14 (4, 4, 3, 3) 3.50",
        "example": "Assume that there are two interrupting devices, A and B, connected in a daisy-chain con-\nfiguration, with A having a higher priority than B.\n\r\nA B\n\u002B\nIEO IEI\nIEI\nIEO\nINT\nB generates an interrupt and is acknowledged. The interrupt enable out, IEO, of B goes \nLow, blocking any lower priority devices from interrupting while B is being serviced. \nThen A generates an interrupt, suspending service of B. The IEO of A goes Low, indicat-\ning that a higher priority device is being serviced. The A routine is completed and a RETI \nis issued resetting the IEO of A, allowing the B routine to continue. A second RETI is \nissued on completion of the B routine and the IE0 of B is reset (High), allowing lower-pri-\nority devices interrupt access.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=302"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "RETN",
        "operation": "Return from nonmaskable interrupt",
        "opcode": "RETN\nED\n11110 1 0 1\n45\n01000 1 0 1",
        "operands": "None.",
        "conditionBitsAffected": "None.",
        "description": "This instruction is used at the end of a nonmaskable interrupts service routine to restore \nthe contents of the Program Counter (analogous to the RET instruction). The state of IFF2 \nis copied back to IFF1 so that maskable interrupts are enabled immediately following the \nRETN if they were enabled before the nonmaskable interrupt.\nM Cycles T States 4 MHz E.T.\n4 14 (4, 4, 3, 3) 3.50",
        "example": "If the Stack Pointer contains 1000h and the Program Counter contains 1A45h when a \nNonmaskable Interrupt (NMI) signal is received, the CPU ignores the next instruction and \ninstead restarts, returning to memory address 0066h. The current Program Counter con-\ntains 1A45h, which is pushed onto the external stack address of 0FFFh and 0FFEh, high-\norder byte first, and 0066h is loaded onto the Program Counter. That address begins an \ninterrupt service routine that ends with a RETN instruction. \nUpon the execution of a RETN instruction, the contents of the former Program Counter \nare popped off the external memory stack, low-order first, resulting in the Stack Pointer \nagain containing 1000h. The program flow continues where it left off with an op code \nfetch to address 1A45h, order-byte first, and 0066h is loaded onto the Program Counter. \n\r\nThat address begins an interrupt service routine that ends with a RETN instruction. Upon \nthe execution of a RETN instruction, the contents of the former Program Counter are \npopped off the external memory stack, low-order first, resulting in stack pointer contents \nof 1000h. The program flow continues where it left off with an op code fetch to address \n1A45h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=304"
    },
    {
        "groupName": "Call and Return Group",
        "keyword": "RST p",
        "operation": "(SP \u2013 1) \u2190 PCH, (SP \u2013 2) \u2190 PCL, PCH \u2190 0, PCL \u2190 P",
        "opcode": "RST",
        "operands": "p\n11 t 111",
        "conditionBitsAffected": "",
        "description": "",
        "example": "If the Program Counter contains 15B3h, then upon the execution of an RST 18h (object \ncode 1101111) instruction, the PC contains 0018h as the address of the next fetched op \ncode.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=306"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "IN A, (n)",
        "operation": "A \u2190 (n)",
        "opcode": "IN",
        "operands": "A, (n)\nDB\n11011 0 1 1\nn",
        "conditionBitsAffected": "None.",
        "description": "The operand n is placed on the bottom half (A0 through A7) of the address bus to select \nthe I/O device at one of 256 possible ports. The contents of the Accumulator also appear \non the top half (A8 through A15) of the address bus at this time. Then one byte from the \nselected port is placed on the data bus and written to the Accumulator (Register A) in the \nCPU.\nM Cycles T States 4 MHz LT.\n3 11 (4, 3, 4) 2.75",
        "example": "The Accumulator contains 23h, and byte 7Bh is available at the peripheral device mapped \nto I/O port address 01h. Upon the execution of an IN A, (01h) instruction, the Accumula-\ntor contains 7Bh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=309"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "IN r (C)",
        "operation": "r \u2190 (C)",
        "opcode": "IN",
        "operands": "r, (C)\nED\n11110 1 0 1\n01 r 000",
        "conditionBitsAffected": "S is set if input data is negative; otherwise, it is reset.\nZ is set if input data is 0; otherwise, it is reset.\nH is reset.\nP/V is set if parity is even; otherwise, it is reset.\nN is reset.\nC is not affected.",
        "description": "The contents of Register C are placed on the bottom half (A0 through A7) of the address \nbus to select the I/O device at one of 256 possible ports. The contents of Register B are \nplaced on the top half (A8 through A15) of the address bus at this time. Then one byte \nfrom the selected port is placed on the data bus and written to register r in the CPU. Regis-\nter r identifies any of the CPU registers shown in the following table, which also indicates \nthe corresponding 3-bit r field for each. The flags are affected, checking the input data.\nRegister r\nFlag 110 Undefined op code; set the flag\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111\nM Cycles T States 4 MHz E.T.\n3 12 (4, 4, 4) 3.00",
        "example": "Register C contains 07h, Register B contains 10h, and byte 7Bh is available at the periph-\neral device mapped to I/O port address 07h. Upon the execution of an IN D, (C) com-\nmand, the D Register contains 7Bh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=310"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "INI",
        "operation": "(HL) \u2190 (C), B \u2190 B \u2013 1, HL \u2190 HL \u002B 1",
        "opcode": "INI\nED\n11110 1 0 1\nA2\n10100 0 1 0",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set if B \u2013 1 = 0; otherwise it is reset.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of Register C are placed on the bottom half (A0 through A7) of the address \nbus to select the I/O device at one of 256 possible ports. Register B can be used as a byte \ncounter, and its contents are placed on the top half (A8 through A15) of the address bus at \nthis time. Then one byte from the selected port is placed on the data bus and written to the \nCPU. The contents of the HL register pair are then placed on the address bus and the input \nbyte is written to the corresponding location of memory. Finally, the byte counter is decre-\nmented and register pair HL is incremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "Register C contains 07h, Register B contains 10h, the HL register pair contains 1000h, \nand byte 7Bh is available at the peripheral device mapped to I/O port address 07h. Upon \nthe execution of an INI instruction, memory location 1000h contains 7Bh, the HL register \npair contains 1001h, and Register B contains 0Fh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=312"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "INIR",
        "operation": "(HL) \u2190 (C), B \u2190 B \u2013 1, HL \u2190 HL \u002B1",
        "opcode": "INIR\nED\n11110 1 0 1\nB2\n10101 0 1 0",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of Register C are placed on the bottom half (A0 through A7) of the address \nbus to select the I/O device at one of 256 possible ports. Register B is used as a byte coun-\nter, and its contents are placed on the top half (A8 through A15) of the address bus at this \ntime. Then one byte from the selected port is placed on the data bus and written to the \nCPU. The contents of the HL register pair are placed on the address bus and the input byte \nis written to the corresponding location of memory. Then register pair HL is incremented, \nthe byte counter is decremented. If decrementing causes B to go to 0, the instruction is ter-\nminated. If B is not 0, the Program Counter is decremented by two and the instruction \nrepeated. Interrupts are recognized and two refresh cycles execute after each data transfer. \nNote: If B is set to 0 prior to instruction execution, 256 bytes of data are input.\nIf B \u2260 0:\nM Cycles T States 4 MHz E.T.\n5 21 (4, 5, 3, 4, 5) 5.25\nIf B = 0:\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "Register C contains 07h, Register B contains 03h, the HL register pair contains 1000h, \nand the following sequence of bytes is available at the peripheral device mapped to I/O \nport of address 07h.\n51h\nA9h\n03h\nUpon the execution of an INIR instruction, the HL register pair contains 1003h, Register \nB contains a 0, and the memory locations contain the following data: \n1000h 51h\n1001h A9h\n1002h 03h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=314"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "IND",
        "operation": "(HL) \u2190 (C), B \u2190 B \u2013 1, HL \u2190 HL \u2013 1",
        "opcode": "IND\nED\n11110 1 0 1\nAA\n10110 0 1 0",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set if B \u2013 1 = 0; otherwise, it is reset.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of Register C are placed on the bottom half (A0 through A7) of the address \nbus to select the I/O device at one of 256 possible ports. Register B can be used as a byte \ncounter, and its contents are placed on the top half (A8 through A15) of the address bus at \nthis time. Then one byte from the selected port is placed on the data bus and written to the \nCPU. The contents of the HL register pair are placed on the address bus and the input byte \nis written to the corresponding location of memory. Finally, the byte counter and register \npair HL are decremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "Register C contains 07h, Register B contains 10h, the HL register pair contains 1000h, \nand byte 7Bh is available at the peripheral device mapped to I/O port address 07h. Upon \nthe execution of an IND instruction, memory location 1000h contains 7Bh, the HL regis-\nter pair contains 0FFFh, and Register B contains 0Fh.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=316"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "INDR",
        "operation": "(HL) \u2190 (C), B \u2190 131, HL \u2190 HL1",
        "opcode": "INDR\nED\n11110 1 0 1\nBA\n10111 0 1 0",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of Register C are placed on the bottom half (A0 through A7) of the address \nbus to select the I/O device at one of 256 possible ports. Register B is used as a byte coun-\nter, and its contents are placed on the top half (A8 through A15) of the address bus at this \ntime. Then one byte from the selected port is placed on the data bus and written to the \nCPU. The contents of the HL register pair are placed on the address bus and the input byte \nis written to the corresponding location of memory. Then HL and the byte counter are dec-\nremented. If decrementing causes B to go to 0, the instruction is terminated. If B is not 0, \nthe Program Counter is decremented by two and the instruction repeated. Interrupts are \nrecognized and two refresh cycles are executed after each data transfer. \nWhen B is set to 0 prior to instruction execution, 256 bytes of data are input.\nIf B \u2260 0:\nM Cycles T States 4 MHz E.T.\n5 21 (4, 5, 3, 4, 5) 5.25\nIf B = 0:\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "Register C contains 07h, Register B contains 03h, the HL register pair contains 1000h \nand the following sequence of bytes is available at the peripheral device mapped to I/O \nport address 07h:\n51h\nA9h\n03h\nUpon the execution of an INDR instruction, the HL register pair contains 0FFDh, Register \nB contains a 0, and the memory locations contain the following data: \n0FFEh 03h\n0FFFh A9h\n1000h 51h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=318"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "OUT (n), A",
        "operation": "(n) \u2190 A",
        "opcode": "OUT",
        "operands": "(n), A\nD3\n11001 0 1 1\nn",
        "conditionBitsAffected": "None.",
        "description": "The operand n is placed on the bottom half (A0 through A7) of the address bus to select \nthe I/O device at one of 256 possible ports. The contents of the Accumulator (Register A) \nalso appear on the top half (A8 through A15) of the address bus at this time. Then the byte \ncontained in the Accumulator is placed on the data bus and written to the selected periph-\neral device.\nM Cycles T States 4 MHz E.T.\n3 11 (4, 3, 4) 2.75",
        "example": "If the Accumulator contains 23h, then upon the execution of an OUT (01h) instruction, \nbyte 23h is written to the peripheral device mapped to I/O port address 01h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=320"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "OUT (C), r",
        "operation": "(C) \u2190 r",
        "opcode": "OUT",
        "operands": "(C), r\nED\n11110 1 0 1\n01 r 010",
        "conditionBitsAffected": "None.",
        "description": "The contents of Register C are placed on the bottom half (A0 through A7) of the address \nbus to select the I/O device at one of 256 possible ports. The contents of Register B are \nplaced on the top half (A8 through A15) of the address bus at this time. Then the byte con-\ntained in register r is placed on the data bus and written to the selected peripheral device. \nRegister r identifies any of the CPU registers shown in the following table, which also \nshows the corresponding three-bit r field for each that appears in the assembled object \ncode.\nRegister r\nB 000\nC 001\nD 010\nE 011\nH 100\nL 101\nA 111\nM Cycles T States 4 MHz E.T.\n3 12 (4, 4, 4) 3.00",
        "example": "If Register C contains 01h and the D Register contains 5Ah, then upon the execution of an \nOUT (C), D instruction, byte 5Ah is written to the peripheral device mapped to I/O port \naddress 01h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=321"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "OUTI",
        "operation": "(C) \u2190 (HL), B \u2190 B \u2013 1, HL \u2190 HL \u002B 1",
        "opcode": "OUTI\nED\n11110 1 0 1\nA3\n10100 0 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set if B \u2013 1 = 0; otherwise, it is reset.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of the HL register pair are placed on the address bus to select a location in \nmemory. The byte contained in this memory location is temporarily stored in the CPU. \nThen, after the byte counter (B) is decremented, the contents of Register C are placed on \nthe bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 \npossible ports. Register B can be used as a byte counter, and its decremented value is \nplaced on the top half (A8 through A15) of the address bus. The byte to be output is placed \non the data bus and written to a selected peripheral device. Finally, the register pair HL is \nincremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "If Register C contains 07h, Register B contains 10h, the HL register pair contains 100014 \nand memory address 1000h contains 5914, then upon the execution of an OUTI instruc-\ntion, Register B contains 0Fh, the HL register pair contains 1001h, and byte 59h is writ-\nten to the peripheral device mapped to I/O port address 07h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=323"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "OTIR",
        "operation": "(C) \u2190 (HL), B \u2190 B \u2013 1, HL \u2190 HL \u002B 1",
        "opcode": "OTIR\nED\n11110 1 0 1\nB3\n10101 0 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of the HL register pair are placed on the address bus to select a location in \nmemory. The byte contained in this memory location is temporarily stored in the CPU. \nThen, after the byte counter (B) is decremented, the contents of Register C are placed on \nthe bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 \npossible ports. Register B can be used as a byte counter, and its decremented value is \nplaced on the top half (A8 through A15) of the address bus at this time. Next, the byte to \nbe output is placed on the data bus and written to the selected peripheral device. Then reg-\nister pair HL is incremented. If the decremented B Register is not 0, the Program Counter \n(PC) is decremented by two and the instruction is repeated. If B has gone to 0, the instruc-\ntion is terminated. Interrupts are recognized and two refresh cycles are executed after each \ndata transfer. \nNote: When B is set to 0 prior to instruction execution, the instruction outputs 256 bytes of data.\nIf B \u2260 0:\nM Cycles T States 4 MHz E.T.\n5 21 (4, 5, 3, 4, 5) 5.25\n\r\nIf B = 0:\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "Register C contains 07h, Register B contains 03h, the HL register pair contains 1000h, \nand memory locations contain the following data.\n1000h contains 51h\n1001h contains A9h\n1002h contains 03h\nUpon the execution of an OTIR instruction, the HL register pair contains 1003h, Register \nB contains a 0, and a group of bytes is written to the peripheral device mapped to I/O port \naddress 07h in the following sequence:\n51h\nA9h\n03h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=325"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "OUTD",
        "operation": "(C) \u2190 (HL), B \u2190 B \u2013 1, HL \u2190 HL \u2013 1",
        "opcode": "OUTD\nED\n11110 1 0 1\nAB\n10110 0 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set if B \u2013 1 = 0; otherwise, it is reset.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of the HL register pair are placed on the address bus to select a location in \nmemory. The byte contained in this memory location is temporarily stored in the CPU. \nThen, after the byte counter (B) is decremented, the contents of Register C are placed on \nthe bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 \npossible ports. Register B can be used as a byte counter, and its decremented value is \nplaced on the top half (A8 through A15) of the address bus at this time. Next, the byte to \nbe output is placed on the data bus and written to the selected peripheral device. Finally, \nthe register pair HL is decremented.\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3. 4) 4.00",
        "example": "If Register C contains 07h, Register B contains 10h, the HL register pair contains 1000h, \nand memory location 1000h contains 59h, then upon the execution of an OUTD instruc-\ntion, Register B contains 0Fh, the HL register pair contains 0FFFh, and byte 59h is writ-\nten to the peripheral device mapped to I/O port address 07h.",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=327"
    },
    {
        "groupName": "Input and Output Group",
        "keyword": "OTDR",
        "operation": "(C) \u2190 (HL), B \u2190 B \u2013 1, HL \u2190 HL \u2013 1",
        "opcode": "OTDR\nED\n11110 1 0 1\nBB\n10111 0 1 1",
        "operands": "None.",
        "conditionBitsAffected": "S is unknown.\nZ is set.\nH is unknown.\nP/V is unknown.\nN is set.\nC is not affected.",
        "description": "The contents of the HL register pair are placed on the address bus to select a location in \nmemory. The byte contained in this memory location is temporarily stored in the CPU. \nThen, after the byte counter (B) is decremented, the contents of Register C are placed on \nthe bottom half (A0 through A7) of the address bus to select the I/O device at one of 256 \npossible ports. Register B can be used as a byte counter, and its decremented value is \nplaced on the top half (A8 through A15) of the address bus at this time. Next, the byte to \nbe output is placed on the data bus and written to the selected peripheral device. Then, reg-\nister pair HL is decremented and if the decremented B Register is not 0, the Program \nCounter (PC) is decremented by two and the instruction is repeated. If B has gone to 0, the \ninstruction is terminated. Interrupts are recognized and two refresh cycles are executed \nafter each data transfer. \nNote: When B is set to 0 prior to instruction execution, the instruction outputs 256 bytes of data.\nIf B \u2260 0:\nM Cycles T States 4 MHz E.T.\n5 21 (4, 5, 3, 4, 5) 5.25\n\r\nIf B = 0:\nM Cycles T States 4 MHz E.T.\n4 16 (4, 5, 3, 4) 4.00",
        "example": "Register C contains 07h, Register B contains 03h, the HL register pair contains 1000h, \nand memory locations contain the following data.\n0FFEh 51h\n0FFFh A9h\n1000h 03h\nUpon the execution of an OTDR instruction, the HL register pair contain 0FFDh, Register \nB contains a 0, and a group of bytes is written to the peripheral device mapped to I/O port \naddress 07h in the following sequence:\n03h\nA9h\n51h",
        "link": "https://dgzornoza.github.io/zx-spectrum-tools/Docs/AssemblerZ80.pdf#page=329"
    }
]