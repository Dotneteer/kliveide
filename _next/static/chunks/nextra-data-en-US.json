{"/book":{"title":"Inside the ZX Spectrum Next — A Programmer's and Emulator Developer's Guide","data":{"":"Welcome to my book about the ZX Spectrum Next and its programming with Z80 Assembly.\nThis book is still in development, so what you see here is a very early and incomplete version.\nCopyright © 2025-2026 István NovákThis work is licensed under the Creative Commons Attribution 4.0 International License (CC BY 4.0). You are free to:\nShare — copy and redistribute the material in any medium or format\nAdapt — remix, transform, and build upon the material for any purpose, even commercially\nUnder the following terms:\nAttribution — You must give appropriate credit to István Novák, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\nTo view a copy of this license, visit: https://creativecommons.org/licenses/by/4.0/","dedication#Dedication":"Dad, Mom, without your support, I would not become the proud family man and software engineer I am.Your son","table-of-contents#Table of Contents":"Preface\nIntroduction\nAppendix A: The NEX File Format\nAppendix B: NextReg Reference"}},"/book/app-A-nex-file-format":{"title":"Appendix A: The NEX File Format","data":{"":"Throughout this book, every hands-on exercise loads and runs code using the NEX file format. It's the standard way to distribute ZX Spectrum Next applications - a single file that contains everything needed to load and run a program. Understanding NEX files isn't just academic curiosity; it's essential for testing your emulator, running examples, and eventually creating your own Next software. This chapter breaks down the format from the user's perspective first, then dives into the implementation details you'll need for your emulator's loader.","why-nex-files-exist-the-problem-they-solve#Why NEX Files Exist: The Problem They Solve":"The original ZX Spectrum had multiple file formats: TAP files for tape images, SNA and Z80 for snapshots, raw binaries that needed manual loading. Each format served a purpose, but none were ideal for modern distribution. TAP files included tape loading headers with checksums. Snapshot formats saved entire machine state but couldn't preserve modern Next features. Raw binaries required complex multi-step loading procedures.The Next needed something better: a self-contained executable format that could:\nLoad directly from the SD card operating system (NextZXOS/ESXDOS)\nSpecify exactly which memory banks to load and where\nInclude loading screens (Layer 2, ULA, LoRes, or Timex modes)\nSet up hardware registers, palettes, and initial state\nSupport the full 2MB address space (112 banks of 16KB each)\nRun immediately after loading without manual setup\nThat's NEX. Think of it as the Next's equivalent to EXE on Windows or ELF on Linux - a standardized executable format that \"just works.\"","file-structure-layers-of-a-nex-file#File Structure: Layers of a NEX File":"Every NEX file starts with a mandatory 512-byte header, followed by optional blocks as needed. Here's the complete structure:\nBlock\tSize\tPurpose\tHeader\t512 bytes\tMagic number, version, loading instructions, bank list\tPalette\t512 bytes\t256 color entries (Layer 2, LoRes, Tilemap screens)\tLoading Screen\t6,912–81,920 bytes\tULA, Layer 2, LoRes, or Timex display during loading\tCopper Code\t2,048 bytes\tRaster effects for animated loading bar\tBank 5\t16,384 bytes\tFirst memory bank in file order (ULA screen memory)\tBank 2\t16,384 bytes\tSecond bank (typically working memory)\tBanks 0, 1, 3, 4, 6–111\t16,384 bytes each\tRemaining banks in defined order\tCustom Data\tVariable\tApplication-defined data (levels, assets, etc.)\t\nThe header tells you what's coming. The optional blocks appear only if the header says they're present. Everything is laid out sequentially - no seeks, no compression, no complex structures. Just read block after block in order.","the-header-control-center-for-loading#The Header: Control Center for Loading":"The first 512 bytes contain everything the loader needs to know. Let's break down the key fields:","identification-and-version-offsets-0-7#Identification and Version (Offsets 0-7)":"Offset 0: \"Next\" (4 bytes) - Magic number identifying NEX files\nOffset 4: \"V1.2\" (4 bytes) - Version string (V1.0, V1.1, or V1.2)\nEvery NEX file starts with the ASCII string \"Next\" followed by the version. This lets loaders quickly verify \"yes, this is a NEX file\" and \"yes, I understand this version.\" If you encounter \"Next\" but an unknown version, you can reject the file early.","memory-requirements-offset-8#Memory Requirements (Offset 8)":"Offset 8: RAM required (1 byte)\n  0 = 768KB (standard Next)\n  1 = 1792KB (expanded Next)\nMost Next machines have 1MB or 2MB of RAM. This byte tells the loader whether 768KB is sufficient or if the full expanded memory is required. If the machine doesn't have enough RAM, the loader can bail out with a clear error message instead of attempting to load and failing mysteriously.","bank-loading-information-offsets-9-129#Bank Loading Information (Offsets 9-129)":"Offset 9:  Number of banks to load (1 byte) - count of 16KB banks (0-112)\nOffset 18: Bank presence array (112 bytes) - one byte per bank (0=skip, 1=load)\nThis is clever: the header contains a 112-byte array where each byte corresponds to one of the 112 possible 16KB banks (banks 0-111). A value of 1 means \"this bank's data is in the file,\" 0 means \"skip this bank.\"But here's the twist: banks appear in the file in a specific order, not sequential order:File order: 5, 2, 0, 1, 3, 4, 6, 7, 8, 9, 10, ..., 111Why start with bank 5? Because bank 5 is the ULA screen memory (0x4000-0x7FFF). If you're showing a loading screen, you want it first. Bank 2 comes next because it's often used as working memory during loading. After the first few special-case banks, the rest are sequential.Example: If the header says banks 5, 7, and 10 are present:\nByte at offset 18+5 = 23 will be 1 (bank 5 present)\nByte at offset 18+7 = 25 will be 1 (bank 7 present)\nByte at offset 18+10 = 28 will be 1 (bank 10 present)\nAll other bytes in the array will be 0\nIn the file data section, you'll find: bank 5 data (16KB), bank 7 data (16KB), bank 10 data (16KB).","loading-screens-offset-10#Loading Screens (Offset 10)":"Offset 10: Loading screen type (1 byte, bit flags)\n  Bit 7 (128): No palette block (palette omitted even if screen uses one)\n  Bit 4 (16):  Timex HiCol screen\n  Bit 3 (8):   Timex HiRes screen\n  Bit 2 (4):   LoRes screen\n  Bit 1 (2):   ULA screen\n  Bit 0 (1):   Layer 2 screen\nA NEX file can include a loading screen displayed while banks load. This byte is a bit field - multiple bits can be set, though typical files include only one screen type.The screen types have different sizes:\nLayer 2 (standard): 49,152 bytes (48KB) - 256×192, 256 colors\nLayer 2 (extended): 81,920 bytes (80KB) - 320×256×8 or 640×256×4\nULA: 6,912 bytes (6KB + 768 bytes attrs) - classic Spectrum screen\nLoRes: 12,288 bytes (12KB) - 128×96 with enhanced color attributes\nTimex HiRes: 12,288 bytes (12KB) - 512×192 monochrome\nTimex HiCol: 12,288 bytes (12KB) - 256×192 with 8×1 color cells\nIf bit 7 is clear and the screen type uses palettes (Layer 2, LoRes, Tilemap), a 512-byte palette block follows the header.","execution-parameters-offsets-11-16#Execution Parameters (Offsets 11-16)":"Offset 11: Border color (1 byte) - 0-7 (standard Spectrum colors)\nOffset 12: Stack pointer (2 bytes, little-endian)\nOffset 14: Program counter (2 bytes, little-endian) - 0 means \"don't run, just load\"\nOffset 16: Extra files count (2 bytes) - currently unused\nThe program counter is crucial: if it's zero, the loader loads everything into memory but doesn't start execution. This is useful for data files or multi-stage loading. If non-zero, the loader jumps to that address after loading completes.The stack pointer sets the initial SP value. Most programs use 0xFFFE (top of memory, growing downward), but you can specify a custom stack location if needed.","loading-progress-indicators-offsets-130-133#Loading Progress Indicators (Offsets 130-133)":"Offset 130: Layer 2 loading bar (1 byte) - 0=off, 1=on\nOffset 131: Loading bar color (1 byte) - 0-255 (palette index)\nOffset 132: Delay per bank (1 byte) - frames to wait after loading each bank\nOffset 133: Start delay (1 byte) - frames to wait before execution\nRemember those tape loading borders that flashed colors while loading? The NEX format supports a modern equivalent: a loading bar that progresses across the screen as banks load.Setting offset 130 to 1 enables this bar (only works with Layer 2 screens). Offset 131 sets the bar color. Offset 132 adds artificial delay between banks - useful if you want users to actually see the loading bar rather than having everything load instantly from SD card. Offset 133 adds delay before execution starts.Why artificial delays? Nostalgia, mostly. Loading from SD card is so fast that loading screens flash by unreadably. Adding a small delay (say, 2-3 frames per bank) lets users appreciate that beautiful loading screen you crafted.","hardware-configuration-offsets-134-141#Hardware Configuration (Offsets 134-141)":"Offset 134: Preserve NextRegs (1 byte) - 0=reset machine state, 1=preserve\nOffset 135: Required core version (3 bytes) - major.minor.subminor (0-15.0-15.0-255)\nOffset 138: Timex color / Layer 2 palette offset (1 byte)\nOffset 139: Entry bank (1 byte) - bank mapped to slot 3 (0xC000-0xFFFF)\nOffset 140: File handle address (2 bytes) - where to store file handle (0=close file)\nOffset 142: Disable expansion bus (1 byte) - 0=enabled, 1=disabled (V1.3+ loaders)\nPreserve NextRegs determines whether the loader resets all Next registers to defaults or leaves them as-is. Most programs want 0 (reset everything) for clean state. Setting 1 is useful for utilities that modify the environment without overwriting it.Required core version specifies minimum hardware requirements. The loader checks this against the actual FPGA core version and refuses to load if the hardware is too old. Format is three bytes: major version (4 bits), minor version (4 bits), subminor version (8 bits).Entry bank sets which bank appears at 0xC000-0xFFFF when execution starts. The program counter (offset 14) runs after this mapping is established. If your code lives in bank 0 and expects to run from 0xC000, set this to 0.File handle address is subtle: normally the loader closes the NEX file after loading (value 0). But if your program wants to read more data from the file (perhaps you included custom data at the end), you can request the file handle:\n0: Close file (standard behavior)\n1-0x3FFF: Pass file handle in BC register when program starts\n0x4000-0xFFFF: Write file handle to specified memory address\nThis enables streaming assets - include gigabytes of data at the end of the NEX file, keep it open, and read on demand.Disable expansion bus (offset 142, V1.3+ loaders): Controls whether the expansion bus is available during program execution. Set to 1 to disable the expansion bus (useful if your program expects exclusive hardware access and doesn't want interference from expansion devices). Set to 0 to leave it enabled. Note: This flag is only honored on core versions 3.0.5 or newer. Earlier loaders and core versions ignore this byte.","optional-blocks-palette-screens-and-copper#Optional Blocks: Palette, Screens, and Copper":"After the 512-byte header come the optional blocks. Their presence is determined by header flags.","palette-block-512-bytes#Palette Block (512 bytes)":"If the loading screen uses a palette (Layer 2, LoRes, or Tilemap) and bit 7 of offset 10 is clear, the next 512 bytes define the palette. The format is:\n256 entries × 2 bytes per entry = 512 bytes total\nEach entry (little-endian 16-bit):\n  Bits 0-2:   RRR (3-bit red)\n  Bits 3-5:   GGG (3-bit green)\n  Bits 6-8:   BBB (3-bit blue)\n  Bits 9-15:  Reserved (should be 0)\nThe Next uses 9-bit RGB333 color (3 bits red, 3 bits green, 3 bits blue). The format stores this as little-endian 16-bit values: the lower 9 bits contain the color (BBBGGGRRR), and the upper 7 bits are reserved. The loader writes these values to NextReg $44 (PALETTE_VALUE_BIT9_REGISTER).Byte layout per entry:\nByte 0 (bits 0-7): BBGGGRRR (red[2:0], green[2:0], blue[1:0])\nByte 1 (bits 8-15): 0000000B (reserved, blue[2])\nWhy 512 bytes for 256 entries? The format uses 2 bytes per entry to accommodate the 9-bit RGB333 format with room for future expansion.","loading-screen-blocks#Loading Screen Blocks":"The screen data (if present) follows the palette. The size depends on which screen type is specified:Layer 2 (48KB): 256×192 pixels, 256 colors per pixel\n256 × 192 = 49,152 bytes\nLinear framebuffer: byte N is pixel N\nColor is direct palette index (0-255)\nLayer 2 Extended (80KB): 320×256 or 640×256 pixels\n320×256×8 bpp: 320 × 256 = 81,920 bytes\n640×256×4 bpp: 640 × 256 ÷ 2 = 81,920 bytes (two pixels per byte)\nULA (6,912 bytes): Classic Spectrum format\n6,144 bytes pixel data (256×192, 1 bit per pixel)\n768 bytes attribute data (32×24 cells, 8×8 pixels per cell)\nNon-linear layout (three 2KB thirds, each with 64 rows)\nLoRes (12,288 bytes): 128×96 with 4×8 color cells\n6,144 bytes pixel data\n6,144 bytes attribute data (one byte per 4×8 block)\nAllows two colors per 4×8 block vs. ULA's 8×8\nTimex HiRes (12,288 bytes): 512×192 monochrome\nBitmap layout similar to ULA but double horizontal resolution\nColor specified in header (offset 138)\nTimex HiCol (12,288 bytes): 256×192 with 8×1 color cells\nEnhanced color resolution compared to ULA's 8×8\nEach 8-pixel row can have unique foreground/background colors","copper-code-block-2048-bytes#Copper Code Block (2,048 bytes)":"If you want animated loading effects (rainbow borders, color cycling, raster bars), include a 2KB Copper program. The Copper is a simple raster-synchronized co-processor that executes a list of WAIT/MOVE instructions:\nWAIT instructions: Pause until the raster beam reaches position (X,Y)\nMOVE instructions: Write value to NextReg register\nThe loader enables the Copper if this block is present, creating effects that run automatically while banks load. After loading completes, the Copper is disabled (unless your program re-enables it).Example use: Fade the border color through the spectrum as banks load, or animate the loading bar with raster effects.","bank-data-the-actual-program#Bank Data: The Actual Program":"After all the optional blocks come the memory banks themselves. Each bank present in the header's bank array (offset 18-129) contributes 16,384 bytes of raw data.Remember the order: 5, 2, 0, 1, 3, 4, 6, 7, 8, ..., 111If your program uses banks 0, 5, and 20:\nSkip to end of optional blocks\nRead 16KB → this is bank 5\nRead 16KB → this is bank 0 (comes before bank 2 in file order)\nRead 16KB → this is bank 20\nThe loader tracks which bank it's reading using the header's bank presence array. It walks through the array in file order, loading each present bank into the corresponding memory location.Important: Bank data is raw memory dumps. No compression, no encoding, no headers. Just 16,384 bytes exactly as they should appear in memory. This makes loading fast (no decompression) but files large if you include many banks.","custom-data-beyond-the-standard-format#Custom Data: Beyond the Standard Format":"After all the standard NEX blocks, you can append arbitrary binary data. The NEX specification doesn't define or interpret this data - it's entirely application-specific.Use cases:\nLevel data: Store game levels, load on demand via file handle\nGraphics assets: High-resolution bitmaps, too large for memory banks\nAudio samples: PCM data for music/sound effects\nScript data: Dialog, cutscenes, game logic in custom format\nAccess this data by:\nSetting the file handle address (header offset 140) to non-zero\nKeeping the file open after loading\nReading from file handle using standard file I/O from your program\nExample: A game might include 100 levels as custom data. The program loads level 1's data on demand when the player enters it, level 2 when they progress, etc. This avoids loading all levels into memory simultaneously.","practical-example-anatomy-of-a-simple-nex-file#Practical Example: Anatomy of a Simple NEX File":"Let's trace through a minimal NEX file: a program that displays \"HELLO WORLD\" in the center of a blue Layer 2 screen.","header-construction#Header Construction":"Offset 0-3:   \"Next\" (4 bytes)\nOffset 4-7:   \"V1.2\" (4 bytes)\nOffset 8:     0 (768KB RAM sufficient)\nOffset 9:     3 (three banks: 5, 9, 10)\nOffset 10:    1 (bit 0 set: Layer 2 screen included)\nOffset 11:    1 (blue border)\nOffset 12-13: 0xFFFE (stack at top of memory)\nOffset 14-15: 0xC000 (start execution at 0xC000)\nOffset 16-17: 0 (no extra files)\nBank array (offset 18-129):\nOffset 23 (18+5):  1 (bank 5 present)\nOffset 27 (18+9):  1 (bank 9 present)\nOffset 28 (18+10): 1 (bank 10 present)\nAll others:        0 (not present)\nLoading bar settings:\nOffset 130: 1 (enable loading bar)\nOffset 131: 255 (white bar)\nOffset 132: 2 (2-frame delay per bank for visibility)\nOffset 133: 50 (1-second delay before execution at 50Hz)\nHardware config:\nOffset 134: 0 (reset machine state)\nOffset 135-137: 3, 1, 10 (require core 3.1.10 minimum)\nOffset 138: 0 (Layer 2 palette offset 0)\nOffset 139: 5 (map bank 5 to slot 3 at 0xC000)\nOffset 140-141: 0 (close file after loading)\nRemainder: Pad to 512 bytes with zeros.","optional-blocks#Optional Blocks":"Palette (512 bytes):\nEntry 0: 0x0000 (black)\nEntry 1: 0x00E0 (blue = 000 111 00 in RGB332)\nEntry 255: 0x00FF (white = 111 111 11 in RGB332)\nEntries 2-254: Other colors as needed\nEach entry: 2 bytes (color in low byte, 0 in high byte)\nTotal: 256 × 2 = 512 bytes\nLayer 2 Screen (49,152 bytes):\nFill with palette index 1 (blue background): 49,152 bytes of 0x01\nExcept center region where text renders: pixels set to index 255 (white)\nNo Copper code (omitted).","bank-data-3--16kb--48kb#Bank Data (3 × 16KB = 48KB)":"Bank 5 (16,384 bytes):\nContains the Layer 2 screen data (though that's already shown via loading screen)\nOr contains font data, code, whatever bank 5 needs for the program\nBank 9 (16,384 bytes):\nAdditional Layer 2 screen data (Layer 2 can span banks 9, 10, 11)\nBank 10 (16,384 bytes):\nMore Layer 2 screen data\nFile size: 512 (header) + 512 (palette) + 49,152 (screen) + 49,152 (3 banks) = 99,328 bytes ≈ 97KB","loading-procedure-how-your-code-is-started#Loading Procedure: How Your Code is Started":"Understanding how the NEX loader operates helps you write better programs and debug loading issues. Here's the complete loading sequence.","initial-setup#Initial Setup":"When the NEX loader starts, memory is configured as follows: the first 8K ($0000–$1FFF) holds the ESXDOS ROM, and the second 8K slot ($2000–$3FFF) is RAM containing the loader itself — completely isolated from the $4000–$FFFF address space. The loader immediately saves the current Stack Pointer and moves the stack to the top of that second slot ($3FFF).Before opening the NEX file, the loader disables interrupts and sets the CPU speed to 14MHz. Once the file is open, the loader saves the file handle for later use (see Offset 140) and initializes the screen:\nSets ULA transparency\nDisables Layer 2\nEnables sprites (not over border; sprites above Layer 2, Layer 2 above ULA)\nThe loader then maps the upper three 16K memory slots:\nSlot\tAddress range\tBank\t1\t$4000–$7FFF\tBank 5\t2\t$8000–$BFFF\tBank 2\t3\t$C000–$FFFF\tBank 0","reading-the-header#Reading the Header":"The loader reads the 512-byte NEX header into Bank 0 at $C000 and performs these checks in order:\nLoader version: If the NEX file requires a newer loader version, loading aborts with an error.\nExpansion bus (Offset 142): If requested, the loader disables the expansion bus by clearing the top four bits of NextReg $80.\nCore version (Offsets 135–137): On real hardware, if the current FPGA core is older than the required version, loading aborts with an upgrade prompt. In an emulator, this check is skipped.\nThe loader then blacks out the screen — black border, all ULA attributes set to PAPER 0 / INK 0.","resetting-next-registers-offset-134#Resetting Next Registers (Offset 134)":"If Offset 134 is 0, the loader resets the Next hardware to a clean state:\nStops the Copper\nDisables DivMMC NMI (DRIVE button), enables Multiface NMI (M1 button)\nUnlocks port $7FFD\nDisables RAM and port contention\nSets AY stereo mode to ABC\nEnables Spectdrum (four 8-bit DACs) and TurboSound\nEnables the Timex port ($FF)\nSets CPU speed to 28MHz\nSets Layer 2 page to Bank 16, shadow page to Bank 12\nSets global transparency color to $E3\nEnables sprites (not over border; sprites above Layer 2 above ULA)\nResets Layer 2 and LoRes scroll positions to zero\nResets all clip windows to defaults (no clipping)\nEnables flashing\nInitializes primary ULA, Layer 2, and sprite palettes\nSets the fallback color (all layers transparent) to 0\nPages the ROM back into $0000–$3FFF\nThe following Peripheral Settings 2 flags are preserved regardless:\nF8 CPU speed hotkey and F5/F6 expansion bus hotkeys\nBEEP routed to internal speaker only\nF3 50/60Hz hotkey\nAfter waiting for the next screen frame to begin, the loader restores the AY stereo mode that was active before the reset.","loading-the-palette-and-screen#Loading the Palette and Screen":"The loader reads Offset 10 to determine whether a palette and loading screen are present.Palette: The 512-byte palette block is skipped if bit 7 of Offset 10 is set, or if the screen type is ULA, HiRes, or HiColor (these modes don't use a NEX palette). Otherwise, the loader reads the palette and programs the appropriate hardware palette:\nLoRes: Enables ULANext and uploads to the primary ULA palette\nLayer 2: Uploads to the Layer 2 primary palette\nLoading screen: Each screen type is loaded as follows:\nScreen type\tSize\tDestination\tNotes\tLayer 2\t48KB\tBanks 9, 10, 11\tEnables Layer 2; resets Timex port\tULA\t6,912 bytes\t$4000 (Bank 5)\tDisables Layer 2; resets Timex port\tLoRes\t2 × 6,144 B\t$4000 and $6000\tDisables Layer 2; enables LoRes mode\tHiRes\t2 × 6,144 B\t$4000 and $6000\tDisables Layer 2; enables HiRes mode\tHiColor\t2 × 6,144 B\t$4000 and $6000\tDisables Layer 2; enables HiColor mode\t\nAll screen types set sprite priority to: sprites above Layer 2, Layer 2 above ULA.The border color (Offset 11) is applied only if a loading screen is present.After all screens are loaded, Bank 0 is paged back into Slot 3 ($C000–$FFFF).","loading-memory-banks#Loading Memory Banks":"Banks are loaded in this fixed order: 5, 2, 0, 1, 3, 4, 6, 7, then 8 through 111 sequentially. For each bank, the loader checks the corresponding flag byte in the header (Offsets 18–129). If the flag is set, the loader maps that bank to Slot 3 via MMU 6 and MMU 7 and reads 16KB of data from the file into $C000–$FFFF.After each bank loads, the loader updates the loading progress indicator. If a loading screen is present, it also waits the number of frames specified in Offset 132 before proceeding.","starting-execution#Starting Execution":"Once all banks are loaded:\nFile handle (Offset 140): If the value is zero, the NEX file is closed. Otherwise, it remains open for the program to use.\nEntry bank (Offset 139): The specified bank is paged into Slot 3 ($C000–$FFFF) via MMU 6 and MMU 7.\nFile handle delivery: If Offset 140 is in the range $0001–$3FFF, the file handle is placed in register BC. If it is in the range $4000–$FFFF, the file handle is written to that memory address.\nStack pointer: SP is set to the value at Offset 12.\nProgram counter (Offset 14):\nZero: The NEX file is closed, SP and Slot 3 are restored to their original values, and control returns to the NextBASIC prompt.\nNon-zero: The loader jumps to that address with ZX Spectrum Next ROM3 paged in, starting your program.","creating-nex-files-with-klive-assembler#Creating NEX Files with Klive Assembler":"You don't manually construct NEX files byte-by-byte (though you could). Klive IDE includes a Z80 assembler with built-in NEX file generation - it's the tool we'll use throughout this book.Klive's assembler makes NEX creation straightforward using the .model next directive and .savenex pragma. Here's a complete example:\n.model next\n.savenex file \"game.nex\"\n.savenex core 3, 1, 10       ; Require core 3.1.10\n.savenex border 5            ; Cyan border\n; Your code starts at $8000 automatically (unbanked code maps to bank 2)\nmain\n    ld a, 2\n    out (0xFE), a            ; Set border color\n    call game_loop\n    \ntrap\n    jr trap\ngame_loop\n    ; Game logic here\n    ret\nWhen you use .model next, Klive automatically sets sensible defaults:\nRAM requirement: 768KB\nBorder color: 7 (white, unless you override it)\nEntry address: $8000\nBank mapping: Unbanked code goes to bank 2\nThe .savenex pragma accepts multiple subcommands to configure every aspect of the NEX file:Basic Configuration:\n.savenex file \"myapp.nex\"        ; Output filename\n.savenex ram 768                 ; 768KB or 1792KB\n.savenex border 4                ; Green border (0-7)\n.savenex stackaddr 0xFFFE        ; Stack pointer\n.savenex entryaddr 0x8000        ; Entry point\n.savenex entrybank 2             ; Bank at 0xC000 on startup\nLoading Screen:\n.savenex screen \"layer2\", \"loading.scr\"\n.savenex palette \"colors.nxp\"\n.savenex bar \"on\", 2, 50, 100    ; Enable loading bar: color 2, delay 50, start delay 100\nAdvanced Features:\n.savenex copper \"effects.cu\"     ; Copper code for loading effects\n.savenex filehandle \"open\"       ; Keep file open, pass handle in BC\n.savenex preserve \"on\"           ; Preserve Next registers\nMulti-Bank Applications:For complex programs using multiple memory banks, combine unbanked code with explicit .bank sections:\n.model next\n.savenex file \"multibank.nex\"\n.savenex core \"3.1.0\"\n; Unbanked code in bank 2 at $8000\nmain\n    ; Page in bank $20 to $A000-$BFFF\n    nextreg $55, $40\n    call DrawScreen\n    jr main\n; Explicit bank $20 code\n.bank $20\n.org $0000\n.disp $a000\nDrawScreen\n    ; Drawing code here\n    ret\nThe assembler tracks which banks your code uses and automatically includes them in the NEX file. Unbanked code (without .bank pragma) goes to bank 2 starting at $8000. Code with explicit .bank directives goes to the specified bank at the addresses you define.","version-differences-v10-v11-v12#Version Differences: V1.0, V1.1, V1.2":"The NEX format has evolved through three versions:V1.0 (original):\nBasic header structure\nStandard loading screens (Layer 2, ULA, LoRes)\nBank loading with fixed order\nV1.1 (added):\nTimex HiRes and HiCol screen support\nCopper code block for loading effects\nExtended core version checking\nFile handle preservation for streaming assets\nV1.2 (current, added):\nLayer 2 extended modes (320×256×8, 640×256×4)\nPalette offset for Layer 2 (header offset 138 reused)\nEnhanced loading bar options\nEntry bank specification for cleaner initialization"}},"/book/introduction":{"title":"Introduction","data":{"":"Building an emulator sounds straightforward until you actually try it. You're not just writing code that pretends to be a computer—you're recreating an entire machine's personality, quirks included. The ZX Spectrum Next makes this challenge even more interesting because it's not just one machine, it's a layer cake of computers: the original 1982 Spectrum, the enhanced 128K models, and a pile of modern features that would have seemed like magic in the 80s.This book walks through building a complete Spectrum Next emulator from scratch. Not a toy that runs a few demos, but a real emulator that handles all the weird hardware interactions, timing quirks, and edge cases that real software depends on. Along the way, you'll learn how computers work at the silicon level—not because it's nostalgic, but because understanding one system deeply teaches you how all systems work.We'll start with the \"why\"—what makes the Next special enough to deserve this effort? Then we'll dive into the hardware architecture, the emulation challenges, and the implementation details. By the end, you'll have built something that runs thousands of existing programs and understand exactly why everything works the way it does.","why-revive-a-40-year-old-computer#Why Revive a 40-Year-Old Computer?":"Here's a question that might seem absurd in 2020: why would anyone build a brand new version of a computer from 1982? The ZX Spectrum was already ancient when the iPhone launched. By the time the Next appeared, the original Spectrum was older than most of its new users' parents.The answer isn't nostalgia alone—though there's plenty of that. It's about preserving a programming culture that's been lost. The ZX Spectrum generation grew up with machines you could understand completely. Open the manual, and by page 50 you'd know exactly how the hardware worked. Write a program, poke a few memory addresses, and you could control every pixel on screen. Modern computers are powerful, but they're black boxes wrapped in abstractions wrapped in more abstractions. You can't \"understand\" an iPhone—you can only use the APIs someone else built.The Spectrum represented something different: accessible low-level computing. Kids learned to program because the barrier between \"user\" and \"programmer\" was paper-thin. The Next project asked: what if we took that philosophy and gave it modern hardware? Not just emulation running in a window, but real silicon you can hold, real signals you can measure with a scope, real hardware you can expand with your own circuits. A machine that's simultaneously authentic 1982 Spectrum and powerful 2020s computer.There's something irreplaceable about physical interaction with real hardware. When you press a key on the Next, an actual electrical signal travels through the FPGA to the keyboard controller. When you run a program, real silicon executes real Z80 code. This tactile feedback—the click of keys, the physical weight of the machine on your desk—connects you to the computer in a way that clicking on a window can't replicate. It's the difference between reading about gravity and actually feeling yourself fall. Emulators are wonderful tools for preservation and education, but the Next offers something more: embodied computing. You can feel the machine working.","the-vision-backward-compatible-forward-thinking#The Vision: Backward Compatible, Forward Thinking":"Victor Trucco and the core team (later joined by many community contributors) started the Next project with a deceptively simple goal: make the perfect Spectrum. Not replace it, not reimagine it—perfect it. That meant two seemingly contradictory requirements:Run all existing Spectrum software without modification. Thousands of programs exist—games, utilities, demos, educational software. These define what \"Spectrum\" means. Break compatibility and you're building something else entirely, just using the same name.Add modern features without breaking the classic experience. More memory, better graphics, faster CPU, SD card storage, HDMI video output. But these enhancements had to be optional—you could toggle them off and get a pure 48K Spectrum experience, or turn them on and get capabilities that would have seemed like science fiction in 1982.The tension between these requirements shaped every design decision. How do you add 2MB of RAM to a machine designed for 48KB? How do you change the graphics without breaking programs that assume ULA timing? How do you modernize storage without losing tape compatibility? The answer: layers of backward compatibility built into hardware that knows when to behave like a 1982 machine and when to show off its 2020s capabilities.","the-kickstarter-journey-from-dream-to-reality#The Kickstarter Journey: From Dream to Reality":"The ZX Spectrum Next didn't appear overnight—it emerged from years of FPGA development work and community passion. Victor Trucco (hardware designer and FPGA developer from Brazil) and Fabio Belavenuto (computer scientist and MSX hardware expert, also from Brazil) created the TBBlue—the original FPGA bitstream that became the foundation for the Next. Jim Bagley (legendary Spectrum game developer who created classics like Cabal and Midnight Resistance) joined to drive development requirements and implement new video modes. Rick Dickinson (1957-2018), the original Sinclair industrial designer behind the ZX80, ZX81, and ZX Spectrum, came aboard to design the case. Henrique Olifiers (former Bossa Studios co-founder) coordinated the project's business and marketing.The first Kickstarter campaign launched April 23, 2017, asking for £250,000 to fund production. The response was overwhelming: £723,390 pledged by 3,113 backers—nearly 290% of the goal. Funded in under 24 hours, the community sent a clear message: they desperately wanted this machine. The campaign offered everything from bare PCB boards for DIY builders to fully assembled machines with injection-molded cases recreating the classic Spectrum aesthetic.But hardware manufacturing taught brutal lessons. Supply chain issues, component revisions, case tooling problems, and the complexities of running a hardware startup from scratch meant delivery took longer than planned. The team grew with Allen Albright taking over firmware development, Garry Lancaster creating NextZXOS and NextBASIC, Phil Candy (Rick's design partner) ensuring quality, and dozens more contributors. The team remained transparent throughout, posting regular updates about challenges and solutions. By 2018-2019, thousands of Issue 2 boards were shipping worldwide.A second Kickstarter launched August 11, 2020 for an improved Issue 2 revision, incorporating lessons learned and component improvements. £1,847,106 pledged by 5,236 backers—funded in under 5 minutes. COVID-19 hit during fulfillment, creating unprecedented supply chain disruptions. The team persisted through Brexit complications, component shortages, and global logistics chaos. By 2020-2021, thousands more Next machines reached backers worldwide.The third campaign launched July 19, 2025 for the Issue 3 board featuring a larger FPGA (Artix A7) enabling new cores: Sinclair QL and Commodore 64 emulation alongside the Spectrum. £2,612,335 pledged by 7,524 backers—over 1000% of the £250,000 goal, funded in 7 minutes. After delivering over 10,000 units across the first two campaigns, the community had proven the Next wasn't just nostalgia—it was a living, evolving platform.Throughout this journey, the project remained community-driven at its core. The FPGA core development happens in public GitLab repositories. Hundreds of developers contribute software, tools, games, and documentation. The official forums buzz with hardware mods, programming techniques, and mutual support. This isn't a product dropped on the market—it's a platform built with its community, not just for them.","why-fpga-the-hardware-philosophy#Why FPGA? The Hardware Philosophy":"Here's where the Next makes its critical architectural choice: it's not emulation. The Next uses an FPGA (Field-Programmable Gate Array) to recreate the original Spectrum hardware at the silicon level. This deserves explanation because it's easy to confuse FPGAs with software emulation.Software Emulation: The Translation ApproachWhen you run a Spectrum emulator on your PC, the software reads the Z80 machine code and translates it: \"Oh, this instruction means load this value into this register.\" Every instruction gets interpreted by another program. It's like reading a French novel through a translator—you get the story, but you're not reading the original words.Software emulation has advantages: it's flexible, easy to debug, runs on any computer. But it has problems too. Timing is approximate at best. Hardware quirks get simplified. External hardware can't connect because there are no real ports. You're simulating the Spectrum, not building one.FPGA: Hardware RecreationAn FPGA is a chip full of programmable logic gates—think of it as reconfigurable silicon. You describe a hardware design in VHDL or Verilog (hardware description languages), and the FPGA rewires itself to become that hardware. The Next's FPGA literally becomes a Z80 CPU, ULA video chip, AY sound chip, and all the glue logic. It's not pretending—at the electrical signal level, it is these components.Why does this matter? Three critical reasons:1. Perfect Timing AccuracyThe original Spectrum relied on precise timing relationships. The ULA steals memory cycles from the CPU at exact moments. Sound generation depends on specific clock relationships. Many programs and especially demos exploit these timings creatively (or accidentally). An FPGA running at the correct clock frequency gets these relationships exactly right—because it's the same circuit relationships as the original, just implemented in different silicon.2. Real Hardware CompatibilityThe Next has physical ports—GPIO, expansion bus, joysticks. External hardware can connect because real electrical signals exist. You can add external peripherals that the original Spectrum never had, but using the same electrical interface philosophy. Try that with software emulation—where do you even plug in the cable?3. Authentic Development ExperienceWhen you write software for the Next, you're writing for real hardware. The constraints are real. The optimizations that matter on real hardware still matter here. It's not a simulation teaching you simulation-optimized techniques—it's authentic low-level computing with all the beautiful constraints that make programming interesting.NextRegs: The Gateway to Modern HardwareThe FPGA doesn't just recreate the original Spectrum circuits—it exposes a large bank of new hardware registers that control all the modern features: graphics modes, palettes, layer priorities, sprite configuration, DMA, interrupt sources, CPU speed selection, and much more. These are called NextRegs (Next Registers), and they are the primary interface between your Z80 code and everything the Next adds beyond the original hardware.Think of NextRegs as the control panel for the FPGA's extended logic. Registers run from 0x00 to 0xFF, covering everything from video layer control to audio routing to memory paging. Throughout this book you'll see references like \"NextReg 0x15 bit 7\"—that means bit 7 of register number 0x15. Where you once poked a handful of ULA ports to control the original Spectrum, on the Next you have a rich register file giving you precise, direct control over a completely programmable hardware platform.","the-modern-enhancements-what-makes-it-next#The Modern Enhancements: What Makes It \"Next\"":"The genius of the Next is in what it adds without breaking the past. Let's look at the key enhancements:","the-memory-expansion-2mb-that-knows-how-to-hide#The Memory Expansion: 2MB That Knows How to Hide":"Original Spectrum: 48KB (16KB ROM + 48KB RAM). The 128K models added bank switching to reach 128KB total. The Next? 2MB—that's over 40 times the original 48K model.But here's the trick: the Z80 still has only 16 address lines. It can only \"see\" 64KB at once. The Next solves this with a flexible MMU (Memory Management Unit) that divides the Z80's address space into eight 8KB slots, each of which can point to any 8KB page in that 2MB. Want to run a 48K program? Set the MMU to mimic the original memory map. Want to use all 2MB? Page it in 8KB at a time through those slots.The MMU is sophisticated enough to stay invisible when running legacy software. Set a mode register, and suddenly it thinks it's a 128K machine with the original 0x7FFD port behavior. The software has no idea it's running on hardware with 40x more memory available.","graphics-from-8-colors-to-256-without-losing-the-stripes#Graphics: From 8 Colors to 256, Without Losing the Stripes":"The original Spectrum ULA is infamous for color clash—you could only have two colors per 8×8 pixel block. This limitation defined the Spectrum's visual aesthetic (and frustrated generations of game developers). The Next adds three new graphics modes that eliminate color clash while keeping the ULA fully functional:Layer 2 provides 256×192 resolution with 256 colors per pixel. That's not a typo—the machine that originally had 8 colors total now gives you 256 colors per pixel. For programs that need even more space, Layer 2 also offers two high-resolution modes: 320×256 with 256 colors and 640×256 with 16 colors. All modes can display photographic-quality images that would have been impossible on the original hardware. Layer 2 uses external SRAM (requiring 48KB for standard resolution and 80KB for the high-resolution modes), while the original ULA screen memory stays in the fast BRAM where it belongs. This means the ULA keeps chugging along underneath, unaware of the high-color layer composited on top, and you can even scroll Layer 2 graphics while the ULA displays text or graphics at the same time.Tilemap mode provides a grid-based background system where you define a map of tile references, and the hardware automatically looks up pattern data and renders them. It's like painting with a palette of 256 pre-drawn tiles—the CPU just specifies which tile goes where. The tilemap layer has its own memory, its own palette, and the hardware handles all rendering automatically. Two layout sizes are supported: 40×32 tiles (the default, matching the ULA character grid) and 80×32 tiles for denser maps. Games can scroll smoothly without the CPU copying screen data around—change a scroll register and the entire background shifts in hardware.Sprites are a completely independent graphics system—movable objects that can float above or below any of the other layers. The Next provides 128 hardware sprites, each with its own position registers, its own palette, and independent movement control. Sprites don't belong to the tilemap system or any other layer—they're a separate compositing element. Unlike the original Spectrum where objects disappeared at the screen edge, Next sprites can be displayed over the border area as well, giving the full visible display to your game world. This independence is what makes them so powerful: you can have sprites moving over a tilemap background, over Layer 2 graphics, or over ULA screens, all controlled separately.LoRes mode is an alternate rendering mode for the ULA—when enabled (NextReg 0x15 bit 7), it replaces standard ULA output. LoRes reduces resolution to 128×96 to gain more color attributes per block: 2 colors per 4×8 block instead of ULA's 2 colors per 8×8 block. It uses the same memory space as ULA, so you can't have both simultaneously—it's either ULA or LoRes.The Next's video compositor combines these systems using a three-layer priority order: Sprites, Layer 2, and ULA (which represents standard ULA, LoRes mode, or ULA/LoRes with Tilemap composited). The Z80 just writes to video memory—the FPGA handles the complex compositing at 28 MHz.","the-speed-upgrade-from-35-mhz-to-28-mhz#The Speed Upgrade: From 3.5 MHz to 28 MHz":"The original Spectrum ran at 3.5 MHz—fast for 1982, leisurely by modern standards. The Next offers selectable CPU speeds: 3.5 MHz, 7 MHz, 14 MHz, and 28 MHz. That top speed is 8 times faster than the original.Why multiple speeds instead of just \"fast\"? Compatibility. Some programs rely on specific timing—they delay by executing pointless loops, assuming each instruction takes a certain number of microseconds. Run these at 28 MHz and they break spectacularly (or finish so fast you can't see what happened). The Next lets you switch speeds per program, or even mid-program if you need precise timing for one section and maximum speed for another.There's a subtle implementation detail here: the memory wait states adjust automatically based on CPU speed. At 28 MHz, the external SRAM can't respond instantly, so the hardware inserts wait states. At 3.5 MHz, memory is fast enough that no waits are needed. The Z80 never knows this is happening—it just experiences slightly longer memory cycles at high speed, keeping everything synchronized.","copper-the-raster-effect-co-processor#Copper: The Raster Effect Co-Processor":"Borrowed conceptually from the Amiga, the Copper is a simple co-processor that executes a list of instructions synchronized to the video raster beam. You load up to 2KB of Copper instructions (NextReg 0x60-0x63), then start execution (NextReg 0x62). The Copper waits for specific raster positions and writes to NextReg registers when those positions are reached.Why is this useful? Raster effects without CPU involvement. Want to change the border color every scanline? Split the screen into multiple graphics modes? Display more sprites than hardware limits by reusing sprite registers mid-frame? The Copper handles it automatically while the Z80 continues running game logic. Each Copper instruction is just two bytes: either WAIT (pause until raster reaches position X,Y) or MOVE (write value to NextReg). The hardware executes these in a loop, frame after frame, with perfect timing.The Copper can access NextReg registers 0x00-0x7F (not 0x80+), giving it control over palettes, layer priorities, scrolling, sprites, video modes—essentially everything visible. This makes it perfect for loading screens with animated effects (rainbow bars, color cycling) or in-game effects like parallax scrolling layers or HUD overlays that don't consume any CPU time.","dma-bulk-data-transfers-without-cpu-cycles#DMA: Bulk Data Transfers Without CPU Cycles":"The Next includes a DMA (Direct Memory Access) controller accessible through ports 0x0B (Z80 DMA mode) and 0x6B (ZXN DMA mode). This implements a subset of the Zilog Z80 DMA architecture plus Next-specific burst mode optimized for digital audio playback.What does DMA do? It copies memory blocks without tying up the CPU. Need to copy 16KB of graphics data to video memory? Set up the DMA with source address, destination address, and byte count, then trigger it. The DMA handles the transfer in hardware—no loop, no CPU registers involved. The Z80 continues executing code while memory copies happen in parallel (though the DMA and CPU take turns accessing memory to avoid conflicts).The burst mode is particularly clever: it can continuously read from a memory buffer and write to an I/O port (like the DAC audio outputs), effectively streaming audio samples without CPU intervention. Set up a circular buffer of audio data, point the DMA at it, and music plays while your game runs at full speed. This is how tracker modules and digitized audio work on the Next—the DMA feeds samples to the DAC hardware automatically.","programmable-interrupt-system#Programmable Interrupt System":"The original Spectrum had one interrupt: the ULA signaled 50 times per second (or 60 Hz in NTSC mode) at vertical blank. You could use IM2 mode on the original hardware, but you'd still get just that one interrupt source—the ULA—and you had to provide your own interrupt vector table in RAM. The Next extends this dramatically with hardware IM2 mode (NextReg 0xC0) providing a priority-based interrupt system with 10 distinct interrupt sources and automatic vector generation:\nLine interrupts (NextReg 0x22-0x23): Trigger at any specific scanline, not just vertical blank. Want to change the screen mode halfway down the display? Set a line interrupt for scanline 128, handle it in your interrupt routine. This enables split-screen effects that were impossible on the original hardware.\nUART interrupts: Serial communication (Rx and Tx for two UART channels) can trigger interrupts, making it practical to handle keyboard/mouse data from the Raspberry Pi connector or implement networked gaming over serial.\nCTC channels: Four Counter/Timer/Controller channels (ports 0x183B-0x1B3B) provide programmable timers that can trigger interrupts at specific intervals. Need something to happen every millisecond? Program a CTC channel and let hardware handle the timing.\nThe hardware IM2 mode automatically generates interrupt vectors based on priority (line interrupt highest, UART Tx lowest), eliminating the need for software interrupt scanning. The system also supports stackless NMI (NextReg 0xC0 bit 3), which saves the return address to a NextReg instead of the stack—useful for debugging tools that need to inspect the stack without modifying it.This interrupt flexibility means the Next can respond to real-time events (audio sample timing, communication protocols, split-screen rendering) with hardware precision instead of polling loops that waste CPU cycles.","storage-from-tape-to-sd-card#Storage: From Tape to SD Card":"Original Spectrum storage: cassette tape. Loading a game took 3-5 minutes of distinctive warbling sounds—the data being read from tape. Those sounds were meaningful: they told you the program was loading, and when they stopped unexpectedly, you knew something went wrong. The Next has an SD card slot with a complete filesystem operating system (ESXDOS). Insert an SD card, browse folders, load files instantly. Modern convenience meets vintage hardware.But the Next doesn't abandon tape compatibility. You can still load from tape (or tape audio files) if you want that authentic experience. The hardware includes a tape input that works exactly like the original. Many users keep tape loading for nostalgia, using SD cards for everything else.The clever part is DivMMC (covered in detail in the memory management chapter)—a hardware paging system that makes the disk operating system appear and disappear automatically. Call a DOS function? DivMMC pages its ROM into memory, handles the SD card access, then unpages itself. From the program's perspective, it just called a routine and got data back. The complexity is hidden beautifully.","sound-from-beeper-to-9-channel-turbosound#Sound: From Beeper to 9-Channel TurboSound":"The original Spectrum had a beeper—one bit of output that could be on or off. Clever programmers made amazing music by toggling that bit precisely, but it tied up the CPU completely during playback.The 128K models added the AY-3-8912 sound chip—a 3-channel programmable sound generator (PSG). The Next not only includes a register-compatible FPGA recreation of this chip, it provides three AY chips—that's 9 channels of PSG audio in what's known as TurboSound configuration (NextReg 0x08 bit 1). Programs can switch between AY 0, AY 1, and AY 2 using port 0xFFFD bits 7-6, with all three chips mixing their output in stereo (or mono if configured).But the real flexibility comes from the four 8-bit DACs (Digital-to-Analog Converters) labeled A, B, C, and D. DACs A and B feed the left audio channel, C and D feed the right. These DACs connect to various I/O ports (0xDF for Specdrum, 0xFB for Pentagon/ATM, 0xB3 for Covox, and others) providing hardware-level compatibility with numerous Spectrum audio peripherals. The Next can play 8-bit PCM samples, synthesized waveforms, or digitized music while the Z80 continues executing code—no CPU-hogging bit manipulation required.All audio sources—beeper, three AY chips, and four DACs—mix together in hardware and output via analog audio jacks, HDMI, or I²S digital interface. The audio subsystem is sophisticated enough for serious music applications (tracker modules, sample playback, real-time synthesis) yet simple enough that games can casually play sound effects without worrying about the mixing details.","video-output-rgb-vga-hdmi#Video Output: RGB, VGA, HDMI":"Original Spectrum video output: RF modulator (analog TV signal) or RGB if you were lucky. CRT TVs only. The Next provides:\nVGA output (15 kHz RGB, perfect for retro monitors)\nHDMI output (for modern displays)\nScandoubler (converts 15 kHz to 31 kHz for VGA monitors)\nThe FPGA generates video signals directly—no emulation layer converting framebuffers. When you write to screen memory, you're literally controlling what signals appear on the video output pins. It's real-time, zero-latency video generation, just like the original ULA did, but with modern connectors.","expansion-the-future-is-modular#Expansion: The Future Is Modular":"The Next has an expansion bus that's electrically compatible with the original Spectrum edge connector. You can plug in original Spectrum hardware (interfaces, sound cards, etc.) and it works. But the Next also adds:\nRaspberry Pi Zero connector (for WiFi, Bluetooth, USB keyboard/mouse)\nGPIO pins (for custom hardware projects)\nAccelerometer (built into the board, for motion controls)\nThe expansion philosophy is \"make it possible, don't mandate it.\" You can build a completely standalone Next with no expansions, or turn it into a development platform with network connectivity, USB, and custom hardware. The choice is yours.","the-architecture-how-it-all-fits-together#The Architecture: How It All Fits Together":"Let's zoom out and see the system architecture:The FPGA (Xilinx Artix-7 or Spartan-6, depending on board revision) implements:\nT80 CPU core—cycle-accurate Z80 compatible CPU\nULA—original video and timing logic\nLayer 2, Tilemap, LoRes—new graphics subsystems\nSound systems—beeper, three AY chips (TurboSound), four 8-bit DACs\nMemory controller—handles MMU, DivMMC, Multiface, Layer 2 paging\nVideo compositor—combines all graphics layers in real-time\nI/O controllers—keyboard, joystick, SD card, etc.\nExternal to the FPGA:\n2MB SRAM—main memory (1x 2MB chip or 3x 512KB chips)\nSD card—mass storage\nAudio DAC—converts digital audio to analog\nVideo DAC—converts digital RGB to analog VGA\nHDMI transmitter—generates HDMI signals\nClock generators—27 MHz and 28 MHz system clocks\nThe FPGA is the brain—everything else is peripherals. This centralization means firmware updates can add new features (within FPGA resource limits) without hardware changes. The Next has received multiple firmware updates adding features and fixing issues, something impossible with original discrete logic designs.","the-development-story-kickstarter-to-production#The Development Story: Kickstarter to Production":"The Next started as a Kickstarter project in 2017. Victor Trucco, Jim Bagley, and others had been working on FPGA Spectrum recreations for years. The Kickstarter asked: what if we made this perfect, not just functional? The community responded with over £600,000 pledged—enough to fund production of custom PCBs, injection-molded cases, and professional manufacturing.The journey from Kickstarter to production taught harsh lessons about hardware manufacturing. Multiple board revisions fixed design issues. Supply chain problems delayed production. COVID-19 disrupted everything. But the team persisted, and by 2020-2021, Next machines were shipping to backers.What started as a hobbyist project became a community-driven hardware platform. Hundreds of developers contribute software. Dozens design hardware expansions. The Next has an active scene creating new games, demos, and tools—not just preserving the old Spectrum, but extending it.","why-it-matters-preserving-computing-culture#Why It Matters: Preserving Computing Culture":"The Next represents something bigger than one retro computer. It's a statement about computing philosophy: machines should be understandable. You can read the VHDL source code and see exactly how the hardware works. You can write assembly that directly controls hardware. You can build expansions that plug into real buses.Modern computing has lost this. We trade power and convenience for opacity. Most developers couldn't explain how their computer boots, how the GPU renders pixels, or how memory management works at the silicon level. These details are abstracted away, hidden behind APIs, sealed in black boxes.The Next proves you can have both: modern power and complete understanding. It's not a museum piece—it's a working development platform that teaches low-level computing through hands-on experience. Emulators are great for playing old games, but they don't teach you how hardware actually works. The Next does.","the-legacy-what-comes-next#The Legacy: What Comes Next?":"The ZX Spectrum Next succeeded in its goal: it's both an authentic Spectrum and a powerful modern machine. It runs 40-year-old software flawlessly while enabling creations impossible on original hardware. It preserves computing history while pushing retro computing forward.But perhaps more importantly, it inspired a movement. Other platforms saw the Next's success and followed: Mega65 (Commodore 65 revival), X16 (inspired by C64), Agon (modern Z80 computer). The retro computing scene is thriving not just with emulation, but with real hardware, real development, real innovation.The Next proved there's demand for machines that are simultaneously old and new, simple and powerful, nostalgic and forward-thinking. It showed that \"retro computing\" doesn't mean \"computing museum\"—it means taking the best ideas from the past and giving them modern implementation.For those of us building emulators, understanding the Next's architecture teaches lessons about what made the original Spectrum special and how modern enhancements can respect that heritage. The Next isn't just a computer—it's a masterclass in backward-compatible hardware design.And in preserving the Spectrum's legacy, the Next ensures another generation can experience the joy of truly understanding the computer they're programming. That's the real next step: not just better hardware, but better programmers."}},"/book/preface":{"title":"Preface","data":{"":"Everyone has a personal story about their ZX Spectrum. Mine started before I even got my first Speccy. One day, my late father (I'm bearing his name, István Novák) brought back a TI-59 programmable calculator from his workspace. This wasn't just a calculator—it had keys with mysterious text that went far beyond simple arithmetic. As a kid with an affection for math, I learned programming from its user guide. My father saw my enthusiasm and asked my uncle, György Marczin (an electrical engineer), to help me improve.I live in Hungary. In 1981, when I was 13, Hungary was part of the communist bloc. My uncle, working for a large state-owned company, had the privilege of traveling to Western Europe. He saw the spark in me and helped me get a ZX81 from West Germany. Getting it wasn't simple—my father had to buy Deutschmarks at the Hungarian black markets, since the Forint wasn't convertible at the time.The 16K expansion pack for the ZX81 was great, but it became too small. Two years later, my father bought me a ZX Spectrum 48K. I went through the same awakening as countless others around the world who touched that rubber-keyed wonder.","school-days-and-programming-contests#School Days and Programming Contests":"We didn't know it at the time, but in about seven years we'd have a revolution—a relatively peaceful transition from communism to something else. But we already had a technical revolution happening.In my first year at gymnasium (Berze Nagy János Gymnasium), HT-1080Z school computers (TRS-80 clones) became available for Hungarian students. We had four of them in my school! With other awakened buddies, we formed a small group that spent time in the computer lab before and after teaching hours. Another young electrical engineer, about 15 years older than us (Tibor Veres), coached us. Soon we were participating in—and winning—programming contests across Hungary.After the gymnasium, I became a software engineer at the Technical University of Budapest and earned a doctoral title in software technology.","from-testing-to-emulation#From Testing to Emulation":"At the beginning of the 2010s, I found myself as a freelance technology coach, helping software development teams and evangelizing automated testing. I needed something to demonstrate unit and integration testing. About ten years ago, one January morning, I woke up with a dream: let me go back to my childhood and create a ZX Spectrum emulator. Creating a high-fidelity emulator requires extensive automated tests—it would serve as the perfect example for designing and writing tests.And so, my first emulator was born: SpectNetIDE (written in C#), integrated into Visual Studio. Years later, when I coached teams on Web technologies, I started implementing Klive IDE, a TypeScript implementation.","the-zx-spectrum-next-challenge#The ZX Spectrum Next Challenge":"I witnessed the ZX Spectrum revival with the ZX Spectrum Next. Though I missed the KS1 campaign, I have KS2 and (will have) KS3 machines. I felt a personal challenge to emulate this powerful successor in my Klive IDE.While working on the emulator, I learned a tremendous amount about this great machine from both the programmer's point of view and the emulator developer's perspective. The Next pushes boundaries—it's not just nostalgia, it's modern retro hardware done right.Let me share these learnings with the community.— István Novák"}},"/book/using-klive-ide":{"title":"1. Using Klive IDE with ZX Spectrum Next Development","data":{"":"Throughout this book, you'll build, run, and debug all the code examples using Klive IDE — an open-source emulator and development environment for ZX Spectrum machines, including the ZX Spectrum Next.","two-windows-one-workflow#Two Windows, One Workflow":"Klive runs as two separate windows: an Emulator window and an IDE window. The emulator is where your code actually runs — you see the ZX Spectrum Next screen, hear the audio, and interact with the machine. The IDE window is where you write code, manage projects, set breakpoints, inspect memory, and trigger builds.Having two independent windows is no accident. If you have a dual-monitor setup, put the emulator on one screen and the IDE on the other. You get to watch your code run while you write it — which turns out to be a pretty satisfying development experience.\nKlive saves window positions when you exit the app, so your dual-monitor layout is automatically restored on next launch.\nThe first time you start Klive, only the Emulator window opens. Use View | Show IDE to bring up the IDE window alongside it.","what-well-use-it-for#What We'll Use It For":"Every code example in this book lives in a Klive project — a folder with a klive.project file that tells the IDE which machine to target, which file to compile, and how to inject the built code into the emulator. You create a new project with File | New project, pick the ZX Spectrum Next as the machine type, choose a template, and the IDE sets everything up.From there, the typical loop is:\nWrite (or edit) your Z80 assembly source in the IDE editor\nPress F5 to build and inject the code into the running emulator\nWatch it run, set breakpoints if needed, and use Ctrl+F5 to step through it\nAll the machine control commands — start, pause, stop, step into, step over — are available from both windows, so you can drive the debug session from whichever screen you're looking at.","finding-your-way-around-the-documentation#Finding Your Way Around the Documentation":"The complete Klive IDE documentation lives at https://dotneteer.github.io/kliveide/. Here are the sections most relevant to getting up and running:\nInstalling Klive — install kits for Windows, macOS, and Linux\nRunning Klive for the first time — starting the emulator, opening the IDE window, controlling the machine\nCreating a Klive project — project structure, build roots, and project templates\nRunning and debugging code — the full toolbar and debug command reference\nYou don't need to read all of that before continuing — we'll introduce the relevant features as we need them. But if something in the IDE looks unfamiliar, those pages are a good first stop."}},"/book/z80-z80n-overview":{"title":"The Z80 and Z80N: Processor Overview","data":{"":"To build a ZX Spectrum Next emulator, you need to understand the processor at its heart. This chapter covers the Zilog Z80 architecture and the Z80N extensions specific to the Next - not as a complete tutorial, but as a focused overview of what matters for emulation. We'll look at registers, addressing modes, instruction categories, and the new Z80N opcodes that make the Next more than just a faster Spectrum.","the-z80-a-1976-design-that-refused-to-die#The Z80: A 1976 Design That Refused to Die":"The Zilog Z80 debuted in 1976 as an enhanced, binary-compatible version of Intel's 8080. While Intel moved on to the 8086 and beyond, the Z80 found a home in everything from arcade games to home computers to industrial controllers. By the time the ZX Spectrum shipped in 1982, the Z80 was already considered mature - yet here we are in the 2020s, still building machines around this architecture.Why? Because the Z80 hit a sweet spot: powerful enough to be useful, simple enough to understand completely. You can hold the entire instruction set in your head (well, most of it). The architecture makes sense. There are no hidden microcode layers, no speculative execution, no cache coherency protocols. What you see is what you get, and what you get is enough to build surprisingly sophisticated software.The Z80N in the ZX Spectrum Next is a cycle-accurate recreation implemented in FPGA, with carefully chosen extensions that add modern conveniences without breaking the fundamental character of the original design. It's still recognizably a Z80, just with some quality-of-life improvements that would have been impossible in 1976.","core-architecture-what-makes-a-z80-a-z80#Core Architecture: What Makes a Z80 a Z80":"Before diving into instructions, you need to understand what you're working with: the Z80's internal architecture. Registers, flags, and addressing modes form the foundation everything else builds on.","the-register-set-more-than-it-looks#The Register Set: More Than It Looks":"The Z80 has an unusual register architecture: it appears to have only seven 8-bit registers (A, B, C, D, E, H, L) plus the accumulator... but these are actually two complete sets that you can swap with a single instruction (EX AF,AF' or EXX). This gives you:Main register set:\nA (accumulator): Primary register for arithmetic, logic, and I/O\nF (flags): Status bits (zero, carry, sign, etc.) - not directly accessible\nBC, DE, HL: Three 16-bit register pairs (can be used as 8-bit or 16-bit)\nHL is special - most operations treat it as \"the\" pointer register\nAlternate register set:\nA', F': Alternate accumulator and flags\nBC', DE', HL': Alternate versions of the register pairs\nWhy the duplicates? Fast context switching. Writing interrupt handlers? Swap to the alternate set with EX AF,AF' and EXX, do your work, swap back. No pushing/popping dozens of bytes on the stack. It's beautifully efficient when you need it, but many programs never touch the alternate set.Special purpose registers:\nIX, IY: 16-bit index registers for displacement addressing\nSP: Stack pointer (grows downward from high memory)\nPC: Program counter (where execution currently is)\nI: Interrupt vector register (high byte for IM2 mode)\nR: Memory refresh counter (increments each instruction, used for DRAM refresh)","the-flags-how-the-cpu-remembers-what-just-happened#The Flags: How the CPU Remembers What Just Happened":"The F register contains status flags that reflect the result of the last operation:\nZ (Zero): Set if result was zero\nC (Carry): Set if arithmetic generated a carry or borrow\nS (Sign): Reflects bit 7 of result (negative if set, treating values as signed)\nP/V (Parity/Overflow): Means parity for logical ops, overflow for arithmetic\nN (Add/Subtract): Set if last operation was a subtraction (used by DAA)\nH (Half-carry): Carry from bit 3 to bit 4 (also used by DAA for BCD math)\nBCD (Binary Coded Decimal): A numbering system where each byte represents two decimal digits (0-99), with 0x00-0x09 valid in each nibble. The DAA instruction converts after addition/subtraction to maintain BCD format. Used in calculators and financial software where decimal precision matters more than speed.\nConditional jumps and calls test these flags: JP Z,label, CALL NC,subroutine, etc. The flags update automatically after most arithmetic and logical operations, but not after loads or bit operations.","memory-addressing-16-bits-of-reach#Memory Addressing: 16 Bits of Reach":"The Z80 has a 16-bit address bus, giving it a 64KB address space (0x0000 to 0xFFFF). That's it - no banking, no segments, no MMU from the CPU's perspective. When later systems needed more memory (like the Spectrum 128K or Next's 2MB), they added external hardware to page different memory banks into the Z80's view.Addressing modes determine how the CPU interprets operands:Immediate: Value is part of the instruction\nLD A,42        ; Load literal 42 into A\nRegister direct: Value comes from a register\nLD A,B         ; Copy B into A\nRegister indirect: Register contains an address to read from\nLD A,(HL)      ; Load from memory address in HL\nIndexed with displacement: Base address + signed offset\nLD A,(IX+5)    ; Load from address in IX plus 5\nExtended (absolute): 16-bit address in the instruction\nLD A,(0x4000)  ; Load from address 0x4000\nThe choice of addressing mode affects both speed (immediate is fast, indexed is slow) and code size (direct is compact, extended needs 2 extra bytes).","instruction-categories-what-can-this-thing-do#Instruction Categories: What Can This Thing Do?":"The Z80 instruction set divides roughly into categories by function. Understanding these categories helps you pick the right tool for each job - and spot when you're using an expensive instruction where a cheap one would work.","data-movement-getting-bytes-where-they-need-to-be#Data Movement: Getting Bytes Where They Need to Be":"The Z80 has a powerful LD (load) instruction with dozens of variants:\nLD A,42         ; Immediate to register (7 cycles)\nLD A,B          ; Register to register (4 cycles)\nLD A,(HL)       ; Memory to register (7 cycles)\nLD (HL),A       ; Register to memory (7 cycles)\nLD HL,0x4000    ; 16-bit immediate to register pair (10 cycles)\nLD A,(0x5C00)   ; Memory to A using absolute address (13 cycles)\nThere's also LDI and LDIR for block moves - LDIR copies BC bytes from HL to DE automatically. One instruction, hundreds of bytes moved. Perfect for copying graphics data or clearing memory.","arithmetic-and-logic-making-numbers-dance#Arithmetic and Logic: Making Numbers Dance":"The Z80 provides comprehensive arithmetic and logical operations, with separate instruction sets for 8-bit and 16-bit values. Most operations automatically update flags, making conditional execution straightforward.8-bit arithmetic:\nADD A,B         ; A = A + B (sets flags)\nADC A,C         ; A = A + C + carry flag (for multi-byte math)\nSUB D           ; A = A - D\nSBC A,E         ; A = A - E - carry flag\nINC A           ; A = A + 1 (doesn't affect carry!)\nDEC B           ; B = B - 1\n16-bit arithmetic:\nADD HL,BC       ; HL = HL + BC (16-bit addition)\nADC HL,DE       ; HL = HL + DE + carry (for 32-bit math)\nSBC HL,BC       ; HL = HL - BC - carry\nINC HL          ; HL = HL + 1 (doesn't affect flags)\nLogical operations:\nAND B           ; A = A & B (bitwise AND)\nOR C            ; A = A | C (bitwise OR)\nXOR D           ; A = A ^ D (bitwise XOR)\nCP E            ; Compare A with E (A - E, update flags, discard result)\nThe CP instruction is clever - it performs subtraction just to set flags, then throws away the result. Perfect for testing values without destroying them.","bit-operations-twiddling-individual-bits#Bit Operations: Twiddling Individual Bits":"The Z80 has dedicated bit manipulation instructions:\nBIT 3,A         ; Test if bit 3 of A is set (updates Z flag)\nSET 5,B         ; Set bit 5 of B to 1\nRES 2,C         ; Reset bit 2 of C to 0\nThese are slow when operating on memory via (HL) or indexed - they take 15+ cycles. But for register operations, they're clean and readable.Rotate and shift:\nRLA             ; Rotate A left through carry\nRRA             ; Rotate A right through carry\nRLC A           ; Rotate A left (bit 7 -> bit 0, also -> carry)\nSLA B           ; Shift B left (bit 7 -> carry, 0 -> bit 0)\nSRL C           ; Shift C right logical (0 -> bit 7, bit 0 -> carry)\nSRA D           ; Shift D right arithmetic (bit 7 preserved, bit 0 -> carry)","control-flow-making-decisions-and-loops#Control Flow: Making Decisions and Loops":"Programs need to make decisions and repeat operations. The Z80 provides jumps, calls, and returns in both conditional and unconditional forms, plus specialized loop instructions.Unconditional jumps:\nJP 0x4000       ; Jump to absolute address\nJR label        ; Jump relative (-126 to +129 bytes, smaller/faster)\nJP (HL)         ; Jump to address in HL (not a memory read!)\nConditional jumps:\nJP Z,label      ; Jump if Zero flag set\nJP NZ,label     ; Jump if Zero flag clear\nJP C,label      ; Jump if Carry flag set\nJR NC,label     ; Relative jump if No Carry\nSubroutines:\nCALL subroutine ; Push PC to stack, jump to address\nRET             ; Pop return address from stack, jump there\nRET Z           ; Return if Zero flag set\nThe JR (jump relative) instructions are faster and smaller than JP when the target is nearby. They use a signed 8-bit offset, so they can reach -126 to +129 bytes from the current position.Loops using DJNZ:\n    LD B,10         ; Loop counter\nloop:\n    ; ... do something 10 times ...\n    DJNZ loop       ; Decrement B, jump if not zero\nDJNZ (Decrement and Jump if Not Zero) is a single instruction that decrements B and jumps if the result isn't zero. Compact loop construct that costs just 13 cycles when it branches.","stack-operations-last-in-first-out#Stack Operations: Last In, First Out":"The stack starts at high memory and grows downward. The stack pointer (SP) points to the last pushed value.\nPUSH BC         ; SP -= 2, write BC to stack\nPOP DE          ; Read from stack into DE, SP += 2\nPUSH AF         ; Save accumulator and flags\nThe stack is crucial for:\nSubroutine calls: CALL pushes the return address, RET pops it\nInterrupts: Hardware automatically pushes PC when an interrupt fires\nTemporary storage: Need an extra register? Push one to the stack\nBut stack operations are slow (memory accesses), so don't use PUSH/POP for quick register swaps - that's what EX and EXX are for.","block-operations-when-you-need-to-move-data-in-bulk#Block Operations: When You Need to Move Data in Bulk":"The Z80 has powerful block instructions that operate on entire memory regions:\nLDI             ; (DE) = (HL), increment HL and DE, decrement BC\nLDIR            ; Repeat LDI until BC = 0 (auto-loop)\nCPI             ; Compare A with (HL), increment HL, decrement BC\nCPIR            ; Repeat CPI until BC = 0 or A = (HL)\nExample: Clear 256 bytes of screen memory\n    LD HL,0x4000    ; Source (will be incremented)\n    LD DE,0x4001    ; Destination (one byte higher)\n    LD BC,255       ; Count (256 - 1, we handle first byte separately)\n    LD (HL),0       ; Clear first byte\n    LDIR            ; Fill rest with zeros (copies 0x4000 to 0x4001, then 0x4001 to 0x4002, etc.)\nThis trick uses LDIR to propagate a single zero byte across memory. Classic Z80 optimization.","z80n-extensions-what-the-next-adds#Z80N Extensions: What the Next Adds":"The Z80N extends the original instruction set with new opcodes that live in previously undefined instruction space. All original Z80 software runs unchanged - the new instructions use opcodes the original Z80 would execute as NOP or invalid.","motivation-why-add-instructions-at-all#Motivation: Why Add Instructions at All?":"The Z80 instruction set has gaps - operations that require awkward multi-instruction sequences. The Z80N additions focus on:\nRegister operations that save cycles in common patterns\nStack manipulation for cleaner function prologues/epilogues\nBit manipulation that's faster and more flexible\nMemory access with new addressing modes\nHardware access specific to Next features","new-load-instructions#New Load Instructions":"LD (nn),BC / LD (nn),DE / LD (nn),HLThe original Z80 can load register pairs from memory but not store them directly:\n; Original Z80 - storing BC to memory requires two instructions:\nLD (addr),C\nLD (addr+1),B\n; Z80N - single instruction:\nLD (addr),BC\nLD BC/DE/HL,(nn)Similarly, loading 16-bit values is now symmetric:\n; Z80N - load BC from memory:\nLD BC,(0x5C78)\nThese save cycles and code space in common operations like saving/restoring pointers.","push-immediate-values#Push Immediate Values":"PUSH nnThe original Z80 can't push immediate values to the stack:\n; Original Z80:\nLD HL,0x1234\nPUSH HL\n; Z80N:\nPUSH 0x1234     ; Directly push 16-bit value\nSaves 2 bytes and multiple cycles when setting up stack frames or passing constant parameters.","extended-register-operations#Extended Register Operations":"NEXTREG reg,valueThis is Z80N's killer feature for Next-specific hardware: write to NextReg registers without going through ports:\n; Original Z80 method:\nLD BC,0x243B    ; NextReg select port\nLD A,21         ; Register number\nOUT (C),A\nLD BC,0x253B    ; NextReg data port\nLD A,128        ; Value to write\nOUT (C),A\n; Z80N method:\nNEXTREG 21,128  ; Single instruction, 2 bytes shorter, faster\nNextReg registers control Next-specific features: layer priorities, palettes, memory mapping, sprites, copper, DMA, etc. The NEXTREG instruction makes accessing these dramatically more efficient.NEXTREG reg,AVariant that writes the accumulator's value:\nLD A,(palette_value)\nNEXTREG 0x41,A      ; Write A to palette register","test-and-set-atomic-bit-operations#Test and Set: Atomic Bit Operations":"TEST nTest immediate value against accumulator (like CP but with AND semantics):\nTEST 0x80       ; Test if bit 7 of A is set\nJP NZ,bit_set   ; Jump if it was\nEquivalent to AND 0x80 but doesn't destroy A's value.","mirror-operations#Mirror Operations":"MIRROR AReverses the bit order of the accumulator:\nLD A,0b10110001    ; Binary 177\nMIRROR A           ; A = 0b10001101 (bits reversed)\nWhy? Bitmap graphics use little-endian bit order (bit 0 = leftmost pixel), but sometimes you need to flip horizontally. MIRROR does this in a single instruction instead of 8 shifts and masks.","multiply-operations#Multiply Operations":"MUL / MUL D,EThe original Z80 has no multiply instruction - you write a loop:\n; Original Z80 - multiply D by E, result in HL:\nLD HL,0\nLD B,8\nloop:\n    ADD HL,HL\n    SLA E\n    JR NC,skip\n    ADD HL,DE\nskip:\n    DJNZ loop\n; Z80N:\nMUL D,E         ; HL = D * E (unsigned 8x8 = 16-bit result)\nThis is dramatically faster - the multiply completes in about 128 cycles versus 100+ for the loop version, but saves massive code space and programming complexity.Note: The multiply is unsigned. For signed multiplication, you need to handle signs separately and negate the result if needed.","extended-addressing-modes#Extended Addressing Modes":"ADD/ADC/SUB/SBC HL,valueImmediate arithmetic on 16-bit register pairs:\n; Original Z80:\nLD BC,1000\nADD HL,BC\n; Z80N:\nADD HL,1000     ; Directly add immediate value\nADD/ADC/SUB/SBC A,valueWait, doesn't the Z80 already have this? Yes - but Z80N adds missing modes:\nADD A,(HL)      ; Add memory via HL (original Z80 has this)\nADD A,(IX+d)    ; Add memory via IX+offset (Z80N adds this)\nFills in gaps in the addressing mode matrix.","stack-frame-operations#Stack Frame Operations":"LDPIRXComplex instruction designed for stack frame manipulation in high-level languages. It combines multiple operations:\nLDPIRX          ; DE = (HL), HL += 2, BC -= 2, repeat until BC = 0\nUsed in CP/M BDOS emulation and some compiler-generated code. Specialized, but useful when you need it.","swap-operations#Swap Operations":"SWAPNIBSwaps the high and low nibbles of the accumulator:\nLD A,0x3F\nSWAPNIB         ; A = 0xF3\nUseful for BCD operations, palette color manipulation, and bit-packed data structures.PIXELDN / PIXELADThese are Next-specific operations for navigating screen memory:\nPIXELDN         ; Move HL down one pixel row in screen memory\nPIXELAD         ; Move HL down one attribute row in screen memory\nScreen memory on the Spectrum is not linear - it's divided into three 2KB thirds, each containing 64 character rows. Navigating vertically requires awkward arithmetic:\n; Original Z80 - move down one pixel in screen memory:\nINC H           ; Move to next row in same third\nLD A,H\nAND 0x07\nJR NZ,done      ; Still in same character row\nLD A,L\nADD A,0x20\nLD L,A\nLD A,H\nADC A,0x00\nLD H,A\ndone:\n; Z80N:\nPIXELDN         ; Single instruction","barrel-shift-operations#Barrel Shift Operations":"SETAESets the accumulator from flags in a specific pattern:\nSETAE           ; A = carry flag (extended to 8 bits: 0xFF if C=1, 0x00 if C=0)\nUseful for branchless code and bit manipulation.","practical-considerations-writing-z80n-code#Practical Considerations: Writing Z80N Code":"Understanding instructions is one thing; using them effectively is another. Here's practical guidance for writing Z80N code that's fast, compatible, and maintainable.","when-to-use-z80n-instructions#When to Use Z80N Instructions":"Use them when:\nYou're writing Next-specific code that won't run on original hardware\nThe speed improvement matters (multiply, NextReg access)\nCode clarity improves significantly (PIXELDN vs. manual screen navigation)\nAvoid them when:\nYou need compatibility with original Spectrum\nYou're writing library code that should be portable\nThe benefit is marginal (one instruction vs. two with no speed gain)","cycle-timing-matters#Cycle Timing Matters":"The Z80 runs at 3.5 MHz on original Spectrum, 3.5/7/14/28 MHz on Next. Every instruction has a fixed cycle count:\nLD A,B          ;  4 cycles\nLD A,(HL)       ;  7 cycles\nLD A,(IX+5)     ; 19 cycles (slow!)\nContended memory adds wait states when accessing screen memory (0x4000-0x7FFF) during active display. At 3.5 MHz, this can add 0-6 cycles per memory access depending on timing. Avoid the contended region in tight loops, or use uncontended memory (0xC000+) for critical data.","register-allocation-strategy#Register Allocation Strategy":"The Z80 has limited registers, so choose wisely:\nA: Your workhorse accumulator; all arithmetic starts here\nHL: Primary pointer; most instructions favor HL over DE/BC\nBC: Loop counters, secondary pointer, port addresses\nDE: Data pointer, rarely as versatile as HL\nIX/IY: Fixed base addresses with offsets (but slow - add 4-8 cycles vs. HL)\nAlternate registers (via EXX): Great for interrupt handlers and preserving state, but creates \"invisible\" dependencies that make debugging harder. Use sparingly in application code.","summary-z80-and-z80n-in-the-next#Summary: Z80 and Z80N in the Next":"The Z80 brought 8-bit computing to millions in the late 1970s and 1980s. Its instruction set is powerful enough for sophisticated software, yet simple enough to understand without years of study. The architecture's limitations (64KB address space, limited registers) forced programmers to think carefully about resource usage - constraints that made better programmers.The Z80N extensions respect this legacy. They don't fundamentally change the architecture - you're still writing Z80 assembly,just with better tools for common operations. The original Z80 mindset still applies: every byte matters, every cycle counts, clever tricks beat brute force.For emulator builders, this means:\nImplement the original Z80 instruction set completely and accurately\nAdd Z80N extensions as a separate layer that can be toggled\nTrack cycle counts precisely (they matter for timing-sensitive code)\nHandle contended memory correctly (or document that you don't)\nRemember that real programmers are incredibly clever - anything your emulator gets wrong, someone will notice\nThe Z80 and Z80N aren't just historical curiosities. They're living architectures with active communities writing new software today. Understanding them means understanding a design philosophy: make the simple stuff simple, make the complex stuff possible, and trust programmers to know the difference.For deeper dives into specific instruction categories, see the detailed chapters on arithmetic operations, memory management, and timing-critical code. For Z80N-specific emulation notes, see the Next extensions chapter."}},"/commands-reference":{"title":"Commands Reference","data":{"bp-ea#bp-ea":"This command erases all breakpoints already set.\nbp-ea\nAvailable aliases: eab","bp-list#bp-list":"This command lists the breakpoints already set.\nbp-list\nAvailable aliases: bpl","bp-del#bp-del":"This command removes a breakpoint.\nbp-del <address-spec>\nAvailable aliases: bdThe address-spec parameter can be\na 16-bit address (using the number for the address), for example, $120a or 32768;\nan address with a partition Available aliases: shmem","w-add#w-add":"This command adds a watch expression for a symbol.\nw-add [>]<symbol>[:<type>[:<length>]]\nAvailable aliases: wThe watch expression specification format is [>]<symbol>[:<type>[:<length>]] where:\nsymbol: A valid identifier (symbol name)\n>: Optional flag. When present, the watch is marked as direct (the IDE will treat the symbol as a direct value/address).\ntype: Optional data type (defaults to b if omitted). One of the following:\na: byte array (requires length)\nb: 8-bit number (default)\nw: 16-bit little-endian number\nl: 32-bit little-endian number\n-w: 16-bit big-endian number\n-l: 32-bit big-endian number\nf: flag (boolean, zero is false, other values are true)\ns: string (requires length)\nlength: Required for array (a) and string (s) types, must be between 1 and 1024\nExamples:\nw-add playerScore - 8-bit value (default type)\nw-add >playerScore - 8-bit value with direct flag\nw-add playerScore:w - 16-bit little-endian value\nw-add playerName:s:32 - 32-byte string\nw-add inventory:a:64 - 64-byte array\nw-add isAlive:f - boolean flag","w-del#w-del":"This command removes a watch expression by symbol name.\nw-del <symbol>\nAvailable aliases: wdThe symbol parameter is the name of the symbol for which the watch expression should be removed.","w-ea#w-ea":"This command erases all watch expressions.\nw-ea\nAvailable aliases: wea","w-list#w-list":"This command lists all defined watch expressions.\nw-list\nAvailable aliases: wlThis command displays all defined watchpoints with their symbol names, data types, lengths (if applicable), and resolved addresses/partitions (if the symbols have been resolved after compilation).","show-memorye-partition-and-the-address-separated-with-a-colon-for-example-r132ac-meaning-32ac-provided-rom-1-is-paged-in#show-memorye partition and the address separated with a colon), for example, r1:$32ac (meaning $32ac, provided ROM 1 is paged in);":"or a source code line specification, for example, [code/code.kz80.asm]","bp-en#bp-en":"This command turns a breakpoint already set on or off.\nbp-en <address-spec> [-d]\nAvailable aliases: bdThe address-spec parameter can be\na 16-bit address (using the number for the address), for example, $120a or 32768;\nan address with a partition (the partition and the address separated with a colon), for example, r1:$32ac (meaning $32ac, provided ROM 1 is paged in);\nor a source code line specification, for example, [code/code.kz80.asm]\nThe -d option disables the breakpoint.","bp-set#bp-set":"This command sets a breakpoint.\nbp-set <address-spec>\nAvailable aliases: bpThe address-spec parameter can be\na 16-bit address (using the number for the address), for example, $120a or 32768;\nan address with a partition (the partition and the address separated with a colon), for example, r1:$32ac (meaning $32ac, provided ROM 1 is paged in);\nor a source code line specification, for example, [code/code.kz80.asm]","close#close":"Use this command to close the folder currently opened in the IDE.\nclose","clh#clh":"Use this command to clear the interactive command prompt history.\nclh","cls#cls":"Use this command to clear the interactive command output.\ncls","compile#compile":"This command compiles the code, provided a Klive project is loaded, and a build root file is selected.\ncompile\nAvailable aliases: co","crd#crd":"This command creates an empty disk file (DSK format) you can use with ZX Spectrum +3 models (and compatible).\ncrd <disk-type> <disk-name> [<disk-folder>] [-p]\nThese are the arguments of the command:\ndisk-type: One of these supported formats:\nss: Single-sided CPC\nds: Double-sided CPC\nsse: Single-sided Extended CPC\ndse: Double-sided Extended CPC\ndisk-name: The name of the disk file (.dsk extension as added automatically)\ndisk-folder: An optional folder in which the new disk file is created. The folder must exist.\n-p: Creates the disk file within the currently opened project folder (under disks).","debug#debug":"This command compiles the code. If the compilation is successful, it injects the code into the current virtual machine and starts it in debug mode. This command requires that a Klive project be loaded.\ndebug\nAvailable aliases: rd\nNote: The command will start (or restart) the virtual machine.","dis#dis":"This command disassembles the specified memory section and displays the disassembly result in a new document pane.\ndis <start> <end> [-d] [-c] [-lc]\nIt requires a start and an end (inclusive) address. Use the -d option if you want the disassembly to display addresses, numbers, and instructions with decimal numbers. The -c option turns on the concise mode (disassembled bytes are omitted from the output). By default, labels do not end with colons; however, you can turn on this mode with the -lc option.\nNote: This command does not support bank operations (yet). It can disassemble only the currently paged 64K memory.","em-debug#em-debug":"This command starts the current machine in debug mode.\nem-debug\nAvailable aliases: :d","em-out#em-out":"This command executes all instructions until it exits the current subroutine and pauses at the instruction following the subroutine call. It expects the machine to be paused when this command is issued.\nem-out\nAvailable aliases: :o\nNote: If the function returns unconventionally (for example, popping the return address and jumping to it, etc.), this command may not stop the machine.","em-pause#em-pause":"This command pauses (suspends) the current machine.\nem-pause\nAvailable aliases: :p","em-restart#em-restart":"This command restarts (stops, and then starts) the current machine.\nem-restart\nAvailable aliases: :r","em-start#em-start":"This command starts the current machine.\nem-start\nAvailable aliases: :s","em-sti#em-sti":"This command executes the next Z80 instruction from the current PC (Program Counter) and pauses the machine again. It expects the machine to be paused when this command is issued.\nem-sti\nAvailable aliases: :","em-sto#em-sto":"This command executes the next Z80 instruction from the current PC (Program Counter). If that instruction is a function call or a block instruction, it executes the entire subroutine or block operation before pausing again. It expects the machine to be paused when this command is issued.\nem-sto\nAvailable aliases: .\nNote: If the function call does not return to the instruction following the current instruction at the PC address, the machine won't pause again (unless it reaches a breakpoint).","em-stop#em-stop":"This command stops the current machine.\nem-stop\nAvailable aliases: :h","expc#expc":"This command compiles the code and exports it according to the specified options.\nexpc filename [-n name] [-f format] [-as] [-p] [-c] [-b border]\n  [-sb] [-addr address] [-scr screenfile]\nThese are the input arguments and options:\nfilename: The name of the exported file\n`-n: The name of the program in the exported file. This name will be displayed during the LOAD operation.\n-f: The file format to use:\nhex: Intel HEX format\ntzx: TZX file format\ntap: TAP file format\n-as: Autostart the exported code after loading it\n-p: Add a PAUSE statement into the loader (before starting the loaded code)\n-c: Add a clear statement to keep the end of the BASIC code before the start address of the exported code\n-b: Specifies the border color to set when the loader program starts\n-sb: The compiled code may contain multiple segments. If this option is used, the exporter merges all code segments into one (filling up the padding code with zeros). Otherwise, each code segment goes into a separate CODE file.\n-addr: Specifies the start address of the exported code. The exported extracts this information from the compilation result if not specified. However, you can change the inferred address with this option.\n-scr: You can specify a screen file (TAP or TZX format) to load after the autoloader.\nNote #1: If the compilation fails, no code will be exported.\nNote #2: If you compile code for a ZX Spectrum 128 (or upper) model with multiple bank support, the exporter creates a loader that loads the banks in the compilation (and puts them into the appropriate memory bank) before starting the app.","hide-disassembly#hide-disassembly":"Use this command to hide the machine code disassembly view.\nhide-disassembly\nAvailable aliases: hdis","hide-memory#hide-memory":"Use this command to hide the memory contents view.\nhide-memory\nAvailable aliases: hmem","inject#inject":"This command compiles the code, and if the compilation is successful, it injects the code into the current virtual machine. This command requires that a Klive project be loaded and the virtual machine be paused.\ninject\nAvailable aliases: inj","nav#nav":"This command navigates to the specified project file (to an optional position). If the file is not open yet, the IDE opens it.\nnav projeFile [line] [column]\nThe filename argument is a project file name. When you specify the name, use the full name (including the file extension) relative to the project's root folder. For example, if your file is in the code folder and named program.zxb, use the code/program.zxb parameter.You can specify an optional line and column argument to jump to the specified location within the file.","newp#newp":"This project creates a new Klive project and optionally opens it.\nnewp <machine-id> <project-name> [<template>] [-p <project-folder>] [-o]\nThe machine-id  argument specifies the ID of the machine and an optional model. When you specify the machine and model type, use a colon to separate the machine ID from the model ID. For example, use sp48 for the basic ZX Spectrum 48K model and sp48:ntsc to use the NTSC version of ZX Spectrum 48K. See the Machine Types article for these IDs.The project-name argument defines the project's name. Unless the optional project-folder parameter is specified, the new project is created in the KliveProjects folder within your user folder.Klive may support multiple project templates for a particular machine type (it provides a default template for each). If you want a specific template, specify its name in the template argument. See the Project Templates article for more information about available templates.By default, the IDE creates a new project but does not open it. However, if you add the -o option, the new project will be immediately opened.","num#num":"This command displays its argument number in decimal, hexadecimal, and binary formats.\nnum <number>\nThe input argument can be in decimal, hexadecimal, or binary format.","open#open":"Use this command to open a folder.\nopen [<folder-path>]\nAvailable aliases: opIf the folder-path argument is omitted, the IDE opens the show folder dialog to select a project folder. Otherwise, the IDE opens the project you specified. If the folder path is relative, the IDE loads the folder within your user directory's KliveProjects folder.","outp#outp":"You can select a particular output pane with this command.\noutp <paneId>\nThe paneId argument can be one of the available output panes (emu, build, or script).","projectexcluded-items#project:excluded-items":"This command lists the definitions of excluded project items. You can use the -global option to list the items that are excluded globally.\nproject:excluded-items [-global]\nAvailable aliases: project:list-excluded, proj:excluded-items, proj:list-excluded, p:lx","projectexclude-item#project:exclude-item":"This command adds or deletes excluded project items. You can use the -global option to list the items that are excluded globally. The -d option signs that the defined option should be deleted from the exclusion list. You can specify multiple items to add or delete.\nproject:exclude-item [--global] [-d] <item-path-1> ... <item-path-n>\nAvailable aliases: project:exclude, proj:exclude-item, proj:exclude, p:x","run#run":"This command compiles the code. If the compilation is successful, it injects the code into the current virtual machine and starts it. This command requires that a Klive project be loaded.\nrun\nAvailable aliases: r\nNote: The command will start (or restart) the virtual machine.","run-build-function#run-build-function":"This command starts the build command function (see the build.ksx file) named in the command argument.\nrun-build-function <function-name>\nAvailable aliases: rbfThe build.ksx file contains several commands, such as buildCode, injectCode, runCode, debugCode, and exportCode. Some projects may have additional custom commands.","script-cancel#script-cancel":"This command runs the script file specified in the argument.\nscript-cancel <script-file-path-or-script-id>\nAvailable aliases: scYou can provide a script file name or a script ID as an argument. When you start a script, the ID of the running script is displayed. You can also get a particular script's ID from the Script History panel.When you specify a file name, use the full name (including the .ksx file extension) relative to the project's root folder. For example, if your script is in the scripts folder and named myScript.ksx, use the scripts/myScript.ksx parameter.","script-output#script-output":"This command navigates to the output document of the specified script.\nscript-output <script-id>\nAvailable aliases: soYou must provide a script ID as an argument. When you start a script, the ID of the running script is displayed. You can also get a particular script's ID from the Script History panel.","script-run#script-run":"This command runs the script file specified in the argument.\nscript-run <script-file-path>\nAvailable aliases: scrProvide the full file name (including the .ksx file extension) relative to the project's root folder. For example, if your script is in the scripts folder and named myScript.ksx, use the scripts/myScript.ksx parameter.","sjasmp-reset#sjasmp-reset":"Provide the folder path of the SjasmPlus compiler.\nsjasm-reset <SjasmPlus executable folder> [-p]\nAvailable aliases: sjasmprKlive stores the SjasmPlus settings in the Klive.setting file. If you want to change this path for a particular project (perhaps you want to test with another SjasmPlus version), use the -p switch to save this setting into the currently open project.","set#set":"You can use this comment to set or delete a particular Klive setting.\nset [-p] [-u] <key> [<value>] \nUse the -p option to set a project setting or -u for a user setting. <key> is the setting key, <value> is the new setting value. The specified key is removed if you omit <value>.\nNote: Project settings are saved in the currently open project file, while user settings are saved in the Klive/live.settings file under your user folder.\nIf you do not specify the context (with -p or -u), the IDE will save a project setting, provided a project is open; otherwise, it saves a user-level setting.","setl#setl":"This command lists the specified settings.\nsetl [-p] [-u] [<setting>] \nUse the -p option to list project settings or -u for user settings. By default, all settings in the specified bucket are listed. Additionally, you can specify a setting prefix in <setting>. In this case, only matching settings are listed.\nNote: Project settings are saved in the currently open project file, while user settings are saved in the Klive/live.settings file under your user folder.\nIf you do not specify the context (with -p or -u), the IDE will list project settings, provided a project is open; otherwise, it lists user-level settings.","setm#setm":"This command lists the specified settings.\nsetl [-pull] [-push] [-c] \nThis command moves settings from the user setting file to the current project file (-pull) or vice versa (push). The additional -c option copies the settings instead of moving them.\nNote: You can use either -pull or push. This command works only when a Klive project is open in the IDE.","setmem#setmem":"This command sets the memory contents at the specified address with the provided value. When you set the content, you can use 8-bit, 16-bit, 24-bit, and 32-bit values using little-endian or big-endian assignment.\nsetmem <address> <value> [-b8] [-b16] [-b24] [-b32] [-be]\nThe -b8 (default), -b16, -b24, and -b32 options determine the data size (1, 2, 3, or 4 bytes, respectively) to write into the memory. These options are exclusive.The -be option specifies the big-endian mode; the most significant byte of the value is written to the address specified in the command.Lets assume you execute this command:\nsetmem $4000 $010203 -b24\nIt will store $03 at address $4000, $02 at $4001, and $01 at $4002 (little-endian mode). However, adding the -be options like this:\nsetmem $4000 $010203 -b24 -be\nWill reverse the order of bytes: It will store $01 at address $4000, $02 at $4001, and $03 at $4002 (big-endian mode).","setz80reg#setz80Reg":"Use this command to set one of these Z80 registers:\n8-bit: A, F, B, C, D, E, H, L˙, XH, XL, YH, YL, I, and R`\n16-bit: AF, BC, DE, HL, AF', BC', DE', HL', IX, IY, PC, SP, and WZ (memptr).\nsetz80Reg <register> <value> \nAvailable aliases: sr\nThis command runs only when the machine is paused. In other states, it gives an error message.\nWhen the value is outside the register's valid range, the command will give you a warning and keep only the last 8 or 16 bits.","show-disassembly#show-disassembly":"Use this command to display the machine code disassembly view.\nshow-disassembly\nAvailable aliases: shdis","show-memory#show-memory":"Use this command to display the memory contents view.\nshow-memory\nAvailable aliases: shmem","zxb-reset#zxb-reset":"Use this command to set ZXBASIC integration.\nzxb-reset <Full ZXBC executable path> [<python3 path>] [<start of machine code>]\nAvailable aliases: zxbrProvide the full executable path of the ZXBC compiler. Optionally, you can provide the path to the Python3 executable and the start of the machine code. See the ZXBASIC integration article for more information."}},"/contribute/get-source":{"title":"Get the Source Code","data":{"":"If you want to contribute to Klive, you should get the source code with these steps:\nMake sure Node.js is installed on your machine. If not, download it from https://nodejs.org/en/download (use the LTS version)\nWe recommend using Visual Studio Code. Nonetheless, you can work with your preferred development tool.\nFork the Klive GitHub repository (https://github.com/Dotneteer/kliveide) and clone your fork with git clone.\nExecute npm install.\nAfter these steps, Klive should start with npm run dev.\nWhen your contribution is ready to submit, create a GitHub Pull Request from your fork's branch to Klive's master branch. The team will review it and decide how to merge it."}},"/contribute/improve-docs":{"title":"Improve the Documentation","data":{"":"Though we strive to maintain high-quality documentation, you may find typos, grammar issues, clumsy explanations, out-of-date information, and other problems.You can help by fixing these issues or submitting new content.Klive generates its documentation using Nextra. This article explains how to contribute to improving the documentation.Follow the steps to get the source code.","running-the-documentation-site-locally#Running the Documentation Site Locally":"Start the documentation site locally on your development machine with the npm run doc:dev command, then visit http://localhost:3000 in your browser.This site uses hot module reloading (HMR), so as you modify the documentation, updates are displayed live in your browser. When you have completed all modifications, create a GitHub Pull Request from your working branch to Klive's master branch for review and merging.","documentation-structure#Documentation Structure":"You can find these documentation-related folders within the project's root:\npages: The source documentation files using Nextra and the .mdx (extended markdown) format. Documentation lives in .mdx files. The content of this folder represents the hierarchy of the documentation. Each folder describes its content in a _meta.ts file (you'll understand them; they map the individual files with the table of contents).\npublic/images: The image resources of the documentation pages (organized hierarchically).\nThe project contains some other Nextra-related files; please do not touch them. If you have to do so, please add some comments to your submitted PR to explain your intention.","common-documentation-tasks#Common Documentation Tasks":"","adding-a-new-page#Adding a New Page":"Create a new .mdx page in the appropriate folder. Use a short name representing the contents you intend to describe.\nOptionally, you can create a new folder and add documentation files there.\nEnsure you update the _meta.ts file in the new article folder with a suitable title. Place the new article in the location where it fits the best among the already existing articles.\nYou can consider existing articles as examples.","creating-hidden-pages#Creating Hidden Pages":"Sometimes you may want to create documentation pages that are accessible via URL but don't appear in the navigation sidebar. This is useful for:\nSupplementary reference materials\nDraft content that's ready but not yet promoted\nSpecial-purpose landing pages\nBeta feature documentation\nTo create a hidden page:\nCreate your .mdx file in the appropriate folder (e.g., pages/book.mdx)\nAdd an entry for this page in the corresponding _meta.ts file with display: \"hidden\"\nThe page will be accessible via its URL path (e.g., /book) but won't appear in navigation\nExample:\n// pages/_meta.ts\nexport default {\n  index: \"Introduction\",\n  \"getting-started\": \"Getting Started\",\n  book: {\n    display: \"hidden\"  // Page exists at /book but hidden from sidebar\n  }\n};\nThe page at pages/book.mdx will be accessible at /book but hidden from the sidebar. You can link to hidden pages from other documentation pages using standard markdown links: [Link text](/book).See the example hidden page to understand how this works in practice.","adding-images#Adding images":"You can add images following these steps:\nAdd the following line to the top of the .mdx file:\nimport ClickableImage from '../../page-components/ClickableImage'\nCopy the image to add into the right folder within public/images (under the project's root folder).\nUse the <ClickableImage> component to place your image in an article:\n<ClickableImage \n  src=\"/images/working-with-ide/mem-view.png\" \n  alt=\"Memory view\" \n  width={512} \n/>\nTo set the image's display dimensions, use the width attribute. The ClickableImage component will handle proper path resolution for both development and production environments."}},"/getting-started/creating-project":{"title":"Creating a Klive Project","data":{"":"The IDE supports developing applications with a Klive project. With the File | Open folder command, you can open the contents of a particular folder and display it. The IDE considers folders with a well-formed klive.project file within them a Klive project.\nIn Klive v0.32.0, a new file, build.ksx, was introduced to allow build process customization. At the end of this article, you will find a section about updating your old Klive projects to leverage the new build system.","the-new-project-dialog#The New Project Dialog":"With the File | New project menu command, you can create a new Klive project:\nYou can select the machine type to use in the project (you can change it any time when the project is open).\nThe IDE offers you a few project templates depending on the machine type.\nYou can specify a root folder for your project directory. The new project will be a subfolder of the root. If you leave it empty, the new project goes into your user home's KliveProjects folder.\nThe project requires a name (MyFirstKliveProject in the figure above).\nWhen you click Create, the IDE creates the new project folder and opens it.","the-project-structure#The Project Structure":"A Klive project is a folder with a klive.project file in it. The file is a JSON file that describes the project's properties. The IDE creates the following structure for a new project:\nThe little home icon to the left of the root folder name (MyFirstKliveProject) indicates that the open folder is a Klive project. The last two files contain essential information related to the current project.\nklive.project is the file that stores project settings, including the machine type, IDE options, breakpoints, etc. Klive IDE does not allow editing it in its code editor.\nbuild.tsx is a script file that executes within the IDE. It contains functions representing build commands.\nBy changing the functions' body, you can customize the build (and create new build-related commands).When you open a folder that is not a Klive project (does not have a valid klive.project file), you cannot see the home icon:","the-build-root#The Build Root":"When you develop your code, you may work with multiple files — Klive needs to know the main file to compile it to machine code. The build root designates this main file. When you create a new project, Klive automatically assigns a file as the build root. In the Explorer, the \"combine\" icon to the right of the file name indicates this:\nYou can change the build root any time by right-clicking on a file and selecting the Promote to Build Root command.\nThe Promote to Build Root command is available only for particular file types Klive supports.","build-root-commands#Build Root commands":"When you select the build root in the Explorer, the content of the file opens in the code editor, and it displays four icons at the right side of the document tab bar:\nEach of these icons carries out a particular operation:\nIcon\tOperation\t\tThis command compiles the project using the build root file as the main file. This operation lets you check whether your code is free from compilation errors.\t\tThis command compiles the project. If the compilation is successful, it immediately injects the binary code into the memory of the paused machine. After the operation, you can resume the machine and execute the code (for example, with the RANDOMIZE USR(<address>) command).\t\tWith this command, you can start the compiled code.\t\tWith this command, you can start the compiled code in debug mode.\t\nWhen you start the code, Klive executes several steps to ensure a one-click user experience to run or debug the code:\nThe IDE compiles the code. If the compilation fails, no program is started.\nThe IDE restarts the current machine on successful compilation and runs while its OS reaches the main execution cycle. At this point, the IDE may emulate keystrokes to lead the OS to a point where code execution is safe.\nKlive pauses the machine and injects the code into the memory.\nKlive sets the Program Counter (PC) register to the entry point of the injected code and resumes the machine.\nThe injected code runs.","the-project-file#The Project File":"The klive.project file encapsulates information about the current project, including the machine type, UI settings, breakpoint, project state, and many others. While you work with the project, the IDE may update this file.The project file uses JSON format. When you click it in the Explorer, you can look at its content within the code editor. However, the IDE considers this file read-only; thus, it does not allow you to edit it directly. The little shield icon to the right of the filename indicates this read-only state.\nThough you cannot edit this file with the IDE, you can modify it outside. Such modifications may lead to the loss of the project file if the IDE cannot parse klive.project while opening the project folder. If you ever decide to modify klive.project manually, make sure that particular project is not open in the IDE.","updating-old-projects#Updating Old Projects":"If you created your Klive project before v0.32.0, you might have a project without a build.ksx file. After v0.4.0, these projects will not compile, inject, or run your code, as it needs the build.ksx file. Follow these steps to fix the issue:\nOpen your project in Klive.\nWith the New file context menu, add a new file to your project root folder. (It must be the same level as the klive.project file.)\nType the following code into the build.ksx file:\nexport function buildCode() {\n  $command(\"klive.compile\")\n}\nexport function injectCode() {\n  $command(\"klive.inject\")\n}\nexport function runCode() {\n  $command(\"klive.run\")\n}\nexport function debugCode() {\n  $command(\"klive.debug\")\n}\nexport function exportCode() {\n  $command(\"display-dialog export\")\n}\nClose the project.\nOpen the project again; Klive recognizes the build.ksx file and prepares the build functions accordingly.\nNow, you should be able to compile, inject, and run your code."}},"/getting-started/first-run":{"title":"Running Klive","data":{"":"The first time you start Klive, it displays the Emulator window. You can recognize it from the dark grey box representing a turned-off machine.\nKlive stores your last selected machine type and a few other settings when you close the app and reloads them automatically the next time you start Klive again.Klive has two separate windows; however, the first time you start it, the app shows only the Emulator window. Select the View | Show IDE menu command and Klive displays the IDE window:\nWhen you close the Emulator window, it automatically closes the IDE window, too. However, closing the IDE window keeps the Emulator window open. You can quit the Klive application by closing the Emulator window or selecting File | Exit on Windows or Klive | Quit klive-emu on Mac.\nKlive saves the window positions when exiting the app. If you use multiple monitors, the windows will be restored according to their last display the next time you start Klive.","controlling-the-emulator#Controlling the Emulator":"You can start the emulated machine (ZX Spectrum 48K, by default) in several ways:\nPressing the F5 key.\nUsing the Machine | Start menu command\nClicking the Play toolbar button (the leftmost green button of the Emulator's toolbar)\nYou can also start the machine with the em-start (or :s) interactive command within the IDE.\nYou can control the running machine with other commands:\nPause: You can suspend running the machine with the Shift+F5 key, the Pause icon in the toolbar, or the Machine | Pause menu. Later, you can restore running the machine.\nStop: When turning the emulated machine off, use the F4 key, the Stop icon in the toolbar, or the Machine | Stop menu command. Though you can view the state of the stopped machine, you cannot continue running it.\nRestart: You can stop and immediately start the machine again with the Shift+F4 key. The same action is available with the Restart toolbar icon and the Machine | Restart menu.","debug-mode#Debug Mode":"The emulator supports running in debug mode. In this mode, the running machine will stop at designated breakpoints, allowing you to examine the current state.You can turn the machine on in debug mode with the Ctrl+F5 key, using the Machine | Start with Debugging menu, or selecting the \"Start with Debugging\" option from the toolbar's drop-down and pressing the play button.When you suspend (pause) the machine, you can continue running it in debug mode with Ctrl+F5. Also, while the machine is paused, you can move it into debug mode with any of these debugger commands:\nStep Into. This command executes the next Z80 instruction and pauses the machine again. Use the F10 key, the Machine | Step Into command, or the Step Into toolbar key.\nStep Over. This command executes the next Z80 instruction and pauses the machine again. Suppose the instruction is a subroutine call, an RST call, or a block operation (e.g., LDIR). In that case, the entire instruction is executed, and the machine pauses again at the next instruction following the call or the block operation. Use the F11 key, the Machine | Step Over command, or the Step Over toolbar key.\nStep Out. This command executes all Z80 instructions to the next return instruction and suspends running again at the return point. Use the Shift+F11 key, the Machine | Step Over command, or the Step Over toolbar key.\nThe Step Out command may not work in every context. There are Z80 programs that do not use the RET statement (or its conditional equivalents) but manipulate the stack and use indirect jump statements. The Step Out command cannot work with such constructs.","changing-the-view#Changing the View":"In the View menu, you find several commands that allow changing  the view of the current window (Emulator or IDE):\nActual Size: Sets the view size to Normal (100%) according to the operating system on which you run Klive.\nZoom In: Enlarges the screen (including all text and graphics).\nZoom Out: Makes text and graphics smaller.\nToggle Full Screen: Turns on and off full-screen mode.\nWhile the Toggle Full Screen command handles the Emulator and IDE windows independently, other commands affect both."}},"/getting-started/installation":{"title":"Installing Klive","data":{"":"Visit the project release page to get the install kits for Klive. You find the latest release at the top of the page. When you expand the Assets tab, it will list five files, including the three installation kits:\nKliveIdeSetup-{version}-{arch}.AppImage: The Linux AppImage format to install Klive IDE on Linux without requiring an admin privilege to run\nKliveIdeSetup-{version}-{arch}.exe: Self-extracting executable to install Klive IDE on Windows x64 (NSIS installer)\nKliveIdeSetup-{version}-{arch}.pkg: The standard PKG format to install Klive IDE on MacOS\n{version} is a placeholder for the version number of a particular release in the filename.\n{arch} is a placeholder for the architecture of the target platform. It can be x64 or arm64.\nWindows currently supports only the x64 architecture.\nDownload the file according to the operating system and architecture to use, and follow the sections of this article.","macos-installation#MacOS Installation":"Open the downloaded .pkg file. As the file comes from an untrusted source, the OS cannot install it directly. Click the OK button to close the message.\nNow, open the System Settings panel and navigate the Privacy & Security tab. As you scroll down, you can see the message with the blocked filename and the Open Anyway button. Click the button to sign that you intend to run the install kit.\nOpen the .pkg file again and select the Open button in the security dialog on the screen.\nThe OS may ask for your password to confirm the installation.\nClick Open to allow the installer to run. Follow the screenshots (use Continue) to complete the installation.\nThe installer will create a Klive IDE folder in the Applications folder and copy the required files into it. It will also create a shortcut in the Launchpad. When you complete the installation, MacOS may ask you for access to your Downloads folder to recycle the install set optionally.\nAfter the successful installation, you can find Klive IDE in your Applications folder.","windows-installation#Windows Installation":"The .exe setup file is a self-extracting executable. Open it, and it will automatically extract itself and copy the executable files into the Programs (within your user home's AppData/Local/Programs/klive-ide) directory.\nKnown Issue on Windows 11: Some users have reported that the installer may appear to hang or take an exceptionally long time to complete (10-22 minutes) on Windows 11 systems. This is typically caused by Windows Defender or other antimalware software scanning the installer. The installer will eventually complete if you wait.\nThe setup kit will start Klive IDE after completion. Later, you can start Klive IDE again:Use the search in the Windows taskbar and type \"Klive\". The newly installed app shows up in the search results:\nClick on Klive IDE to start it.\nWhen Klive IDE is selected in the search result list, the right pane shows the Pin to taskbar command. Use this to add the IDE to the taskbar; later, you can run it with a single click on the Klive IDE icon.","linux-installation#Linux Installation":"The Linux install kit is an .AppImage file. You may need to download and install FUSE on your machine to use it. For example, on Ubuntu (where FUSE is not installed by default), you can install it:\nsudo apt-get install fuse libfuse2\nCopy the .AppImage file into the folder from which you intend to use it. Make it executable with this command line:\nchmod +x KliveIdeSetup-{version}-{arch}.AppImage\nAlternatively, you can right-click on the file in the file manager and select the Properties command. In the Permissions tab, check the Allow executing file as program checkbox:"}},"/getting-started/keyboard":{"title":"Using the Keyboard","data":{"":"You can use the computer's physical keyboard or a virtual keyboard to emulate keystrokes. To let the Emulator process the computer's keyboard, the Emulator should have the focus. When you change the current window to the Emulator with your machine's keys or click it with the mouse, it is ready to receive keystrokes.Of course, you should start the machine and wait while it reaches its main execution cycles and starts watching for keys.","using-the-virtual-keyboard#Using the Virtual Keyboard":"If you do not find it easy to use the computer's physical keyboard, you can use the virtual keyboard. You can display (or hide) it with one of these actions:\nClick the View | Show the Virtual Keyboard menu command while in the Emulator window\nClick the Keyboard icon in the Emulator's toolbar\nWhen the keyboard is to show, Klive displays it according to the selected machine's type. These figures show the ZX Spectrum 48K keyboard and the ZX Spectrum 128L/+2E/+3E keyboard.\nKlive also has custom keyboards for the Cambridge Z88 and the ZX Spectrum Next computers.\nTo press a key, move the mouse over the particular virtual key and click it. If you keep the mouse button down, it's just like keeping the button pressed. Releasing the mouse button behaves as you released the real key.When you move the button slowly over a particular key, it will highlight the part of the button with the symbol shift-related and extended mode-related keys. When you click the mouse, it will automatically \"press\" the symbol shift or extended mode keys.You can use both the left and right mouse buttons. However, when using the right mouse button with normal keys, it behaves as if you pressed the CAPS SHIFT key simultaneously.This table shows a few examples:\nExample\tDescription\t\tThe click will display INPUT (i) when you use the left mouse button or INPUT (I) with the right mouse button, depending on the current ZX Spectrum cursor mode.\t\tThe click will result in AT regardless of which mouse button you click.\t\tThe click will show CODE regardless of which mouse button you click.\t\tThe click will display IN regardless of which mouse button you click.\t\tThe click will display a glyph with its top-left corner set if you click the left mouse button and the inverse of that glyph when you use the right mouse button.","resizing-the-virtual-keyboard#Resizing the Virtual Keyboard":"When you move the mouse to the top border of the virtual keyboard, a sizing splitter bar appears:\nHold down the mouse key while over the splitter, and move it. As you move, Klive changes the keyboard size and resizes the emulator display accordingly:\nWhen you reach the desired size, release the mouse button.","known-issues-with-the-virtual-keyboard#Known Issues with the Virtual Keyboard":"Klive uses some cheats with the glyphs over the numeric buttons. It emulates that you press the GRAPHICS button to turn on the graphics mode, then emulates the keypress, after that releases the key, and then emulates GRAPHICS again. While keeping the key pressed (the mouse button is held down) works for other keys, this behavior is ignored for glyphs.If you click a glyph button several times repeatedly, the ZX Spectrum OS may not process the emulation of GRAPHICS quickly enough, and thus, the editor does not get out of the graphics mode.\nThis is a difficult issue to manage. There is currently no fix for it. Please be patient and type a bit slower when you're about to use glyphs."}},"/getting-started/save-programs":{"title":"Saving Files","data":{"":"When you issue a SAVE operation that targets the tape (with ZX Spectrum +3E, you can save the code to disks), Klive saves the code into a .tzx file.\nIf a Klive project is open in the IDE, the file goes into the SavedFiles folder within the open project folder. The Explorer refreshes its view accordingly.\nOtherwise, Klive saves these files into your home directory's Klive/SavedFiles folder.\nAs of now, you cannot change this default location. However, in the future, Klive will have a setting to define another folder for saved files according to your preference.\nYou can move the saved files to any other location. Using the Machine | Set Tape File command, you can mount that file to load later."}},"/getting-started/tapes":{"title":"Loading from Tape","data":{"":"Klive can emulate playing back tape files with .tap and .tzx extensions. To use them with the LOAD Basic command, first select a tape file using the Machine | Select Tape File function. This command opens a file selection dialog where you can select a .tap or .tzx file. You can also select files with other extensions. In that case, the Emulator tries to read them as tape files by attempting to parse them.On successful read, you can issue a LOAD Basic command (or use the Tape Loader from the startup menu of ZX Spectrum 128/+2E/+3E). The running LOAD command will playback the selected file.\nYou can change the tape file any time, even when the machine is stopped, paused, or running. The effect of such a change is similar to ejecting a tape from a physical tape player and inserting a new one.","normal-and-fast-load#Normal and Fast Load":"Loading ZX Spectrum programs and tapes may take a long time, especially for large files. Besides the normal loading mode, Klive supports fast load, which reads the program instantly, in a fraction of a second.You can turn on or off fast load with the Machine | Fast Load command or by clicking the Fast Load icon (rocket) in the toolbar.You can change the Fast Load mode even while loading a game. However, the change will take effect only when you start loading a program next time.\nBy default, fast load is turned on.","revinding-the-tape#Revinding the Tape":"When the loading completes or gets interrupted, the tape position stays as if you stopped the physical tape player. When you issue the LOAD command again, the load operation starts searching the following file header from the position where it has been stopped.You can rewind the tape to its beginning just as you can do it with a physical tape cassette. Click the Rewind icon in the toolbar (the one to the right of the rocket icon) or execute the Machine | Rewind Tape command.\nKlive allows you to examine the contents of a particular tape file. You can learn about it in the IDE documentation.","how-fast-load-works#How Fast Load Works":"The Fast Load mode applies a powerful technique: ROM hooking. While the emulator runs, it observes when the OS reaches a particular entry point of the load subroutine (by examining the value of the PC register) in the ZX Spectrum ROM, including all ZX Spectrum models.When the execution reaches the load routine, the Fast Load mechanism suspends the machine and injects the data from the tape file directly into the memory. While doing this, the algorithm sets the Z80 registers (including the flags) in the same way as the algorithm in the ROM.When the data is loaded, the mechanism sets the current value of the PC register to the exit point of the load routine as if the CPU has executed that and exits the fast mode.If there is some error during the load, the fast load mechanism sets PC to the beginning of the method that reports tape error."}},"/howto/always-on-top":{"title":"Keeping the Emulator Always on Top","data":{"":"While working with Klive, you may need to ensure that the Emulator is always at the top. The Klive Emulator window's toolbar has a pin icon that you can toggle. With this icon turned on (it has a highlight border in this state), the Emulator window remains at the top over other windows."}},"/howto/customize-syntax-colors":{"title":"Customizing Syntax Highlighting Colors","data":{"":"Klive IDE allows you to customize the syntax highlighting colors for each programming language. You can modify token colors by creating simple JSON configuration files in your Klive settings folder.","token-color-files-location#Token Color Files Location":"Create your custom token files in the Klive settings folder:\nmacOS/Linux: ~/Klive/\nWindows: C:\\Users\\<YourUsername>\\Klive\\\nThe Klive settings folder is created automatically when you first run Klive. It's the same folder where application settings are stored.","supported-languages#Supported Languages":"You can customize token colors for these languages:\nLanguage\tFile Name\tKlive Z80 Assembly\tkz80-asm.tokens.json\t6510 Assembly (C64)\t6510-asm.tokens.json\tZX Basic Assembly\tzxbasm.tokens.json\tZX Basic\tzxbas.tokens.json\tKlive Script\tksx.tokens.json\tSjASM Plus\tsjasmp.tokens.json","token-file-format#Token File Format":"Each token file uses a simple JSON structure with two main sections:\n{\n  \"darkTheme\": {\n    \"comment\": \"6a9955\",\n    \"keyword\": {\n      \"foreground\": \"569cd6\",\n      \"fontStyle\": \"bold\"\n    },\n    \"identifier\": \"dcdcaa\"\n  },\n  \"lightTheme\": {\n    \"comment\": \"237122\",\n    \"keyword\": {\n      \"foreground\": \"0070c0\",\n      \"fontStyle\": \"bold\"\n    },\n    \"identifier\": \"795e26\"\n  }\n}","token-values#Token Values":"You can specify each token in two ways:\nSimple string (foreground color only):\n\"comment\": \"6a9955\"\nObject (with font style):\n\"keyword\": {\n  \"foreground\": \"569cd6\",\n  \"fontStyle\": \"bold\"\n}","color-format#Color Format":"Colors are specified as 6-digit hexadecimal values without the # prefix:\n\"6a9955\" - greenish gray\n\"569cd6\" - blue\n\"af00db\" - purple","font-styles#Font Styles":"Available font styles:\n\"bold\"\n\"italic\"\n\"underline\"\nOr combinations: \"bold italic\"","example-customizing-z80-assembly-colors#Example: Customizing Z80 Assembly Colors":"Let's customize the syntax highlighting for Klive Z80 Assembly:\nCreate a new file called kz80-asm.tokens.json in your Klive settings folder (~/Klive/ on macOS/Linux).\nAdd the following content:\n{\n  \"darkTheme\": {\n    \"comment\": \"6a9955\",\n    \"keyword\": {\n      \"foreground\": \"569cd6\",\n      \"fontStyle\": \"bold\"\n    },\n    \"identifier\": \"dcdcaa\",\n    \"register\": \"9cdcfe\"\n  },\n  \"lightTheme\": {\n    \"comment\": \"237122\",\n    \"keyword\": {\n      \"foreground\": \"0070c0\",\n      \"fontStyle\": \"bold\"\n    },\n    \"identifier\": \"795e26\",\n    \"register\": \"0089ba\"\n  }\n}\nSave the file and restart Klive IDE.\nYou must restart Klive IDE for token color changes to take effect.","common-token-names#Common Token Names":"","assembly-languages-z80-6510-zxb-assembly-sjasm#Assembly Languages (Z80, 6510, ZXB Assembly, SjASM)":"comment - Comments\nkeyword - CPU instructions (LD, ADD, SUB, etc.)\nstatement - Assembler directives and statements\npragma - Pragma directives\nidentifier - Labels and identifiers\nregister - CPU registers (A, B, C, HL, etc.)\ncondition - Condition flags (Z, NZ, C, NC, etc.)\nfunction - Built-in functions\nmacroparam - Macro parameters\nescape - Escape sequences in strings","zx-basic#ZX Basic":"comment - Comments\nstatement - BASIC keywords (PRINT, LET, etc.)\nidentifier - Variable names\nfunction - Built-in functions\nescape - Escape sequences\nasmdel - ASM block delimiters\ndirective - Preprocessor directives","klive-script#Klive Script":"comment - Comments\nkeyword - Language keywords\nstatement - Statement keywords\nidentifier - Identifiers\nregexp - Regular expressions\nregexp.escape - Regex escapes\nstring.escape - String escapes","partial-customization#Partial Customization":"You don't need to specify all tokens. You can override only the tokens you want to customize:\n{\n  \"lightTheme\": {\n    \"comment\": \"008000\",\n    \"keyword\": \"0000ff\"\n  }\n}\nUnspecified tokens will use their default colors.","tips-for-choosing-colors#Tips for Choosing Colors":"Ensure Contrast: Make sure there's sufficient contrast between foreground and background colors\nTest Both Themes: Define colors for both dark and light themes\nStay Consistent: Use a consistent color scheme across related token types\nStart Simple: Begin by customizing just a few key tokens (comments, keywords, identifiers)","troubleshooting#Troubleshooting":"","colors-not-applied#Colors Not Applied":"Verify the file is in the correct folder with the correct name\nCheck that the JSON syntax is valid (no missing commas, brackets, etc.)\nEnsure you've restarted Klive IDE","invalid-json#Invalid JSON":"Use a JSON validator or editor with JSON support to check for syntax errors.","wrong-colors-displayed#Wrong Colors Displayed":"Verify you're using 6-digit hex values without the # prefix\nCheck that you're editing the right theme section (dark vs light)\nEnsure file permissions allow Klive to read the file\nIf a token file cannot be read or parsed, Klive will silently skip it and use default colors. Check your JSON syntax if your customizations don't appear."}},"/howto/diagnostics":{"title":"Diagnostics","data":{"":"Klive allows you to turn on and off the console log of the Emulator and IDE windows. This log may contain information to help troubleshoot issues with Klive and fix bugs.Use these steps to turn on the console log:\nStart Klive\nIn the IDE window, execute this command:\nset -u devTools.allow 1\nRestart Klive\nAfter these changes, you can use the View | Toggle Developer Tools menu command to display or hide the developer tools (similar to Chrome). The Console tab displays the diagnostics messages, including warnings and errors.You can turn off the console log by executing this command in the IDE window:\nset -u devTools.allow 0\nYou should restart Klive after changing the setting."}},"/howto/file-extensions":{"title":"Changing default file extensions","data":{"":"Klive ships with file extensions associated with particular build systems (languages). You can change the default file extensions and use your own in your projects. In this document, you can learn how to do that.The current version of Klive supports these languages; each has an identifier that you will need when changing file extensions:Klive Z80 Assembler: kz80-asmThis language uses the Z80 syntax of Klive's built-in Z80 Assembler. This compiler is associated with the files with the .kz80.asm extension. The built-in assembler generates debugging information, so source code debugging is available.ZX BASIC (Boriel Basic): zxbasYou can install ZX BASIC on your machine and integrate it with Klive. The ZX BASIC compiler is associated with the .zxbas extension. Klive does not support ZX BASIC source code debugging.ZXB Z80 Assembler: zxbasmWhen you install ZX BASIC on your machine, it comes with its assembler. This compiler is associated with the .zxb.asm extension. Klive does not support ZXB Assembler source code debugging.If you want to change the default file extensions to a particular language, you can use the set interactive command to carry out this change.Let's assume you want to change the .z80.asm file extension used by the Klive Z80 Assembler to accept files with .asm and .kasm. You can carry out this change with these steps:\nIssue the following command in the interactive command prompt:\nset languages.kz80-asm \".asm|.kasm\"\nChange the file extension of the previous source code file (with the Rename context menu) to .asm or .kasm, according to your preference.\nClose the project and open it again.\nSet the renamed file as the build root (if not the build root).\nNow, you can use the compile, inject, and run commands.\nIn the current Klive release, you must close and reopen the project to let the file association settings work. In the future, Klive will not require this extra step.\nYou should use the set command with these parameters:\nset languages.<language-id> \"<file-ext-1>|<file-ext-2>|...|<file-ext-n>\"\nUse the language IDs described above and the file extensions you want to associate with them. The file extensions must be separated by the | character. Do not forget to start the file extension with a dot.When you open the klive.project file, you can see the effect of the set command:\n{\n  \"settings\": {\n    \"languages\": {\n      \"kz80-asm\": \".asm|.kasm\"\n    }\n  }\n}"}},"/howto/ide-startup":{"title":"IDE Startup Options","data":{"":"Klive displays two separate windows, the Klive Retro-Computer Emulator window, and Klive IDE. This arrangement allows you to use Klive in a multi-monitor environment.When you start Klive the first time after installation, only the emulator window appears. You can display the IDE window with the View | Show IDE menu command. When you close Klive, it saves the arrangements of these windows and restores them when you open the program next time.Also, by default, Klive IDE loads the last project you opened when it starts (provided you used a project in the last session). To turn off this feature, toggle the IDE | IDE Settings | Open the last project at startup option.When you load a project, Klive IDE automatically opens its build root file. You can turn off this feature by toggling the IDE | IDE Settings | Open the build root of the project option."}},"/howto/instant-screen":{"title":"Using the Instant Screen","data":{"":"All ZX Spectrum models render the screen simultaneously with the CPU. The screen rendering follows the virtual electron beam (modern LCD and LED displays do not have a physical electron beam). Writing a value to the screen memory or changing some settings will be rendered only when the hardware processes the pixels behind that screen memory value.When you debug your app and modify the screen memory, that modification is not immediately reflected on the emulator screen. When the debugging is paused, screen rendering is paused, too.The Instant Screen feature of Klive allows you to check how the screen looks when the screen rendering does not stop with debugging.You can turn this feature on or off with the highlighted toolbar button:\nWhen the Instant Screen is on, the screen rendering is not paused when the debugging is paused. This way, you can see the screen as it would look if the screen rendering was not paused.\nThe Instant Screen is only active when the machine is paused.\nWhile the machine is paused, you can turn on or off the Instant Screen. The turned-off state shows what the real-time screen would look like."}},"/howto/measure-t-states":{"title":"Measuring T-States","data":{"":"Klive makes it easy to measure the number of T-states (clock cycles) that a piece of code consumes. When you open the CPU panel, it displays a value, TSP, which stands for T-states elapsed since the last pause. Whenever your paused machine continues the code execution (debugging), the next time it gets paused, this value displays the number of T-states used since the last pause.","example#Example":"Take a look at the following code (use the ZX Spectrum 48K model):\nStart:\n    .model Spectrum48\n    .org #8000\n    ld a,2;\t      ; (START)\n    call #1601    ; open the channel\n    ld hl,Message ; HL points the the message string\nNextCh:\n    ld a,(hl)     ; get next character\n    or a\n    jr z,Done     ; we reached the end\n    rst #10       ; display character\n    inc hl        ; next character\n    jr NextCh     ; next loop\nDone:\n    jp #12a9      ; (END)\nMessage:\n    .dm \"\\a\\x0A\\x06\" ; AT 10, 6\n    .dm \"\\p\\x04\"     ; PAPER 4\n    .dm \"Welcome to Klive IDE\"\n    .dm \"\\a\\x0B\\x08\" ; AT 10, 8\n    .dm \"\\p\\x04\"     ; PAPER 4\n    .dm \"\\b\\x01\"     ; BRIGH 1\n    .dm \"(ZX Spectrum 48)\"\n    .db 0x00         ; terminate\nAdd two breakpoints to the lines marked with (START) and (END). Now, run the code in the debugger. When the code execution stops at the first breakpoint, (START), check TSP at the CPU panel:\nClick continue and let your code access the second breakpoint, (END). The TSP value shows the number of T-states that have elapsed since continuing from (START):\nNow you can see how many T-states your code consumes between two breakpoints. This feature is handy when you want to optimize your code for speed.","conditions-influencing-t-states#Conditions Influencing T-States":"There are some things you should consider when measuring the number of T-States:1. Memory contentionThe ZX Spectrum 48K model's CPU and ULA contend for memory access to the $4000-$7fff address range when reading or writing information. The ULA may block the CPU for a few states. So, when your code runs, it may display a bit different TSP values for each run due to memory contention.2. InterruptsIf your code takes more than 20 milliseconds to run, an interrupt request is likely. In this case, the interrupt handler's T-states are also summed up to the TSP value."}},"/howto/shortcuts":{"title":"Changing Keyboard Shortcuts","data":{"":"You can change the shortcuts for a few menu commands and other actions in Klive. This feature is experimental and may change in the future.","update-shortcuts#Update Shortcuts":"You can change a few shortcut keys when using Klive IDE with the set in the interactive command panel:\nset -u shortcuts.<actionId> \"<keyId>\"\nHere, <actionId> is one of the following values (case-sensitive):\nfullScreen. Toggle Full Screen\nstepInto. Debug: Step Into\nstepOver. Debug: Step Over\nstepOut. Debug: Step Out\nThe <keyId> value must be a valid shortcut description using this syntax:You can define custom shortcut keys using the following syntax, compatible with Windows, macOS, and Linux.\n\"modifier+key\"\nUse CmdOrCtrl to define Cmd on macOS and Ctrl on Windows/Linux. Modifiers and keys are case-insensitive.Modifiers:\nModifier\tWindows/Linux\tMacOS\tCmdOrCtrl\tCtrl\t⌘ (Command)\tCtrl\tCtrl\t⌃ (Control)\tCmd\tN/A\t⌘ (Command)\tAlt\tAlt\t⌥ (Option)\tOption\tN/A\t⌥ (Option)\tShift\tShift\t⇧ (Shift)\t\nKeys:\nLetters: A to Z (e.g., \"CmdOrCtrl+S\" for Save)\nNumbers: 0-9\nFunction Keys: F1 to F24\nSpecial Keys:\nEnter, Backspace, Delete, Esc, Tab, Space\nUp, Down, Left, Right\nYou must restart Klive to use the new accelerator keys. Though it may work with the new keys immediately in some environments, the proper reassignment requires a restart.","reset-shortcuts#Reset Shortcuts":"To reset a particular shortcut (let Klive forget about a previously set shortcut), run this command:\nset -u shortcuts.<actionId>","conflicts-with-other-keys#Conflicts with Other Keys":"The Monaco Editor (your code editor) may already use one of your new accelerator keys. If Klive experiences a conflict between a Monaco Editor key and your stepInto, stepOver, or stepOut keys, it will force your keys and oppress the initial Monaco functionality.\nYour OS may override the key combination that you define. In this case, the OS-assigned shortcut key function will prevail."}},"/howto/sp48-custom-rom":{"title":"Using a Custom ROM with ZX Spectrum 48K","data":{"":"Klive lets you replace the built-in ZX Spectrum 48K ROM with any compatible 16K ROM image of your choice. This is useful when you want to test or develop against alternative ROM implementations, patched ROMs, or diagnostic ROMs.\nThis feature is only available for the ZX Spectrum 48K machine model. Other Spectrum models (128K, +2E/+3E) are not affected.","selecting-a-custom-rom#Selecting a Custom ROM":"Open the Machine menu in the Emulator window. Under the ZX Spectrum 48K machine, you will find two ROM-related commands:\nSelect ROM File... — opens a file picker to choose a ROM image\nReset to Default ROM — removes the custom ROM and restores the original Spectrum 48K ROM\nClick Select ROM File... and browse to your ROM file. Klive accepts files with the .rom and .bin extensions (as well as any other extension via the All Files filter).\nThe selected ROM file must be exactly 16,384 bytes (16K) in size. If the file is smaller or larger, Klive will reject it and display an error message.\nOnce a valid file is selected, the machine is restarted automatically with the new ROM. The path to the ROM file is stored in the project configuration, so it will be reloaded automatically the next time you open the project.","resetting-to-the-default-rom#Resetting to the Default ROM":"To go back to the original ZX Spectrum 48K ROM, click Reset to Default ROM in the Machine menu. Klive will ask for confirmation before switching back:\nAre you sure you want to reset to the default ZX Spectrum 48 ROM?\nConfirm with Yes and the machine will restart with the built-in ROM.\nThe Reset to Default ROM menu item is only enabled when a custom ROM is currently active.","how-the-rom-path-is-stored#How the ROM Path Is Stored":"The ROM file path is saved in the config section of the Klive project file (.klive) under the sp48RomFile key. As long as the file exists at that path when the project is reopened, the custom ROM will be used automatically — no extra steps required."}},"/machine-types":{"title":"Machine Types","data":{"":"This document summarizes the machines and models available in Klive IDE.","zx-spectrum-48k#ZX Spectrum 48K":"Machine ID: sp48Available models:\npal: The original ZX Spectrum 48K model with PAL video output.\nntsc: The original ZX Spectrum 48K model with NTSC video output.\npal-16k: The original ZX Spectrum 48K model with PAL video output and 16K RAM.","zx-spectrum-128k#ZX Spectrum 128K":"Machine ID: sp128Available models: Only the original ZX Spectrum 128K model is available.","zx-spectrum-2e3e#ZX Spectrum +2E/+3E":"Machine ID: spp3eAvailable models:\nnofdd: ZX Spectrum +2E (without floppy disk drive).\nfdd1: ZX Spectrum +3E (with a single floppy disk drive).\nfdd2: ZX Spectrum +3E (with two floppy disk drives).","zx-spectrum-next#ZX Spectrum Next":"Machine ID: zxnextAvailable models: Only the original ZX Spectrum Next (KS2) model is available; it is still in development.","cambridge-z88#Cambridge Z88":"Machine ID: z88Available models:\nOZ50: Cambridge Z88 (OZ v5.0 r1f99aaae)\nOZ47: Cambridge Z88 (OZ v4.7)\nOZ40: Cambridge Z88 (OZ v4.0 UK)\nOZ40FI: Cambridge Z88 (OZ v4.01 SE/FI)\nOZ30: Cambridge Z88 (OZ v3.0 UK)\nOZ323IT: Cambridge Z88 (OZ v3.23 IT)\nOZ326FR: Cambridge Z88 (OZ v3.26 FR)\nOZ319ES: Cambridge Z88 (OZ v3.19 ES)\nOZ321DK: Cambridge Z88 (OZ v3.21 DK)\nOZ318DE: Cambridge Z88 (OZ v3.18 DE)"}},"/project-templates":{"title":"Project Templates","data":{"":"TBD"}},"/scripting/overview":{"title":"Scripting Overview","data":{"":"The Klive IDE offers a simple but powerful way to automate tasks with a scripting facility. When you create a new Klive project (or open a folder containing a project), you can create script files with the .ksx file extension.","ksx-files#.ksx Files":"When you add a new .ksx file to your project, the code editor recognizes that and creates a source file using the scripting language. This example shows an empty scripting file:\nWhen you create a simple script, two icons appear in the document tab bar:\nThe first icon executes the script, the second one starts a new Klive instance and starts script execution in debug mode (so that you can debug your script with breakpoints).When running the script, Klive displays a notification bar at the top of the code editor window:","the-output-pane#The Output Pane":"As the script executes, it may display output, including information, errors, and warnings. All of these are displayed in a dedicated Output Pane below the code editor. The script execution keeps track of its output, so that you can see information from any script execution.If you use the $log() API in your script, you can output information to the Output Pane:\nYou can clear the content of the Output Pane with Ctrl+L.","execution-progress#Execution Progress":"Sometimes, you may run a script that takes a long time to complete. Your script can display progress information with a progress bar and a descriptive text. Use the $progress() function:\nIf your script takes too long to complete or enters an infinite loop, the UI hangs too. Be mindful of your script's execution time and handle errors appropriately.","scripting-history#Scripting History":"The Klive IDE automatically keeps track of the scripts you have executed. The latest 50 scripts are displayed in the Scripting History panel. To see it, select the View | Show Scripting History menu command:\nWhen you move your mouse over a script file name in the history, a tooltip shows you the entire path to that file.\nYou can click any item in the history to run that script again."}},"/scripting/syntax":{"title":"Scripting Syntax","data":{"":"The Klive scripting language is a subset of JavaScript. It uses similar expressions and statements, and its evaluation and execution semantics match those of JavaScript.","comments#Comments":"Klive allows you two kinds of comments:\nBlock comments. Any text wrapped between /* and */ is a block comment. Note you cannot nest block comments to each other, and block comments within a string literal are not considered a comment but part of the string.\nEnd-of-line comments. Any text following the // token till the end of the current line is considered a comment.\nExamples:\nconst nums = [ 12, 31, 23, 117 /* , 123 */];\nconst sqrNums = nums.map(n => n * n); // Create the squares of numbers","expressions#Expressions":"Klive scripting expressions follow the syntax of JavaScript expressions. Thus, if you know JavaScript, you can immediately write expressions. The operators and other syntax elements are very close to other \"curly-brace\" programming languages, such as C, C++, Java, and C# (and many others), so you'll get the hang of it in seconds.The JavaScript syntax nature of binding expressions is crucial not just because of the notations. With Klive, you can use all objects available in the global namespace of JavaScript, including the Math object, the fundamental types like Number, String, Date, and many others.You can use these elements in Klive expressions:\nIdentifiers\nLiterals\nNumbers\nStrings\nBoolean values (false and true)\nnull and undefined\nArray literals\nObject literals\nOperators","identifiers#Identifiers":"Klive scripting identifiers may start with one of these characters: $, _,  or any English alphabet letters (from a to z and A to Z). The continuation characters can be of the same set as the start character, and you can also use decimal digits (from 0 to 9). Other characters (such as Unicode letters, symbols, or emojis) are not allowed in identifiers.\nNote: Be aware that Klive uses slightly different identifier syntax than JavaScript.\nHere are a few examples of valid identifiers:\nsaveButton\n$item\n$saveCommand\n_a123","literals#Literals":"You can use the same numbers (integers and floating-point numbers) as in JavaScript, and also the NaN value\n(not-a-number) and Infinity (the result coming from a divide by zero).Array and object literals also allow you the same syntax as in JavaScript. Here are a few samples:\n[1, 2, 3] // An array of three numbers\n[\"Hello\", \"World\", 42, true] // An array of four values\n{a: 1, b: 2, c: 3} // An object with three properties\n{\n  hey: 123,\n  ho: false,\n  hi: 123.e-2,\n  what: NaN,\n  is: [\"this\", \"object-like\"],\n  thing: {\n      that: null,\n      seems: \"completely\",\n      stupid: \"?\"\n  }\n} // A compound object literal\nStrings allow the same characters as JavaScript, including inline Unicode and the following escape characters:\n\\b: Backspace\n\\f: Form Feed\n\\n: New Line\n\\r: Carriage Return\n\\t: Horizontal Tabulator\n\\v: Vertical Tabulator\n\\S: Non-breaking Space\n\\\\: Backslash\n\\': Single quote\n\\\": Double quote\n\\xhh: Hexadecimal character (here, hh represents two hexadecimal digits).\n\\uhhhh: Unicode code point between U+0000 and U+FFFF (here hhhh represents four hexadecimal digits).\n\\u{hHHHHH}: Unicode code point between U+0000 and U+10FFFF (here hHHHHH represents one to six hexadecimal\ndigits).","operators#Operators":"You can use most of the JavaScript operators in Klive scripts. Here, you can read the list of them; the operators are grouped according to their precedence, starting with the highest one:Precedence group #1\nGrouping: ( … ), for example (6 * 7)\nPrecedence group #2\nMember access:  … . …, for example a.b\nComputed member access: … […], for example a[b]\nFunction call: … (…), for example addItem(a, b, c)\nOptional chaining: … ?. …, for example: prop?.value\nPrecedence group #3\nPostfix increment: … ++, for example: counter++\nPostfix decrement: … --, for example: counter--\nPrecedence group #4\nLogical NOT: ! …, for example !value\nBitwise NOT: ~ …, for example ~bits\nUnary plus: + …, for example +b\nUnary negation: - …, for example -b\nPrefix increment: ++ …, for example: ++counter\nPrefix decrement: -- …, for example: --counter\nType query: typeof …, for example typeof myValue\nProperty delete: delete …, for example delete a.prop\nPrecedence group #5\nExponentiation: … ** …, for example, 2 ** 3. (This operator has a right-to-left associativity.)\nPrecedence group #6\nMultiplication: … * …, for example a * 12\nDivision: … / …, for example a / b,\nRemainder: … % … for example value % 2\nPrecedence group #7\nAddition: … + …, for example, a + b\nSubtraction: … - …, for example: present - absent\nPrecedence group #8\nBitwise left shift: … << …, for example value << 3\nBitwise right shift: … >> …, for example other >> 2\nBitwise unsigned shift: … >>> …, for example value >>> b\nPrecedence group #9\nLess than: … < …, for example a < b\nLess than or equal: … <= …, for example a <= b\nGreater than: … > …, for example a > b\nGreater than or equal: … >= …, for example a >= b\nInclusion test: … in …, for example a in [1, 2, 3]\nPrecedence group #10\nEquality: … == …, for example \"2\" == 2\nInequality: … != …, for example \"2\" != a\nStrict equality: … === …, for example \"2\" === 2\nInequality: … !== …, for example \"2\" !== a\nPrecedence group #11\nBitwise AND: … & …, for example apple & pear\nPrecedence group #12\nBitwise XOR: … ^ …, for example sprite ^ mask\nPrecedence group #13\nBitwise OR: … | …, for example walnut | peanut\nPrecedence group #14\nLogical AND: … && …, for example x && y\nPrecedence group #15\nLogical OR: … || …, for example me || you\nNullish coalescing operator: … ?? …, for example value ?? \"\"\nPrecedence group #16\nAssignment: … = …, for example, i = 2\nAddition assignment: … += …, for example, i += 1\nSubtraction assignment: … -= …, for example, i -= 1\nExponentiation assignment: … **= …, for example, i **= 3\nMultiplication assignment: … *= …, for example, i *= 2\nDivision assignment: … /= …, for example, i /= 4\nRemainder assignment: … *= …, for example, i %= 16\nBitwise left shift assignment: … <<= …, for example, i <<= 1\nBitwise right shift assignment: … >>= …, for example, i >>= 4\nBitwise unsigned right shift assignment: … >>>= …, for example, i >>>= 8\nConditional (ternary) operator: … ? … : …, for example a % 2 ? \"off\" : \"on\"\nArrow function: … => …, for example, (a, b) => a * b\nSpread: ... …, for example, ... [1, 2, 3]\nPrecedence group #17\nComma/Sequence: … , …, for example: a, b, c, other\nNote that you cannot use these JavaScript operators with binding expressions: new, void, await, instanceof, assigment operators (none\nof them), yield, and yield*.","arrow-functions#Arrow Functions":"Klive allows you to define arrow functions. Though you can define arrow functions in attribute or property values. Arrow functions have the same syntax as in JavaScript. Here are a few examples:\n() => Math.sqrt(Math.PI);\nThis arrow function has no arguments. It retrieves the square root of PI.\n(a, b) => Math.sqrt(a ** 2 + b ** 2);\nThis arrow function calculates the hypotenuse of a right-angled triangle from its leg dimensions. It has two arguments, a and b, the leg dimensions.\n(n) => {\n  let sum = 0;\n  for (let i = 1; i < n; i++) sum += i;\n  return sum;\n}\nThis arrow function uses statements to calculate the sum of numbers from one to the given n. As it has a body (and not just a single expression), it uses the return statement to retrieve the result.Arrow function arguments support the destructure pattern. You can learn more about them here.Here is an example:\n({x, y}) => x ** 2 + y ** 2;\nAssuming you assigned the arrow function to the myCalc variable, this is how you can invoke it from an event handler:\nconst coords = { x: 12, y: -23 };\n// ...\nmyCalc(coords);","statements#Statements":"Klive scripting provides several statements to express programming logic. Most of these statements have the same semantics as their counterpart in JavaScript.\nNote: The statements can be optionally closed with a semicolon. There are a few contexts where the closing semicolons are required to avoid ambiguity. It is a suggested practice to conclude statements with a semicolon always.","variable-declarations#Variable declarations":"You can use the let and const statements to declare variables and optionally set their initial values. While an initial value is optional for the let statement, it is required for const. You can change the values of variables declared with let. However, the value of const variables can be set only once, at their initialization. The engine raises an error if you try to modify the value of a variable.Here are a few examples:\nlet x; // No initial value\nlet y = 0, z; // Multiple declarations\nlet sum = 0; // Initialize sum to zero\nconst factor = 1.5; // Factor cannot be changed later\nNote: Klive scripting does not support the var keyword; it allows only let and const.","destructuring#Destructuring":"You can use destructure operators with variable expressions. Klive supports a similar syntax to JavaScript; however, it does not support extracting rest values and providing default values.Examples:\nconst {a, b} = someObject;\n// const a = someObject.a, b = someObject.b\nconst {a, b, other: { c, d }} = someObject;\n// const a = someObject.a, b = someObject.b, c = someObject.other.c, d = someObject.other.d\nconst {a, b:myB} = someObject;\n// const a = someObject.a, myB = someObject.b\nlet {a, b, other: { c:myC }} = someObject;\n// let a = someObject.a, b = someObject.b, myC = someObject.other.c\nconst [a, b] = someArray;\n// const a = someArray[0], b = someArray[1}\nconst [a, b,, c] = someArray;\n// const a = someArray[0], b = someArray[1}, c = someArray[3]\nlet [a,,, {b:myB, c}] = someArray;\n// let a = someArray[0], myB = someArray[3].b, c = someArray[3].c","function-declarations#Function Declarations":"You can define functions in Klive scripting. The syntax is similar to JavaScript. You can define functions with or without parameters, and you can use the return statement to return a value from the function.Here are a few examples:\nfunction add(a, b) {\n  return a + b;\n}\nfunction greet(name) {\n  return \"Hello, \" + name + \"!\";\n}\nNote: Klive does support declaring functions within functions.","empty-statement#Empty Statement":"An empty statement is used to provide no statement, although the JavaScript syntax would expect one. The script indicates it with a semicolon (;).\nHint: It is a good idea to comment on the intentional use of the empty statement, as it is not apparent to distinguish from a usual semicolon.\nExample:\n// This for loop has no iteration body\nfor (let i = 0; i < 10; i++); // The closing \";\" indicates the empty statement","block-statement#Block Statement":"You can group multiple statements into a single block statement, wrapping them between { and }. For example, you can put multiple individual statements into the body of a for-loop:\nlet sum = 0;\nfor (let i = 0; i < 10; i++) {\n  sum += i;\n  console.log(\"Current sum is\", sum);\n}\nBlock statements have their separate identifier scope. Variables declared within them will hide external variables with the same name. For example, in the following sample, the log output will show 42 in the first line and 1234 in the second, as the declaration of myNumber in the block statement hides myNumber declared outside of the block statement:\nlet myNumber = 1234;\n{\n  let myNumber = 42;\n  console.log(myNumber); \n}\nconsole.log(myNumber);\nNote: You do not need to put a closing semicolon after a block statement.","expression-statement#Expression Statement":"When you write an expression in the context of other statements, Klive represents that expression as an expression statement. For example, here, the highlighted line are expression statements:\nlet sum = 0;\nfor (let i = 0; i < 10; i++) {\n  sum += i;\n  console.log(\"Current sum is\", sum);\n  123 + 456;\n}\nNote: Though there is no use in evaluating the value of 123 + 456 expression statement, the engine does that (in every iteration) and omits the result.","the-ifelse-statement#The if...else Statement":"The if...else statement executes a statement if a specified condition is truthy. If the condition is falsy, another statement in the optional else clause will be executed.\nNote: A truthy value is a value that is considered true when encountered in a Boolean context: All values are truthy unless they are defined as falsy. That is, all values are truthy except false, 0, -0, \"\", null, undefined, and NaN.\nHere are a few examples:\n// Example #1\nif (a > 3) doThis();\n// Example #2\nif (a > 3) doThis(); else doThat();\n// Example #3\nif (a > 3) {\n  doThisFirst();\n  andThen()\n}\nelse doThat();\nNote: Example #2 shows that you need a closing semicolon before else, as the consequent (\"then\") branch of the if...else statement is a single (non-block) statement.","the-while-statement#The while Statement":"The while statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.Here are a few examples:\n// Example #1\nlet sum = 0;\nlet counter = 1;\nwhile (counter <= 10) sum += counter++; \n// Example #2\nlet sum = 0;\nlet counter = 1;\nwhile (counter <= 10) {\n  sum += counter;\n  counter++;\n}","the-dowhile-statement#The do...while Statement":"The do...while statement creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.\n// Example #1\nlet sum = 0;\nlet counter = 1;\ndo sum += counter++; while (counter <= 10)  \n// Example #2\nlet sum = 0;\nlet counter = 1;\ndo {\n  sum += counter;\n  counter++;\n} while (counter <= 10)","the-for-statement#The for Statement":"The for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.\nInitialization. An expression or variable declaration that is evaluated once before the loop begins. This expression may optionally declare new variables with the let keyword; these variables are local to the loop.\nCondition. An expression to be evaluated before each loop iteration. If this expression evaluates to true, the loop's body is executed. Otherwise, execution exits the loop and goes to the first statement after the loop construct. This conditional test is optional. If omitted, the condition always evaluates to true.\nUpdate. An optional expression to be evaluated at the end of each iteration before the next evaluation of the condition.\nExamples:\n// Example #1\nlet sum = 0;\nfor (let i = 0; i < 10; i++) {\n  sum +=i;  \n}\n// Example #2\nlet sum = 0;\nlet i;\nfor (i = 0; i < 10; i++) {\n  sum += i;  \n}\nYou can declare multiple variables in the loop initialization and add multiple update expressions (as a sequence expression):\nlet sum = 0;\nfor (let i = 0, j = 3; i < 10; i++, j += 3) {\n  sum += i + j;  \n}","the-forin-statement#The for...in Statement":"The for...in statement iterates over all enumerable string properties of an object including inherited enumerable properties.\nVariable. This variable receives a string property name on each iteration. It may be either a declaration with const, or let, or a variable name. Variables declared with const or let are local to the for...in loop's scope.\nObject. An object whose enumerable properties are iterated over.\nExamples:\nconst obj = { a: 12, b: 34, c: \"Hello\" }\nfor (const key in obj) {\n  console.log(obj[key]);\n}\nThis code snippet will display this output:\n12\n34\nHello","the-forof-statement#The for...of Statement":"The for...of statement executes a loop that operates on a sequence of values sourced from an iterable object (such as Array, String, Map, Set, and others.\nVariable. This variable receives a value from the sequence on each iteration. It may be either a declaration with const, or let, or a variable name. Variables declared with const or let are local to the for...in loop's scope.\nObject. An iterable object. The source of the sequence of values on which the loop operates.\nExamples:\nconst values = [1, 2, 3, 5, 8, 13, 21]\nfor (const value of values) {\n  console.log(value);  \n}","the-break-statement#The break Statement":"The break statement terminates the current loop or switch statement and transfers program control to the statement following the terminated statement.Examples:\n// Sum up numbers from 1 to 10\nlet sum = 0;\nlet counter = 1;\nwhile (true) {\n  if (counter > 10) break;\n  sum += counter++;\n}\n// Dispatch options\nswitch (option) {\n  case 0:\n    doThis();\n    break;\n  case 1:\n    doThat();\n    break;\n  case 2:\n    doSpecial();\n    break;\n  default:\n    doExceptional();  \n    break;  \n}","the-continue-statement#The continue Statement":"The continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.In contrast to the break statement, continue does not terminate the execution of the loop entirely, but instead:\nIn a while or do...while loop, it jumps back to the condition.\nIn a for loop, it jumps to the update expression.\nIn a for...in, or for...of loop, it jumps to the next iteration.\nExample:\n  \nlet sum = 0;\nfor (let i = 1; i <= 100; i++) {\n  if (i % 3 === 2) continue;\n  sum += i;\n  console.log(\"Current sum\", sum);\n}","the-return-statement#The return Statement":"The return statement ends function execution and specifies a value to be returned to the function caller. If the value is omitted, undefined is returned.Examples:\n(n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) sum += i;\n  return sum;\n}\n(n) => {\n  if (n % 3 === 2) return;\n  console.log(\"Remainder of \" + n + \" is not equal to 2\");\n}","the-switch-statement#The switch Statement":"The switch statement evaluates an expression, matching the expression's value against a series of case clauses, and executes statements after the first case clause with a matching value until a break statement is encountered. The default clause of a switch statement will be executed if no case matches the expression's value.If the control flow of the executing case clause does not reach a break statement concluding the particular case, the execution continues with the subsequent case clause until there remains any.Examples:\n// Dispatch options\nswitch (option) {\n  case 0:\n    doThis();\n    break;\n  case 1:\n    doThat();\n    break;\n  case 2:\n    doSpecial();\n    break;\n  default:\n    doExceptional();  \n    break;  \n}\n// Case 0 flows to case 1\nswitch (option) {\n  case 0:\n    doThis();\n  case 1:\n    doThat();\n    break;\n  case 2:\n    doSpecial();\n    break;\n}\n// Multiple cases with the same execution\nswitch (option) {\n  case 0:\n  case 3:\n  case 6:\n    doThis();\n    break;\n  case 1:\n  case 2:\n  case 5:\n    doThat();\n    break;\n  default:\n    doExceptional();  \n    break;  \n}","the-throw-statement#The throw Statement":"The throw statement throws a user-defined error value. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the code will terminate.The throw keyword can be followed by any kind of expression.Examples:\n(values) => {\n  if (!values.every(v => typeof v === \"number\")) {\n    throw \"Can only add numbers\";\n  }\n  return values.reduce((a, b) => a + b);\n}\nconst handler = (err, data) => {\n  if (err) {\n    throw err;\n  }\n  console.log(data);\n}","the-trycatch-statement#The try...catch Statement":"The try...catch statement comprises a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code in the finally block will always be executed before the control flow exits the entire construct.The catch block can have an optional identifier to hold the caught error for the associated catch block. If the catch block does not use the exception's value, you can omit the identifier.Examples:Unconditional error\ntry {\n  throw \"myError\";\n} catch (e) {\n  // Log the error\n  console.log(e);\n}\nLog:\nmyError\nTesting the error condition\ntry {\n  readData(); // may throw three types of exceptions\n} catch (e) {\n  if (e === \"DataReadError\") {\n    // Statements to handle data read errors\n  } else if (typeof e === \"number\") {\n    // Statements to handle a particular numeric error code\n  } else if (e.errorType) {\n    // Statements to handle some other error\n  } else {\n    // Statements to handle any unspecified exceptions\n    console.log(e);\n  }\n}\nNested try blocks\ntry {\n  try {\n    throw \"Something strange\";\n  } catch (e) {\n    console.error(\"inner\", e);\n    throw e;\n  } finally {\n    console.log(\"finally\");\n  }\n} catch (e) {\n  console.error(\"outer\", e);\n}\nLog:\ninner Something strange\nfinally\nouter Something strange\nReturning from finally\n(() => {\n  try {\n    try {\n      throw \"weird\";\n    } catch (e) {\n      console.error(\"inner\", e);\n      throw e;\n    } finally {\n      console.log(\"finally\");\n      return;\n    }\n  } catch (e) {\n    console.error(\"outer\", e);\n  }\n})();\nLog:\ninner weird\nfinally"}},"/working-with-ide/basic":{"title":"The BASIC Listing","data":{"":"One of Klive IDE's unique features is that it can list the BASIC program from within the running machine's memory. You can access this view with the IDE | Show BASIC Listing menu command:\nThe toolbar of the view contains these controls from left to right:\nRefresh button. You can refresh the BASIC list view.\nCopy to Clipboard. This button copies the current BASIC list to the clipboard.\nAuto Refresh. With this switch turned on (on by default), the IDE automatically reads and displays the current BASIC listing from the computer (even during program loading).\nShow non-printable. When this switch is turned on (off by default), the non-printable characters are displayed with their two-digit hexadecimal code with a $ prefix and shaded background.\nUse ZX Spectrum font: This switch allows you to use the ZX Spectrum font instead of Klive's default monospace font.\nIf the BASIC listing is not available (or it is corrupted), this view may display one of these messages:\nMachine OS has not been initialized yet: This message appears while the machine's operating system is booting. It disappears when the machine reaches its main execution cycle.\nBASIC program area is empty: There is no BASIC program to list.\nBASIC code corrupted or partially loaded: When the BASIC program area is corrupted (some unexpected data is found) or the program is being loaded, the view displays this message at the location of the error."}},"/working-with-ide/breakpoints":{"title":"The Breakpoints View","data":{"":"With this view, you can overview and manage the breakpoints used for debugging. You can find this view in the Debug activity tag with the BreakPoints header:\nThis view displays all breakpoints you created with interactive commands or in the source code. Each line represents a particular breakpoint with this information:\nA checkbox shows if the current breakpoint is enabled or disabled. You can set this status by toggling the checkbox.\nA filled circle representing the status of a breakpoint:\ncyan: This breakpoint has been created with an interactive command.\nred: This breakpoint has been created in the source code.\norange: This color indicates that a breakpoint has been created in the source code but not resolved to an actual address as the code has not been compiled (after opening the project or editing the code).\ngray: This breakpoint has been disabled.\nAn icon representing the breakpoint type\nThe breakpoint's address or source code location\nOther information (such as the disassembly at the location)","manipulating-breakpoints#Manipulating Breakpoints":"When you hover the mouse over the first two icons, they display additional information:\nWith the right mouse button, you can remove an existing breakpoint. If you want to deactivate a breakpoint temporarily, disable it by clearing the checkbox on its left.","resolved-source-code-breakpoints#Resolved Source Code Breakpoints":"When you open a project or modify an assembly source code file, the source code breakpoint addresses are not resolved to an actual physical address. The orange color of a source code breakpoint indicates this status:\nSource code breakpoints are resolved to a CPU address after compilation, and this address is displayed with the breakpoint. The following figure shows that the last two source code breakpoints display their resolved CPU address after the compilation.","breakpoint-types#Breakpoint Types":"The second icon of the breakpoint item displays its type. There are five types of breakpoints (depending on the operation triggering the machine to pause), as the following figure shows:\nThese are the available breakpoint types (from top to bottom in the figure):\nI/O read. This breakpoint is triggered when a particular I/O port has been read. The displayed address is the 16-bit I/O port address.\nI/O write. This breakpoint is triggered when a particular I/O port has been written. The displayed address is the 16-bit I/O port address.\nExecution. This breakpoint is triggered when the PC register reaches the specified address.\nMemory read. This breakpoint is triggered when a particular 16-bit memory address (including instruction fetches) has been read.\nMemory write. This breakpoint is triggered when a particular 16-bit memory address has been written."}},"/working-with-ide/build-system":{"title":"The Build System","data":{"":"Klive IDE has a scripting system with a JavaScript-like syntax. When you create files with the .ksx extension, the IDE considers them script files and allows you to run them.TBD"}},"/working-with-ide/commands":{"title":"Using IDE Commands","data":{"":"The IDE provides you access to several command functions. To reach them, press F1 (or Command+Shift+P on Mac) and type \"ide\" to list all IDE commands. For example, this command lists all break points you set in your code files:\nIn many cases, you can access these commands with menu items, toolbar buttons, or keyboard shortcuts."}},"/working-with-ide/cpu":{"title":"The CPU View","data":{"":"You can find this view in the Debug activity tag with the Z80 CPU header:\nWhen you hover the mouse over the information items, they display a tooltip with numbers in multiple radices (whenever that has a meaning).You can read this information in this panel:\nZ80 registers: All the standard Z80 registers (moving the mouse over the values will display LSB and MSB separately). The WZ is an internal Z80 register, often called MEMPTR.\nLMR: Last value read from memory\nLMW: Last value written to memory\nIRV: Last value read from an I/O port\nIWV: Last value written to an I/O port\nIM: Current interrupt mode\nSNZ: Is the CPU in snoozed mode (Cambridge Z88 uses this CPU mode)\nIFF1:  Interrupt flip-flop #1\nIFF2:  Interrupt flip-flop #2\nINT: Is the INT signal active?\nHLT: Is the CPU halted?\nCLK: The current clock count since the last machine start\nTSP: T-states elapsed since the last pause. You can use this value to check the number of T-states used between two pauses."}},"/working-with-ide/disassembly":{"title":"The Disassembly View","data":{"":"You can view the disassembly of the memory with the IDE | Show Disassembly menu command:\nBesides viewing the disassembly, you can add breakpoints by clicking with the right mouse button to the left of the line address (see address line 0007):\nWhen you click an existing breakpoint with the right mouse button, the IDE removes it.\nCurrently, you can only add execution breakpoints to the Disassembly view. With interactive commands (see the ones starting with bp-), you can create memory and I/O operations breakpoints.\nBy default, when you display the disassembly, it uses the current value of the PC (Program Counter) register and disassembles up to 1024 bytes of code.Turn off the Follow PC option to disassemble the entire memory (or a selected bank). With this option turned off, models supporting memory paging display a second row of options:","display-options#Display Options":"The Disassembly View provides a few options to display and navigate the memory contents:\nDecimal: Turns on or off the decimal display (off, by default). When turned off, memory addresses, opcodes, and instructions are displayed with decimal numbers; otherwise, they are hexadecimal.\nRam: This option (on, by default) allows you to disassemble the RAM's contents.\nScreen: This option (off, by default) lets you disassemble the screen memory's ($4000-$5AFF) contents.\nBank: This option (on, by default) allows you to turn the display of bank labels on or off in front of memory addresses. This option is available only for models that support memory paging.\nGo To: Type an address into this box and press Enter to jump to the particular address. If the particular address is not at a disassembled instruction's boundary, it will settle at the next instruction. In decimal mode, you can type decimal addresses; otherwise, use hexadecimal addresses.\nA little icon (up or down arrow) is before the Go To address box. Unless the machine is paused, this icon is disabled. When the machine is in a paused state, clicking the button jumps to the disassembly at the address pointed by the PC. The direction of the arrow indicates where the PC position can be found relative to the current view.","banked-disassembly-views#Banked Disassembly Views":"When your model supports memory paging, a new switch, 64K View, is displayed in the second header row. It is turned on by default, and the current 64K memory (according to the current memory page settings) is displayed. When you turn this option off, you can choose the bank to display (ROM pages or RAM banks, depending on the machine type) from the Select bank dropdown. The Disassembly View will display only the disassembled contents of that segment, even if that segment is not paged in.The Offset dropdown lets you select a disassembly offset from one of the 8K page boundaries. This selection may help set a disassembly base address to emulate the page's location.","machine-specific-memory-partitions#Machine-Specific Memory Partitions":"","zx-spectrum-48k#ZX Spectrum 48K":"This model supports only the 64K view.","zx-spectrum-128k#ZX Spectrum 128K":"The ROM 0 and ROM 1 segments allow you to access the two ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 or BANK 7 segments.","zx-spectrum-2e-3e#ZX Spectrum +2E, +3E":"The ROM 0... ROM 3 segments allow you to access the four ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 ... BANK 7 segments.","cambridge-z88#Cambridge Z88":"You can access one of the available 256 banks (16K each) by selecting the bank's index from the dropdown.","zx-spectrum-next#ZX Spectrum Next":"The dropdown provides these options to access memory segments:\nIDs from 00 to DF (000 to 224 in decimal view) to select an 8K RAM bank. The view does not support displaying them as 16K banks.\nM0, M1 ... MF: The 16 DivMMC RAM banks (8K each)\nNROM0 ... NROM3: The ROM pages of the ZX Next OS (16K each)\nALTR0, ALTR1: The alternate ROM pages (16K each)\nDivMR: The DivMMC ROM (8K)"}},"/working-with-ide/editing-code":{"title":"Editing code","data":{"":"Klive IDE leverages Monaco editor (the one in Visual Studio Code) as its code editor, so search for VS Code documentation about basic usage patterns. While the editor in Klive uses the same experience as in VS Code, it does not have the tools that language servers and VS Code extensions provide.You can set some preferences with the menu items within the View | Editor Options menu.\nThese settings are saved to your project and the Klive settings file. When you load a project, the project settings override the previous Klive settings.\nThese are the preferences you can set:\nFont size: The relative font size of the editor.\nEnable AutoComplete. The editor provides AutoComplete patterns from samples you typed in earlier. I suggest you keep this option turned off. In the future, Klive may include its smart AutoComplete functionality, which is aware of the Z80 assembly syntax.\nEnable Selection Highlight. This option highlights all other occurrences of the selected text in the editor.\nEnable Occurrences Highlight. This option highlights all other occurrences of the symbol (e.g., variable or function name) under the cursor without needing to select it.\nDetect Indentation. Use this option to automatically set (and override) the Tab Size and Insert Spaces instead of Tabs options based on the file's content (i.e., it detects indentation style from the text).\nInsert Spaces instead of Tabs. This option controls whether pressing the Tab key inserts actual spaces or a tab character.\nRender Whitespaces. This option controls whether and how whitespace characters (spaces, tabs) are visibly rendered in the editor.\nTab Size. The tabulator size to use with the editor."}},"/working-with-ide/exporting-code":{"title":"Exporting Code","data":{"":"When your code is ready to be tested on actual hardware or with another emulator, you can export it with the Build | Export code menu command. This command pops up a dialog:","the-export-dialog#The Export Dialog":"Before exporting the code, you can specify several parameters:\nExport format. You can select one of these file formats from the dropdown to export your code:\n**TAP format: Standard .tap file format\n**TZX format: Standard .tzx file format\n**Intel HEX format: Standard text file format you can use with classic tools (e.g., EPROM burners).\nExport folder. An optional folder to save the exported file. If you do not specify this folder, the IDE will save the exported file into the KliveExports folder under your home directory.\nExport file name. The filename for the export is mandatory. If you do not specify a file name extension, Klive will add it according to the selected export format.\nProgram name. The name to add to the tape file header. If you leave it empty, the export infers the program name from the export file name.\nCreate BASIC loader. (This option is not available with Intel HEX format.) If you check this option, the export creates a BASIC loader for your code; otherwise, it creates a simple file you can load as a port of your custom loader.\nIf you are about to export the code with a BASIC loader, you can set other options:\nAdd CLEAR. Adds a CLEAR statement to the loader.\nAdd PAUSE 0. Adds a PAUSE 0 statement to the loader. When your code has been completely loaded, it waits for a keypress before running.\nUse a single code block. If this option is checked, your separate code segments (according to their ORG directives) are merged in a single block, gaps filled with zeros. Otherwise, the export creates a separate code file for each code block.\nSet border color. You can specify a color for the border during the load operation (while loading the app's code files).\nScreen file. You can optionally add a screen file for your code. The IDE accepts these formats:\nA .tap or .tzx file that is created when saving a screen (with the SAVE \"<name>\" SCREEN$ command)\nA standard 6912 bytes long .scr file with the raw screen contents.\nA standard 7040 bytes long .scr file with 128 bytes +3DOS header and the raw screen contents. Klive does not test the +3DOS header; it just uses the raw screen bytes.\nCode start address. The IDE infers the code start address from your code (according to the ORG, XORG, ENT, or XENT pragmas), so you can leave this field empty. However, you can specify another start address by typing a decimal value here. This address cannot point to the ROM; it must be between 16384 and 65535.","the-basic-loader#The BASIC Loader":"According to your options, Klive generates a BASIC loader for the ZX Spectrum 48K/128K/+2/+3 models. This loader ensures that other files (screen, code) are loaded in the correct order (and the right memory location).The ZX Spectrum 128K models and above support memory paging, and you can compile multi-bank code with the BANK pragma. When your code uses multiple banks, the loader ensures they are loaded into the appropriate bank.With the following steps, you can examine the structure of the loader:\nTurn off the fast LOAD mode in the emulator toolbar (with the rocket icon).\nLoad the exported file. When the first block is loaded, pause the machine.\nYou can view the code with the IDE | Show BASIC Listing menu command.","overriding-the-current-tape-file#Overriding the Current Tape File":"You can set the current tape file with the Machine | Select tap file menu command. This command loads the selected file and sends it to the emulator.When you export a file in the IDE and overwrite the currently selected tape file, the emulator will still use the contents of the previously selected tape file, as the file update does not send the new file contents to the emulator. However, the emulator picks up the updated file when you click the rewind button in the toolbar (or use the Machine | Rewind tape menu function)."}},"/working-with-ide/ide-settings":{"title":"IDE Settings","data":{"":"TBD"}},"/working-with-ide/memory":{"title":"Displaying the Memory Contents","data":{"":"You can view the contents of the memory with the IDE | Show Machine Memory menu command that displays the contents of the full 64K memory addressable by Z80:\nWhile the ZX Spectrum 48K does not support paging, other models do. When you use them, you can choose to show only the contents of a particular bank:\nSome models (such as ZX Spectrum Next or Cambridge Z88) offer you many banks to choose from:","display-options#Display Options":"The Memory View provides a few options to display and navigate the memory contents:\nDecimal: Turns on or off the decimal display (off, by default). When turned off, memory addresses and content are displayed with decimal numbers; otherwise, they are hexadecimal.\n2 Columns: Depending on this option, you can display one or two columns in a single row (two columns by default).\nChars: This toggles the display of the character view for a particular memory section (on, by default).\nBank: This option (on, by default) allows you to turn the display of bank labels on or off in front of memory addresses. This option is available only for models that support memory paging.\nGo To: Type an address into this box and press Enter to jump to the particular address. Though memory sections are aligned to 8-byte boundaries when jumping to a new address, the designated address's content flashes for about 3 seconds to let you identify the jump target. In decimal mode, you can type decimal addresses; otherwise, use hexadecimal addresses.","banked-memory-views#Banked Memory Views":"A new switch, 64K View, is displayed in the second header row when your model supports memory paging. It is turned on by default, and the current 64K memory (according to the current memory page settings) is displayed. When you turn this option off, you can choose the bank to display (ROM pages or RAM banks, depending on the machine type) from the Select bank dropdown. The Memory View will display only the contents of that memory even if that segment is not paged in.","edit-memory-content#Edit Memory Content":"When you hover the mouse over a memory address that represents RAM, you can edit its content by right-clicking it:\nYou can specify the new value with decimal numbers, hexadecimal numbers (use the $ prefix), or binary numbers (use the % prefix). You can use spaces to group digits; the IDE will remove them.If the specified value cannot be parsed, a red border marks the invalid state. Clicking the Set button or pressing Enter will set the contents to the specified value.With this dialog, you can write 1, 2, 3, or 4 consecutive bytes into the memory (select the size from the dropdown). The given value is entered as a little-endian value (LSB first). However, checking the Big-endian write flag stores the MSB first. This flag is available only for 2, 3, and 4-byte values.\nWriting into the memory can be done while the machine is running. In this case, the machine may overwrite the modified value you set with this dialog! If necessary, pause the machine before setting the content of a particular memory address.\nThough it seems unlogical, this command allows you to write memory contents while the machine is stopped. This feature may benefit several machines (such as Z88) with flash drives used as the operational memory.","machine-specific-memory-partitions#Machine-Specific Memory Partitions":"","zx-spectrum-48k#ZX Spectrum 48K":"This model supports only the 64K view.","zx-spectrum-128k#ZX Spectrum 128K":"The ROM 0 and ROM 1 segments allow you to access the two ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 or BANK 7 segments.","zx-spectrum-2e-3e#ZX Spectrum +2E, +3E":"The ROM 0... ROM 3 segments allow you to access the four ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 ... BANK 7 segments.","cambridge-z88#Cambridge Z88":"You can access one of the available 256 banks (16K each) by selecting the bank's index from the dropdown.","zx-spectrum-next#ZX Spectrum Next":"The dropdown provides these options to access memory segments:\nIDs from 00 to DF (000 to 224 in decimal view) to select an 8K RAM bank. The view does not support displaying them as 16K banks.\nM0, M1 ... MF: The 16 DivMMC RAM banks (8K each)\nNROM0 ... NROM3: The ROM pages of the ZX Next OS (16K each)\nALTR0, ALTR1: The alternate ROM pages (16K each)\nDivMR: The DivMMC ROM (8K)"}},"/working-with-ide/project-explorer":{"title":"The Project Explorer","data":{"":"The Project Explorer is the left-side panel that shows the files and folders in your currently open Klive project. It lets you navigate, open, create, rename, and delete project files, and it automatically picks the right viewer or editor for each file type.","opening-the-project-explorer#Opening the Project Explorer":"Click the Explorer icon (the stacked pages icon) in the activity bar on the far left of the IDE, or use the View | Project Explorer menu command. If no project is open, the panel will be empty. Open or create a project first via File | Open Folder or File | New Project.","the-explorer-tree#The Explorer Tree":"The tree shows your project root and all subfolders beneath it. Folders can be expanded and collapsed by clicking their arrow. Clicking a file opens it in the document area on the right, using the viewer or editor that matches its file type.The file icon next to each entry indicates both the file type and the viewer that will be used to open it.","context-menu-actions#Context Menu Actions":"Right-clicking a folder or file in the Explorer shows a context menu with the following actions:\nNew File — Creates an empty file inside the selected folder.\nNew Folder — Creates a new subfolder.\nRename — Renames the selected file or folder in place.\nDelete — Permanently removes the file or folder from disk.\nSet as Build Root — (Source files only) Marks the selected file as the entry point for the build system.\nUse Rename to change a file's extension if you want to switch which editor or viewer Klive uses to open it.","file-type-binding#File Type Binding":"Klive automatically selects an editor or viewer based on the file extension when you open a file. The rules are checked in order; the first match wins.","source-code-editor#Source Code Editor":"The following extensions open in the Code Editor (Monaco-based), with the corresponding language mode activated:\nExtension\tLanguage\t.kz80.asm, .asm\tKlive Z80 Assembler\t.zxb.asm\tZXB Z80 Assembler\t.zxbas, .bas\tZX BASIC (Boriel Basic)\t.sjasm\tSjASMPlus Z80 Assembler\t.6510.asm\t6510 Assembler\t.c, .h\tC / C Header\t.lua\tLua\t.ksx, build.ksx\tKSX Script","text-editor#Text Editor":"Files with the .txt extension open in a plain Text Editor.Files with no registered extension are probed when first opened. If the content is valid UTF-8 text, Klive opens them in the Text Editor and remembers that choice for the rest of the session.","binary-dump-viewer#Binary Dump Viewer":"The Binary Dump Viewer shows the raw hexadecimal content of a file alongside its ASCII character representation. It supports a two-column layout, decimal or hexadecimal address and value display, a Go To address box, and drag-to-pan scrolling.The following extensions open in the Binary Dump Viewer:\nExtension\tDescription\t.bin\tGeneric binary output file\t.rom\tROM image\t\nFiles with no registered extension that are not detected as text are also opened in the Binary Dump Viewer automatically.","image-viewer#Image Viewer":"The Image Viewer displays images in read-only mode. It supports multiple view modes selectable from a dropdown in the header:\nOriginal size — Displays the image at its natural pixel dimensions, scaled by the current zoom factor.\nFit Width — Stretches the image horizontally to fill the panel width.\nFit Page — Scales the image proportionally so it fits entirely within the visible area.\nZoom controls (zoom in/out buttons and a clickable zoom label that resets to 100%) are active in Original size mode. The image can be panned by clicking and dragging when it is larger than the visible area.The following extensions open in the Image Viewer:\nExtension\tMIME type\t.png\tPNG\t.jpg, .jpeg\tJPEG\t.gif\tGIF\t.bmp\tBMP\t.webp\tWebP\t.svg\tSVG\t.ico\tWindows Icon\t.tiff, .tif\tTIFF","specialised-binary-viewers#Specialised Binary Viewers":"Klive includes dedicated read-only viewers for a number of well-known binary formats:\nExtension\tViewer\t.tap, .tzx\tTAP / TZX Tape Viewer\t.dsk\tDisk Image Viewer\t.nex\tNEX File Viewer\t.z80, .sna\tZ80 / SNA Snapshot Viewer\t.scr\tZX Spectrum Screen Viewer\t.shc, .shr, .slr, .sl2\tZX Spectrum Next Screen Viewers\t.pal, .npl\tPalette Editor\t.nxi\tNXI Layer Editor\t.spr\tSprite Editor\t.vid\tVideo Viewer","unknown-files#Unknown Files":"If a file's extension does not match any registered type, Klive probes the file content when it is first opened:\nIf the content is valid UTF-8 text, the file is opened in the Text Editor.\nOtherwise, it is treated as binary and opened in the Binary Dump Viewer.\nThe detected type is remembered for the rest of the session and is reflected in the icon shown in the Explorer tree.\nYou can change the default file extensions used by the built-in assembler languages. See Changing default file extensions for details."}},"/working-with-ide/run-debug":{"title":"Running and Debugging code","data":{"":"Klive displays a toolbar at the top of the screen in the Emulator window and another in the IDE window. They have the same functionality: they control the emulated machine. The toolbar contains some emulator and IDE-specific functions; however, the machine control commands use the same components.This screen shows these controls in the emulator:\nMove the mouse over a particular control; it displays a tooltip to let you know its function.The leftmost button starts the machine in the selected mode (running with or without debugging). The dropdown next to the start button lets you select this mode:\nThe IDE displays Run Project (F5) and Debug Project (Ctrl+F5) options.\nStarting the machine has a different meaning for the Emulator and IDE windows.\nIn the emulator, you start the machine and let it run.\nWith its toolbar control in the IDE, you can start the machine only when a project is loaded. This start not only starts the emulated machine but also injects the compiled code into it and jumps to its entry point (or invokes it, depending on compilation options).\nKlive provides views (memory, disassembly, BASIC listing, and many more) that allow you to examine the machine's state.When the machine is running, you can use any of the windows to control it (pause, stop, or restart)\nPause: Klive pauses the machine at the current execution point. Soon, you will learn what you can do with the machine in this mode.\nStop: This stops the machine (like turning off the hardware). Though the machine is stopped, you can still examine its memory contents and state when turning it off.\nRestart: This function stops the machine and then starts it again. When you restart the machine in the IDE with a project loaded, it restarts your code and not just the machine.\nIn the paused state of a machine, you can use these actions:\nContinue. Go on running the machine.\nStop. (As described above)\nRestart. (As described above)\nStep into. Execute the subsequent CPU instruction and pause the machine again.\nStep over. Execute the subsequent CPU instruction entirely. If it is a CALL or RST instruction, a block operation (like LDIR), the IDE pauses again at the instruction following the current execution point.\nStep out. If you are within a subroutine, this function stops when the subroutine returns to its caller. Please note that this function only works if subroutine calls are completed by some of the RET instructions, not stack manipulation and jump statements.\nWhile the machine is paused, you can change between the run/debug execution modes with the dropdown."}},"/working-with-ide/sjasmp":{"title":"SJASMPLUS Integration","data":{"":"Klive IDE supports SJASMPLUS out-of-the-box, provided you installed the SjasmPlus Z80 assembler utility on your machine. After setting up SjasmPlus integration, you can use Klive IDE to edit, run, and debug programs created with this assembler.\nRunning and debugging SjasmPlus-compiled code is tested only with the ZX Spectrum 48K model.\nAs Klive IDE does not know where to find the SjasmPlus compiler on your machine, you must set it up before using it.","setting-up-sjasmplus#Setting up SJASMPLUS":"Visit the GitHub page of SjasmPlus for details about this excellent Z80 assembler. You can read information about installing it here. Note the installation folder; you will need it to set up the integration with Klive.The IDE provides a command, sjasmp-reset (or shorter, sjasmpr), to connect Klive with SjasmPlus. You can issue this command from the Command window:\nThe command expects a single parameter: the path of the SjasmPlus installation folder. When Klive invokes the assembler, the SjasmPlus executable name is added to this path.\nKlive stores the SjasmPlus settings in the Klive.setting file. If you want to change this path for a particular project (perhaps you want to test with another SjasmPlus version), use the -p switch to save this setting into the currently open project.","using-sjasmplus#Using SJASMPLUS":"After setting up the SjasmPlus integration, you can create Klive projects with the sjasmplus template:\nThis template creates a project with a code.asm file as the build root and associates the .asm and .sjasm file extensions with the SjasmPlus compiler.If you start with an existing project, you can create source code files with the .sjasm extension and promote them to build roots. Such a file will leverage the SjasmPlus compiler.When you run the SjasmPlus code in the default Klive project template, you can see the result in the Emulator window:"}},"/working-with-ide/system-vars":{"title":"The System Variables View","data":{"":"The current System Variables view does not allow editing the variables' contents.\nYou can display the current system variable values in the Machine info activity tag with the System Variables header:\nWhen you hover the mouse over a particular system variable label, you can read the explanation of that variable:\nWhen a system variable contains multiple flags, you can point to a particular flag to display its explanation:"}},"/working-with-ide/ula":{"title":"The ULA View","data":{"":"Most of the ZX Spectrum family of computers contains a ULA (Uncommitted Logic Array) chip, which renders the computer screen and I/O.You can find this view in the Debug activity tag with the ULA & I/O header:","ula-information#ULA Information":"When you hover the mouse over the information item values, they display a tooltip naming the particular information on the display.You can read this information in this panel:\nFCL: Frame clock. This value shows the current screen rendering tact, which depends on the ZX Spectrum model. For example, the ZX Spectrum 48K (PAL) uses 69.888 tacts to render the entire screen, including the borders, blank area, and sync tacts.\nFRM: The number of frames rendered since the machine started.\nRAS: The raster line being rendered\nPOS: The current rendering position within the raster line.\nPIX: The current pixel rendering operation:\nNone: A blank (non-visible) area is being rendered.\nBorder: The ULA sets the border color to display the current pixel.\nBorderFetchPixel: The ULA sets the border color to display the current pixel. It prepares to display the first pixel in the row by pre-fetching the corresponding byte from the display memory.\nBorderFetchAttr: The ULA sets the border color to display the current pixel. It has already fetched the byte of eight pixels to display, and it prepares to display the first pixel in the row by pre-fetching the corresponding attribute byte from the display memory.\nDisplayB1: The ULA displays the subsequent two pixels of Byte1 sequentially during a single Z80 clock cycle.\nDisplayB2: The ULA displays the subsequent two pixels of Byte2 sequentially during a single Z80 clock cycle.\nDisplayB1FetchB2: The ULA displays the subsequent two pixels of Byte1 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding byte from the display memory.\nDisplayB1FetchA2: The ULA displays the subsequent two pixels of Byte1 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding attribute from the display memory.\nDisplayB2FetchB1: The ULA displays the subsequent two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding byte from the display memory.\nDisplayB2FetchA1: The ULA displays the subsequent two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding attribute from the display memory.\nBOR: The current border color.\nFLO: The current floating bus value. This value is returned if the ZX Spectrum model reads an unhandled port at the current clock item.\nCON: The accumulated number of T-states spent because of memory access contention between the ULA and the CPU since the machine started.\nLCO: The accumulated number of T-states spent because of memory access contention between the ULA and the CPU since the machine was last paused.\nEAR: The EAR I/O bit (flag).\nMIC: The MIC I/O bit (flag).","keyboard-state#Keyboard State":"You can view the keyboard state, which is listed by the flags in the KL0, ..., KL7 lines. Each flag represents a key's state. The active value (filled circle) is for the pressed-down state. The tooltip shows the associated key's name when you hover the mouse over a particular flag. For example, the following figure demonstrates that the rightmost flag in KL0 (the first key line) represents the Caps Shift key.\nBy clicking a particular key flag, you can toggle its state from pressed to released (and back). This feature is handy during debugging. After clicking the Enter key (the rightmost key in line 6), its state indicates that you have just toggled it.\nThe individual key lines represent these keyboard keys:\nKL0: V, C, X, Z, and Caps Shift.\nKL1: G, F, D, S, and A.\nKL2: T, R, E, W, and Q.\nKL3: 5, 4, 3, 2, and 1.\nKL4: 6, 7, 8, 9, and 0.\nKL5: Y, U, I, O, and P.\nKL6: H, J, K, L, and Enter.\nKL7: B, N, M, Symbol Shift, and Space."}},"/working-with-ide/watch":{"title":"The Watch View","data":{"":"With this view, you can observe values of symbols while developing and debugging. You can find this view in the Debug activity tab with the Watch header.\nEach row represents a watch item with the following information:\nAn icon showing the watch value category\nnumeric (direct or indirect)\nstring\nwarning (when unresolved)\nThe symbol name (uppercased)\nThe current value (formatted)\nWhen a watch cannot be evaluated yet (for example, compiled symbols or memory content are unavailable), it displays “<unknown>”. If the symbol is not found in the current compiled output, the value shows “<not found>”.\nNote: To ensure symbol addresses are up to date, rebuild your project after making code changes. Unresolved symbols will display as “<not found>”.","adding-and-removing-watch-items#Adding and Removing Watch Items":"You manage watches through interactive commands:\nAdd a watch\nw-add [>]<symbol>[:<type>[:<length>]]\n>: optional; when present, uses the symbol's direct value rather than reading from memory<type>:\nb: 8-bit value\nw: 16-bit little-endian value\n-w: 16-bit big-endian value\nl: 32-bit little-endian value\n-l: 32-bit big-endian value\nf: flag (true/false)\na: byte array (length required; default: 8 when omitted)\ns: string (length required; default: 8 when omitted)\nRemove a watch\nw-del <symbol>\nList watches\nw-list\nRemove all watches\nw-ea\nIn addition to commands, you can remove a watch directly in the Watch view by right‑clicking its icon.Examples:\nw-add playerScore\nw-add playerScore:w\nw-add >playerAddress:w\nw-add buffer:a:32\nw-add text:s:16","understanding-value-formatting#Understanding Value Formatting":"The Watch panel formats values based on the symbol’s type and whether the watch is direct or memory-based.\nDirect integer values (uses '>')\nAlways shown as 16-bit number: $HHHH (D)\nExample: $12AB (4779)\nMemory-based integer values (no '>')\nThe symbol’s integer value is treated as a 16-bit address\nThe panel reads memory according to the selected type and endianness\nDisplayed as $HH (D), $HHHH (D), or $HHHHHHHH (D) for 8/16/32-bit types\nStrings (type: s)\nReads up to <length> bytes, stops at NUL (0x00)\nNon-printable bytes are shown as '.'\nDisplayed quoted: \"...\"\nArrays (type: a)\nDisplays up to the first 16 bytes as hex pairs separated by spaces\nIf longer than 16 bytes, shows a suffix like:  … (+N)\nFlags (type: f)\nShown as true or false (non-zero => true)\nNote: When you move the mouse over the watch item's icon, the appearing tooltip will show the symbol's display type.","typical-workflows#Typical Workflows":"Track a direct counter/constant\nw-add >frameCounter\nShows as a 16-bit value regardless of the type\nMonitor a pointer and the data it refers to\nw-add ptr:w   # watch shows the 16-bit value at address ptr (little-endian)\nw-add textPtr:s:32   # shows a printable string at the location pointed by textPtr\nInspect a small memory block\nw-add buffer:a:16","tips#Tips":"If you frequently work with strings or arrays and omit length, the default is 8.\nUse w-list to verify your watch specifications and types.\nRebuild your project to update symbol addresses when you change code; unresolved symbols will display as “<not found>”."}},"/working-with-ide/zxb":{"title":"Using ZX BASIC","data":{"":"The ZX Spectrum was famous for its BASIC interpreter, which was significantly faster than other home computers' BASIC variants in 1982. However, the compiled variants that emerged later were much faster, making BASIC a viable alternative to writing games and applications in assembly language.With the ZX BASIC extensions, including graphics utilities, user-defined functions, and a powerful array handling facility, developers could create useful programs, including animation and sound effects.However, BASIC still ran as an interpreted language, which means the computer had to process the source code line by line, limiting the execution speed of BASIC programs. This issue, and the emergence of BASIC compilers including HiSoft BASIC, gave birth to new possibilities.Boriel's ZX BASIC (you can find it here) is a BASIC dialect similar to the original Sinclair BASIC. It fixes many issues found in the original language, such as proper subroutine handling and local variables. It compiles BASIC source code to Z80 binary code, which runs much faster than interpreted BASIC.Klive supports Boriel's ZX BASIC with an extension that allows you to write BASIC source code and create ZX Spectrum executables.","zx-basic-files#ZX BASIC Files":"Files with the .bas extension are automatically recognized as ZX BASIC files. You can open a Klive project and create a new ZX BASIC source file:\nYou can use the zxb-reset command to set up ZXBASIC integration. This command has the following format:\nzxb-reset <Full ZXBC executable path> [<python3 path>]\nProvide the full executable path of the ZXBC compiler. Optionally, you can provide the path to the Python3 executable.","windows#Windows":"Specify only the first argument and use the zxbc.exe executable. For example, if your username is \"djohn\" and you installed the compiler into the zxbasic folder, use this command:\nzxb-reset \"C:\\Users\\djohn\\zxbasic\\zxbc.exe\"","using-zx-basic#Using ZX BASIC":"When you create a ZX BASIC file, you can write your source code using ZX BASIC syntax. When you open a .bas file, you can see four build-related icons in the document tab bar:\nClick the rightmost icon (with the \"play\" sign) to compile and run the code:\nYou can also try keyboard shortcuts to trigger these actions: F7 to compile, Ctrl+F7 to inject code into memory, Shift+F7 to run the code, and Ctrl+Shift+F7 to run it in debug mode.","handling-errors#Handling Errors":"When you run the code, the compiler checks the syntax. If there are any errors, the IDE displays them in a list in the Output panel. You can click on an error to navigate to its location in the source code.","debugging#Debugging":"You can run your code in debug mode by clicking the last icon in the document tab bar or pressing Ctrl+Shift+F7. In debug mode, the IDE will stop at any breakpoints you set in your code."}},"/z80-assembly/directives":{"title":"Directives","data":{"":"The directives of the Klive Z80 Assembler representation are used for preprocessing, similarly to those in the C and C++ programming languages, though their semantics are different.\nAlthough you can add comments to the end of directives, they may not have labels.","the-if-directive#The #IF Directive":"You can use this directive for conditional compilation. The argument of the directive is a\nconditional expression, and it determines on which branch the compilation goes on. #IF\nworks in concert with #ELSE and #ENDIF:\n; Block #1\n#if 2 > 3\n    ld a,b\n#endif\n; Block #2;\n#if 2 < 3\n    nop\n#else\n    ld b,c\n#endif\n; Block #3\n#if $ > $+2\n    nop\n#else\n    ld b,c\n#endif\nHere, since the condition is false, Block #1 does not generate output. Block #2 emits a nop, as the condition is true. The false condition value in Block #3 moves code parsing to the #else branch, emitting a ld b,c instruction.","the-ifdef-and-ifndef-directives#The #IFDEF and #IFNDEF Directives":"These directives work similarly to #IF. However, they check if a particular symbol has (#IFDEF) or has not (#IFNDEF) been defined. So, their single argument is an identifier name.","the-ifmod-and-ifnmod-directives#The #IFMOD and #IFNMOD Directives":"These directives work similarly to #IF. However, these check if the code's current model is specified with the identifier following the IFMOD or IFNMOD pragma. Here is a short sample of using this directive:\n    .model Spectrum48\n#ifmod Spectrum128\n    BorderColor: .equ 5\n    RetAddr: .equ #2604\n#else\n    BorderColor: .equ 4\n    RetAddr: .equ #12a2\n#endif\nStart:\n\t.org #8000\n    ld a,BorderColor\n    out (#fe),a\n    jp RetAddr\nYou can use only these identifiers with this pragma (case-insensitively): SPECTRUM48,\nSPECTRUM128, SPECTRUMP3, NEXT.","the-define-and-undef-directives#The #DEFINE and #UNDEF Directives":"You can explicitly define a symbol with the #DEFINE directive. Such a symbol has no concrete value, just its existence. With #UNDEF, you may declare a symbol undefined.\n#define SYMB\n; Block #1\n#ifdef SYMB\n    ld a,b\n#endif\n#undef SYMB\n; Block #2;\n#ifdef SYMB\n    nop\n#else\n    ld b,c\n#endif\nAccording to this definition, the first block emits a ld, a,b instruction, and the second one emits a ld b,c instruction.","the-include-directive#The #INCLUDE Directive":"You can use this directive to load and process a source file from within another source file.#INCLUDE accepts a string that names a file with its extension. The file name may contain either an absolute or a relative path. When a relative path is provided, its starting point is always the source file with the #INCLUDE directive.Assume that this code is in the C:\\Work folder:\n#include \"Symbol.z80asm\"\n#include \"./MyRules.z80asm\"\n#include \"/Common/scroll.z80asm\"\nThe compiler will check the C:\\Work folder for the first two include files and C:\\Work\\Commmon for the third one."}},"/z80-assembly/expressions":{"title":"Expressions","data":{"":"The Klive Assembler has a rich syntax for evaluating expressions. You can use the same syntax with the #if directives, the Z80 instructions, and the compiler statements.You can use operands and operators just like in most programming languages. Nevertheless, the Klive implementation has its particular way of evaluating expressions:\nExpressions can be one of these types:\nBooleans (true or false)\nintegers (64-bit)\nfloating point numbers (64-bit precision)\nstrings (with 8-bit characters)\nThe assembler applies implicit conversion whenever it's possible.\nFloating point numbers are truncated to integer values.\nThe true Boolean literal is represented with the integer value 1; false with 0.\nWhen the assembler needs a Boolean value, 0 is considered false, and any other values as true.\nThere is no implicit conversion between strings and any numeric values.\nWhen the compiler needs a 16-bit value (for example, ld hl,NNNN), it uses the rightmost 16 bits of an expression's value.\nWhen a Z80 operation (for example, ld a,NN) needs an 8-bit value, it utilizes the rightmost 8 bits.\nBesides the parentheses — ( and ) — you can use square brackets\n— [ and ] — to group operations and change operator precedence.\n; This is valid\nld hl,(Offset+#20)*2+BaseAddr\n; Just like this\nld hl,[Offset+#20]*2+BaseAddr","instant-and-late-expression-evaluation#Instant and Late Expression Evaluation":"Depending on the context in which an expression is used, the compiler evaluates it instantly or decides to postpone the evaluation. For example, when you use the .org pragma, the compiler applies immediate evaluation. Let's assume this is your code:\nStart: .org #8000 + Later\n; code body (omitted)\nLater: .db #ff\nThe value of Later depends on the address in .org, and the .org address depends on Later, so this declaration could not be adequately resolved; it's like a deadlock. The .org pragma would raise an error to avoid such situations, as at the moment of its evaluation, the Later symbol's value is unknown.For most Z80 instructions, the compiler uses late evaluation:\nStart: .org #6000\n    ld hl,(MyVar)\n    ; code body omitted\n    ret\nMyVar: .defs 2\nWhen the compiler reaches the ld hl,(MyVar) instruction, it does not know the value of MyVar. Nonetheless, it does not stop with an error but generates the machine code for ld hl,(0), namely #21, #00, and #00;\ntakes a note (it is called a fixup) when MyVal gets a value, the two #00 bytes generated at address #6001\nshould be updated accordingly.","operands#Operands":"You can use the following operands in expressions:\nBoolean, Decimal and hexadecimal literals\nCharacter literals\nIdentifiers\nThe current assembly address\nNote: String literals cannot be used as operands.","operators#Operators":"You can use about a dozen operators, including unary, binary, and ternary. In this section, you will learn about them. They will be introduced in descending order of their precedence.","conditional-operator#Conditional Operator":"The assembler supports using only one ternary operator, the conditional operator:conditional-expression ? true-value : false-valueThis operation results in -1:2 > 3 ? 2 : -1When the conditional-expression evaluates to true, the operation results\nin true-value; otherwise in false-value.\nNote: Conditional expressions are evaluated from right to left, unlike binary operators, which use left-to-right evaluation.","binary-bitwise-operators#Binary Bitwise Operators":"Operator token\tPrecedence\tDescription\t`\t`\t1\tBitwise OR\t^\t2\tBitwise XOR\t&\t3\tBitwise AND — string concatenation with new line\t\nNote: The & operator can be applied to two strings. If you do so, the compiler concatenates the two strings and puts a \\r\\n (new line) character pair between them.","relational-operators#Relational Operators":"Operator token\tPrecedence\tDescription\t==\t4\tEquality\t!=\t4\tNon-equality\t<\t5\tLess than\t<=\t5\tLess than or equal\t>\t5\tGreater than\t>=\t5\tGreater than or equal","shift-operators#Shift Operators":"The bits of the left operand are shifted by the number of bits given by the right operand.\nOperator token\tPrecedence\tDescription\t<<\t6\tShift left\t>>\t6\tShift right","basic-arithmetic-operators#Basic Arithmetic Operators":"Operator token\tPrecedence\tDescription\t+\t7\tAddition — string concatenation\t-\t7\tSubtraction\t*\t8\tMultiplication\t/\t8\tDivision\t%\t8\tModulo calculation\t\nOperator token\tPrecedence\tDescription\t<?\t9\tMinimum of the left and right operand\t>?\t9\tMaximum of the left and right operand","unary-operators#Unary operators":"Operator token\tPrecedence\tDescription\t+\t10\tUnary plus\t-\t10\tUnary minus\t~\t10\tUnary bitwise NOT\t!\t10\tUnary logical NOT\t\nDo not forget, you can change the default precedence with ( and ), or with [ and ].","functions#Functions":"The Z80 assembler provides a number of functions that can have zero, one, or more arguments.\nSeveral functions (for example as rnd()) have overloads with different signatures. Each\nfunction has a name and a parameter list wrapped into parentheses, the parameters are separated\nby a comma. Of course, parameters can be expressions, and they may invoke other functions, too.\nHere are a few samples:\nlength(\"Hello\" + \" world\")\nmax(value1, value2)\nsin(pi()/2)\nsqrt(pear + 3.0)\nThe Klive support these function signatures:\nSignature\tValue\tDescription\tabs(integer)\tinteger\tThe absolute value of an integer number.\tabs(float)\tfloat\tThe absolute value of a float number.\tacos(float)\tfloat\tThe angle whose cosine is the specified number.\tasin(float)\tfloat\tThe angle whose sine is the specified number.\tatan(float)\tfloat\tThe angle whose tangent is the specified number.\tatan2(float, float)\tfloat\tThe angle whose tangent is the quotient of two specified numbers.\tattr(integer, integer, boolean, boolean)\tinteger\tRetrieves the color attribute byte value defined by ink (first argument, 0 to 7), paper (second argument, 0 to 7), bright (third argument, 0 - non-zero), and flash (fourth argument, 0 - non-zero). The bright and flash values are optional.\tattraddr(integer, integer)\tinteger\tReturns the memory address of the byte specified screen attribute in the given line (first argument, from top to bottom, 0-192) and column (second argument, from left to right, 0-255).\tbright(boolean)\tinteger\tRetrieves the bright flag defined by the attribute (0 - non-zero). It can be ORed to create a color attribute value.\tceiling(float)\tfloat\tThe smallest integral value greater than or equal to the specified number.\tcos(float)\tfloat\tThe cosine of the specified angle.\tcosh(float)\tfloat\tThe hyperbolic cosine of the specified angle.\texp(float)\tfloat\te raised to the specified power.\tfill(string, integer)\tstring\tCreates a new string by concatenating the specified one with the given times.\tflash(boolean)\tinteger\tRetrieves the flash flag defined by the argument (0 - non-zero). It can be ORed to create a color attribute value.\tfloor(float)\tfloat\tThe largest integer less than or equal to the specified number.\tfrac(float)\tfloat\tThe fractional part of the specified number.\thigh(integer)\tinteger\tThe leftmost 8 bits (MSB) of a 16-bit integer number.\tink(integer)\tinteger\tRetrieves the three ink bits defined by the color argument (0 to 7). It can be ORed to create a color attribute value.\tint(float)\tinteger\tThe integer part of the specified number.\tlcase(string)\tstring\tThe lowercase version of the input string.\tleft(string, integer)\tstring\tTakes the leftmost characters of the string with the length specified.\tlen(string)\tinteger\tThe length of the specified string.\tlength(string)\tinteger\tThe length of the specified string.\tlog(float)\tfloat\tThe natural (base e) logarithm of a specified number.\tlog(float, float)\tfloat\tThe logarithm of a specified number in a specified base.\tlog10(float)\tfloat\tThe base 10 logarithm of a specified number.\tlow(integer)\tinteger\tThe rightmost 8 bits (LSB) of an integer number.\tlowercase(string)\tstring\tThe lowercase version of the input string.\tmax(integer, integer)\tinteger\tThe larger of two integer numbers.\tmax(float, float)\tfloat\tThe larger of two float numbers.\tmin(integer, integer)\tinteger\tThe smaller of two integer numbers.\tmin(float, float)\tfloat\tThe smaller of two float numbers.\tnat()\tfloat\tRepresents the natural logarithmic base, specified by the constant, e.\tpaper(integer)\tinteger\tretrieves the three paper bits defined by the argument (0 to 7). It can be ORed to create a color attribute value.\tpi()\tfloat\tRepresents the ratio of the circumference of a circle to its diameter, specified by the constant, π.\tpow(float, float)\tfloat\tThe specified number raised to the specified power.\tright(string, integer)\tstring\tTakes the rightmost characters of the string with the length specified.\tround(float)\tfloat\tRounds a float value to the nearest integral value.\tround(float, int)\tfloat\tRounds a float value to a specified number of fractional digits.\trnd()\tinteger\tReturns a random 32-bit number.\trnd(integer, integer)\tinteger\tReturns a random 32-bit integer between the first and second number.\tscraddr(integer, integer)\tinteger\tRetrieves the memory address of the screen pixel byte in the specified line (first argument, from top to bottom, 0-192) and in the specified column (second argument, from left to right, 0-255).\tsign(integer)\tinteger\tReturns an integer that indicates the sign of an integer number.\tsign(float)\tinteger\tReturns an integer that indicates the sign of a float number.\tsin(float)\tfloat\tThe sine of the specified angle.\tsinh(float)\tfloat\tThe hyperbolic sine of the specified angle.\tsqrt(float)\tfloat\tThe square root of a specified number.\tstr(bool)\tstring\tConvert the input value to a string.\tstr(integer)\tstring\tConvert the input value to a string.\tstr(float)\tstring\tConvert the input value to a string.\tsubstr(string, integer, integer)\tstring\tTakes a substring of the specified string from the given position (zero-based) and length.\ttan(float)\tfloat\tThe tangent of the specified angle.\ttanh(float)\tfloat\tThe hyperbolic tangent of the specified angle.\ttruncate(float)\tinteger\tCalculates the integral part of a specified number.\tucase(string)\tstring\tThe uppercase version of the input string.\tuppercase(string)\tstring\tThe uppercase version of the input string.\tword(integer)\tinteger\tThe rightmost 16 bits of an integer number.\t\nFunctions have the same precedence as the unary operators (such as the unary + and -).","parse-time-functions#Parse Time Functions":"The compiler provides a construct, parse time functions. These functions can receive a Z80 assembly language token and transform them into other language constructs. As the name suggests, these functions run in the parsing phase before the compiler emits code.","the-lreg-and-hreg-parse-time-functions#The lreg() and hreg() Parse Time Functions":"These functions accept a 16-bit register pair token (BC, DE, HL, IX, or IY) and retrieve the lower\nor higher 8-bit register half of their input. Here is a sample code snippet:\nld a,lreg(bc)\nld c,hreg(hl)\nld a,lreg(ix)\nld l,hreg(de)\nThe compiler sees as if you wrote this:\nld a,c\nld c,h\nld a,ixl\nld l,d","the-textof-parse-time-function#The textof() Parse Time Function":"You can use textof(), which accepts these kinds of tokens: mnemonic, register, register indirection, C port, or condition. This function translates these tokens into uppercase string constants that represent them.\nHere is a sample:\n.dm textof(ldir)\n.dm textof(bc)\n.dm textof((de))\n.dm textof((c))\n.dm textof(nz)\nThe compiler sees as if you wrote this code:\n.dm \"LDIR\"\n.dm \"BC\"\n.dm \"(DE)\"\n.dm \"(C)\"\n.dm \"NZ\""}},"/z80-assembly/language-structure":{"title":"Klive Z80 Assembly Language Structure","data":{"":"Each line of the source code is a declaration unit and is parsed within its context. Such a source code line can be one of these constructs:\nA Z80 instruction, which can be directly compiled to binary code (such as ld bc,#12AC)\nA directive that is used by the compiler's preprocessor (e.g. #include, #if, etc.)\nA pragma that emits binary output or instructs the compiler about code emission (.org, .defb, etc.)\nA compiler statement (or shortly, a statement) that implements control flow operations for the compiler (e.g., .loop, .repeat...until, .if...elif...else...endif)\nA comment that helps the understanding of the code.","syntax-basics#Syntax Basics":"The assembler language has specific case sensitivity rules. You can write reserved words (such as assembly instructions, pragmas, or directives) with lowercase or uppercase letters, but you cannot mix these cases. For example, these instructions use the proper syntax:\nLD c,A\nJP #12ac\nldir\ndjnz MyLabel\nHowever, in these samples, character cases are mixed, and the compiler will refuse them:\nLd c,A\nJp #12ac\nldIR\ndjNZ MyLabel\nIn symbolic names (labels, identifiers, etc.), you can mix lowercase and uppercase letters. Nonetheless, the compiler applies case-insensitive comparison when matching symbolic names. So, these statement pairs are equivalent to each other:\njp MainEx\njp MAINEX\ndjnz mylabel\ndjnz MyLabel\nld hl,ErrNo\nld hl,errNo","comments#Comments":"The language supports two types of comments: end-of-line and block comments.End-of-line comments start with a semicolon (;) or double forward slash (//). The compiler takes the rest of the line into account as the body of the comment. This sample illustrates this concept:\n; This line is a comment-only line\nWait:   ld b,8     ; Set the counter\nWait1:  djnz Wait1 // wait while the counter reaches zero\nBlock comments can be put anywhere within an instruction line between /* and */ tokens until they do not break other tokens. Nonetheless, block comments cannot span multiple lines; they must start and end within the same source code line. All of the block comments in this code snippet are correct:\nSetAttr:\n\tld b,32\nfill:\n  /* block */\n  /* b2 */ ld (hl),a\n  inc /* b3 */ hl\n  djnz /* b4 */ fill /* b5 */\n  ret\nHowever, this will result in a syntax error:\n/* \n  This block comment spans multiple lines,\n  and thus, it is invalid\n*/\nSetAttr:\n\tld b,32\nNote: If you need multi-line comments, you can add single-line comments after each other. The Z80 assembly does not have separate multi-line comment syntax.","literals#Literals":"The language syntax provides these types of literals:\nBoolean values. The following tokens represent Booleans: .false, false, .true, and true.\nDecimal numbers. You can use up to 5 digits (0..9) to declare a decimal number. For example: 16, 32768, 2354.\nFloating point numbers. You can use the same notation for floating point numbers as in C/C++/Java/C#. Here are a few samples:\n.25\n123.456\n12.45E34\n12.45e-12\n3e+4\nHexadecimal numbers. You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare a hexadecimal literal. The compiler looks for a #, 0x, or $ prefix or one of the h or H suffixes to recognize them as hexadecimal. If you use the h or H suffixes, the hexadecimal number should start with a decimal digit 0...9; otherwise, the assembler interprets it as an identifier (label). Here are a few samples:\n#12AC\n0x12ac\n$12Ac\n12ACh\n12acH\n0AC34H\nBinary numbers. Literals starting with one of the %, or 0b prefixes (or with the b or B suffix) are considered binary literals. You can follow the prefix with up to 16 0 or 1 digits. To make them more readable, you can separate adjacent digits with the underscore (_) or single quote (') character. These are all valid binary literals:\n%01011111\n0b01011111\n0b_0101_1111\n0101_1111b\n0b'0101'1111\nOctal numbers. You can use up to 6 digits (0..7) with an o, O (letter O), q, or Q suffix to declare an octal number. Examples: 16o, 327q, 2354Q.\nNote: You can use negative numbers with the minus sign in front of them. The sign is not part of the numeric literal; it is an operator.\nCharacters. You can put a character between single quotes (for example: 'Q').\nStrings. You can put a series of characters between double quotes (for example: \"Sinclair\").\nNote: You can use escape sequences to define non-visible or control characters, as you will learn soon.\nThe $, * or . tokens. These literals are equivalent; all represent the current assembly address.","identifiers#Identifiers":"You can use identifiers to refer to labels and other constants. Identifiers must start with a letter (a...z or A...Z) or with one of these characters: ` (backtick), _ (underscore), @, !, ?, or #. The subsequent ones can be digits and any start characters except backtick. Here are a few examples:\nMyCycle\nERR_NO\nCycle_4_Wait\n`MyTemp\n@ModLocal\nIsLastLine?\nNote: Some strings can be identifiers or hexadecimal literals with the H or h suffix, like AC0Fh, or FADH. The assembler considers such strings as identifiers. To sign a hexadecimal literal, use a 0 prefix: 0FADH is a hexadecimal literal, while FADH is an identifier.\nNote: Theoretically, you can use arbitrary long identifiers. I suggest you make them no longer than 32 characters so readers can read your code easily.","scoped-identifiers#Scoped Identifiers":"As you will later learn, the Klive Assembler supports modules like namespaces in other languages (Java, C#, C++, etc.) to encapsulate labels and symbols. To access symbols within modules, you can use scoped identifiers with this syntax:::? identifier (. identifier)*The optional :: token means the name should start in the outermost (global) scope. The module and identifier segments are separated with a dot. Examples:\n::FirstLevelModule.Routine1\nNestedModule.ClearScreen\nFirstLevelModule.NestedModule.ClearScreen","characters-and-strings#Characters and Strings":"You have already learned that you can utilize character and string literals (wrapped into single or double quotes, respectively), such as in these samples:\n\"This is a string. The next sample is a single character:\"\n'c'\nZX Spectrum has a character set with special control characters such as AT, INK, PAPER, etc. The Assembler allows you to define these with special escape sequences:\nEscape\tCode\tCharacter\t\\i\t0x10\tINK\t\\p\t0x11\tPAPER\t\\f\t0x12\tFLASH\t\\b\t0x13\tBRIGHT\t\\I\t0x14\tINVERSE\t\\o\t0x15\tOVER\t\\a\t0x16\tAT\t\\t\t0x17\tTAB\t\\P\t0x60\tpound sign\t\\C\t0x7F\tcopyright sign\t\\\\\t0x5C\tbackslash\t\\'\t0x27\tsingle quote\t\\\"\t0x22\tdouble quote\t\\0\t0x00\tbinary zero\t\nNote: Some of these sequences have different values than their corresponding pairs in other languages, such as C, C++, C#, or Java.\nTo declare a character by its binary code, you can use the \\xH or\n\\xHH sequences (H is a hexadecimal digit). For example, these\nescape sequence pairs are equivalent:\n\"\\i\"\n\"\\x10\"\n\"\\C by me\"\n\"\\x7f \\x62y me\"","labels-and-symbols#Labels and Symbols":"In Klive Z80 Assembly, you can define labels and symbols. Both constructs are syntactically the same, but there is some difference in their semantics. While we define labels to mark addresses (code points) in the program so that we can jump to those addresses and read or write their contents, symbols are not as specific; they just store values we intend to use.From now on, I will mention \"label\" for both constructs and do otherwise only when the context requires it.When you write a Klive Assembly instruction, you can start the line with a label:\nMyStart: ld hl,0\nHere, in this sample, MyStart is a label. The assembler allows you to omit the colon after the label name, so this line is valid:\nMyStart ld hl,0\nSome developers like to put a label in a separate line from the instruction to which it belongs. You can use the same hanging label style within Klive. In this case, the label should go before its instruction. Take a look at this code snippet:\nMyStart:\n  ld hl,0\nMyNext\n  ; Use B as a counter\n  ld b,32\nThis code is entirely correct. Note the ld b,32 instruction belongs to the MyNext label. As you see from the sample, the colon character is optional for hanging labels, too. You can have multiple line breaks between a label and its instruction, and the space can include comments.","label-and-symbol-declarations#Label and Symbol Declarations":"As you will learn later, you can define symbols with the .EQU or .VAR pragmas. While .EQU allows you to assign a constant value to a symbol, it cannot change its value after the declaration. .VAR lets you re-assign the initial value.Klive supports the idea of lexical scopes. When you create the program, it starts with a global (outermost) lexical scope. Particular language elements, such a statements create their nested lexical scope. Labels and symbols are always created within the current lexical scope. Nonetheless, when resolving them, the assembler starts with the innermost scope and goes through all outer scopes until it finds the label declaration.This mechanism means that you can declare labels within a nested scope so that those hide labels and symbols in outer scopes.Klive also supports modules, which allow you to use namespace-like constructs.","temporary-labels#Temporary Labels":"The assembler considers labels that start with a backtick (`) character as temporary labels. Their scope is the area between the last persistent label preceding the temporary one and the first persistent label following the temporary one.This code snippet demonstrates this concept:\nSetPixels:        ; Persistent label\n  ld hl, #4000\n  ld a,#AA\n  ld b,#20\n`loop:            ; Temporary label (scope #1)\n  ld (hl),a\n  inc hl\n  djnz `loop\nSetAttr:          ; Persistent label, scope #1 disposed here\n  ld hl,#5800\n  ld a,#32\n  ld b,#20\n`loop:            ; Temporary label (scope #2)\n  ld (hl),a\n  inc hl\n  djnz `loop\n  ret\n; scope #2 still lives here\n; ...\nAnother: ; Persistent label, scope #2 disposed here\n  ld a,b\nAs you see, the two occurrences of  `loop  belong to two separate temporary scopes. The first scope is the one between SetPixels and SetAttr, the second one between SetAttr and Another."}},"/z80-assembly/pragmas":{"title":"Pragmas","data":{"":"The compiler understands several pragmas that — though they are not Z80 instructions — influence the emitted code. Each pragma has two alternative syntax constructs, one with a dot prefix and another without.For example, you can write ORG or .ORG to use the ORG pragma.","the-org-pragma#The ORG pragma":"With the ORG pragma, you define where to place the compiled Z80 code when you run it.For example, the following line sets this location to the 0x6000 address:\n.org #6000\nIf you do not use ORG, the default address is 0x8000.You can apply multiple ORG pragmas in your source code. Each usage creates a new segment in the assembler output. Take a look at this code:\nld h,a\n.org #8100\nld d,a\n.org #8200\nld b,a\nThis code generates three output segments, each with one emitted byte representing the corresponding LD operation. The first segment will start at 0x8000 (default), the second at 0x8100, and the third at 0x8200.","the-xorg-pragma#The XORG pragma":"With the XORG pragma, you define the start address of a specific code section (the section started with the previous .ORG) to use when exporting to Intel HEX format.For example, the following line sets this location to the 0x0000 address; however, the code section starts at 0x6000.\n.org #6000\n.xorg #0\nIf you try to use multiple .XORG within a code section, the assembler raises an error:\n.org #6000\n.xorg #0\n    ld a,b\n    ; ...\n.xorg #1000 ; This line will cause an error message","the-ent-pragma#The ENT pragma":"The ENT pragma defines the entry code of the program when you start it. If you do not apply ENT in your code, the entry point will be the first address of the very first output code segment. Here's a sample:\n.org #6200\nld hl,#4000\n.ent $\njp #6100\n.org #6100\ncall MyCode\n...\nThe .ent $ pragma will sign the address of the jp #6100 instruction as the entry address of the code. Should you omit the ENT pragma from this code, the entry point would be0x6200, as that is the start of the very first output segment, even though there is another segment starting at 0x6100.","the-xent-pragma#The XENT pragma":"The IDE provides a command, Export Code, which allows you to create a LOAD block that automatically starts the code. When you run the code from the IDE, the address specified with the ENT pragma is used. However, the auto LOAD block uses the RANDOMIZE USR address pattern, and you may need to define a different entry address that can be closed with a RET statement. The XENT pragma sets this address.Here's a sample:\nstart: \n\t.org #8000\n\t.ent #8000\n\tcall SetBorder\n\tjp #12ac\nSetBorder:\n\t.xent $\n\tld a,4\n\tout (#fe),a\n\tret\nThe IDE will use #8000 — according to the .ent #8000 pragma — when starting the code from the IDE. Nonetheless, the exported code will offer #8006 — according to the .xent $ pragma — as the startup code address.","the-disp-pragma#The DISP pragma":"The DISP pragma allows you to define a displacement for the code. The value affects the $ token representing the current assembly address. Your code is placed according to the ORG of the particular output segment, but the assembly address is always displaced with the value according to DISP. Take a look at this sample:\n.org #6000\n.disp #1000\nld hl,$\nThe ld hl,$ instruction will be placed to the 0x6000 address, but it will be equivalent\nwith the ld hl,#7000 statement due to the .disp #1000 displacement.\nOf course, you can use negative displacement, too.","the-bank-pragma#The BANK pragma":"The ZX Spectrum 128K/2A/+2A/+3/+3E models handle 16K memory pages (banks) that can be paged into particular memory slots. (You can find more information about this here.)The BANK pragma lets you declare that you want to put the Z80 Assembly code in a specific memory bank. When you export the compiled output, the Export code command of the IDE creates a loader that reads the code and places it on the specified memory page.The BANK pragma accepts two parameters (plus optional flags). The first is the bank number (0-7 for Spectrum128, 0-111 for ZX Spectrum Next). The second one is an optional offset value (between 0 and 16383), which indicates the start offset within the bank. If you omit this, the default value is zero. By default, the Klive Assembler assumes that the start address of the code in the bank is $C000. Nonetheless, you can specify any other value.\nNote: You need to apply the .model Spectrum128 pragma at the top of your code so that you can use .bank.","using-bank-without-an-offset#Using BANK without an offset":"Let's assume you have this code:\n.model Spectrum128\n; ...\n.bank 3\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nThe compiler emits this code (and later, the loader takes care that it goes to bank #3):\n0000: call #C004  ; yellow\n0003: ret\n0004: ld a,#06    ; this is yellow (#C004)\n0006: out (#FE),a\nThe offset values at the beginning of the lines show the byte offset within the 16K memory bank.","using-bank-with-an-offset#Using BANK with an offset":"Let's modify the previous code by adding an offset value:\n.model Spectrum128\n; ...\n.bank 3, #100\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nNow, the compiler emits similar code, but its start address is #C100 (#100 away from the default #C000):\n0100: call #C104  ; yellow\n0103: ret\n0104: ld a,#06    ; this is yellow (#C104)\n0106: out (#FE),a\nThough we're wasting the first 256 bytes of the page, the Export command does not output those bytes. The loader knows that it should load the code from address #C100.","using-bank-with-org#Using BANK with ORG":"Though the default address to compile the code is #C000, you can change it. For example, Bank #2 is paged into the #8000-#BFFF\nmemory range (slot 2), so it seems natural to use the #8000 address like this:\n.model Spectrum128\n; ...\n.bank 2\n.org #8000\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nAs you expect, this is the output:\n0000: call #8004  ; yellow\n0003: ret\n0004: ld a,#06    ; this is yellow (#8004)\n0006: out (#FE),a","using-bank-with-offset-and-org#Using BANK with offset and ORG":"You can combine the offset of the bank with ORG:\n.bank 2, #100\n.org #8000\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nThe output is probably different from the one you expect:\n0100: call #8004  ; yellow\n0103: ret\n0104: ld a,#06    ; this is yellow (#8004)\n0106: out (#FE),a\nAs you can see, the code stream is the same as in the previous case; however, here, the code starts at offset #100.","using-multiple-bank-directives#Using multiple BANK directives":"As you may need multiple memory banks in your program, you can use multiple BANK pragmas, like in this example:\n.bank 1\n; Here is the code for bank #1\n; ...\n.bank 3\n; Here is the code for bank #3\n; ...","using-the-noexport-flag-next-model-only#Using the noexport flag (Next model only)":"When using the ZX Spectrum Next model, you can optionally exclude specific banks from being exported to the NEX file by using the noexport flag. By default, all banks are exported. This flag allows you to mark banks that should not be included in the final NEX output:\n.model Next\n.bank 5\n; This bank WILL be exported\n  nop\n.bank 10 noexport\n; This bank will NOT be exported\n  nop\n.bank 15\n; This bank WILL be exported\n  nop\nYou can also combine the noexport flag with the offset parameter:\n.model Next\n.bank 20, #1000 noexport\n; This bank with offset will not be exported\n  nop\nNote: The noexport flag is only available for the ZX Spectrum Next model. Using it with other models (Spectrum48, Spectrum128) will raise an error.","restrictions-with-bank#Restrictions with BANK":"BANK cannot have a label.\nBANK cannot be used with the ZX Spectrum 48 model type.\nFor Spectrum128: The BANK value must be between 0 and 7\nFor ZX Spectrum Next: The BANK value must be between 0 and 111\nThe offset must be between 0 and 16383\nFor Spectrum128: You can use the BANK pragma for a particular bank page only once\nFor ZX Spectrum Next: You can reuse the same bank multiple times to create multiple segments within the same bank\nThe noexport flag can only be used with the ZX Spectrum Next model","the-equ-pragma#The EQU pragma":"The EQU pragma allows you to assign a value to an identifier. The label before EQU is the name of the identifier (or symbol), and the expression used in EQU is the variable's value. Here is a short example:\n      .org #6200\n      ld hl,Sym1\nSym1: .equ #4000\n      ld bc,Sym2\nSym2: .equ $+4\nThis sample is equivalent to this one:\n.org #6200\nld hl,#4000 ; Sym1 <-- #4000\nld bc,#620a ; Sym2 <-- #620a as an ld bc,NNNN operation and\n                       an ld hl,NNNN each takes 3 bytes","the-var-pragma#The VAR pragma":"The VAR pragma works similarly to EQU. However, while EQU does not allow the use of the same symbol with multiple value assignments, VAR assigns a new value to the symbol every time it is used.\nNote: The VAR pragma accepts extra syntax alternatives: =, :=","the-injectopt-pragma#The INJECTOPT pragma":"The INJECTOPT pragma expects an identifier-like option tag after the starting pragma keyword. This keyword identifies an option for injecting the code into an emulated machine. The Klive Assembler supports two options:","cursorl#cursorl":"When you run the ZX Spectrum virtual machine from the IDE, it injects the machine code into the memory and sets up the system as if you started the code from BASIC with the RUN command. By default, it sets the cursor to \"K\" mode.However, in several cases, you'd like to keep the cursor in \"L\" mode, for example, when you intend to start the code with the RANDOMIZE USER addr command (here, addr is the entry address). In this case, you can add the INJECTOPT pragma to the code:\n.injectopt cursorl","cursork-deprecated#cursork (deprecated)":"The cursork option is a deprecated alias for cursorl and does the same thing — it sets the cursor to \"L\" mode. The name was originally chosen because the \"K\" cursor is what you want to get rid of, which caused confusion. Use cursorl instead.\n.injectopt cursork  ; deprecated: use cursorl instead","subroutine#subroutine":"This option instructs the IDE to call your code (terminated with RET) and not to jump directly to its start address.\nNote: You can use any other options; the compiler will not raise an exception; it ignores the unknown options.","the-defb-pragma#The DEFB pragma":"The DEFB pragma emits 8-bit expressions (bytes) from the current assembly position. Here is a sample:\n.org #6000\n.defb #01, #02, $, #04\nThe DEFB pragma will emit these four bytes starting at 0x6000: 0x01, 0x02, 0x03, 0x04.\nThe $ expression will emit 0x03, because, at the emission point, the current assembly address is 0x6003. The DEFB program considers only the rightmost 8 bits of any expression: this is how $ results in 0x03.\nDEFB has extra syntax variants: db, .db, DB, and .DB are accepted, too.","the-defw-pragma#The DEFW pragma":"The DEFW pragma is similar to DEFB, but it emits 16-bit values with LSB, MSB order.\n.defw #1234, #abcd\nThis simple code above will emit these four bytes: 0x34, 0x12, 0xcd, 0xab.\nDEFW has extra syntax variants: dw, .dw, DW, and .DW are accepted, too.","the-defm-pragma#The DEFM pragma":"The DEFM pragma emits the byte-array representation of a string. Each character in the string is replaced with the corresponding byte. Take a look at this code:\n.defm \"\\C by me\"\nHere, the DEFM pragma emits 7 bytes for the seven characters (the first escape sequence represents the copyright sign): 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0x65.\nDEFM has extra syntax variants: dm, .dm, DM, and .DM are accepted, too.","the-defn-pragma#The DEFN pragma":"The DEFN pragma works just like the DEFM pragma, but it emits an additional 0x00 byte to terminate the string. Look at this code:\n.defn \"\\C by me\"\nHere, the DEFN pragma emits 8 bytes for the seven characters (the first escape sequence represents the copyright sign) plus the terminating zero: 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0x65, 0x00.\nNote: DEFN has extra syntax variants: dn, .dn, DN, and .DN are also accepted.","the-defc-pragma#The DEFC pragma":"The DEFC pragma works just like the DEFM pragma, but it sets Bit 7 of the last emitted character. Look at this code:\n.defc \"\\C by me\"\nHere, the DEFC pragma emits 7 bytes for the seven characters (the first escape sequence represents the copyright sign) with Bit 7 of the last character (0x65) set (so it becomes 0xE5): 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0xE5.\nNote: DEFC has extra syntax variants: dc, .dc, DC, and .DC are also accepted.","the-defh-pragma#The DEFH pragma":"The DEFH pragma uses a string with an even number of hexadecimal digits to emit a byte-array representation of the input. Each character pair in the string is replaced with the corresponding byte. Take a look at this code:\n.defh \"12E4afD2\"\nHere, the DEFH pragma emits 4 bytes: 0x12, 0xe4, 0xaf, 0xd2.\nNote: DEFH has extra aliases: dh, .dh, DH, and .DH.","the-defs-pragma#The DEFS pragma":"You can emit zero (0x00) bytes with this pragma. It accepts a single argument, the number of zeros to emit. This code sends 16 zeros to the generated output:\n.defs 16\nNote: DEFS has extra syntax variants: ds, .ds, DS, and .DS are also accepted.","the-fillb-pragma#The FILLB pragma":"With FILLB, you can emit a particular count of a specific byte. The first argument of the pragma sets the count, and the second specifies the byte to emit. This code emits 24 bytes of #A5 values:\n.fillb 24,#a5","the-fillw-pragma#The FILLW pragma":"With FILLW, you can emit a particular count of a 16-bit word. The first argument of the pragma sets the count, and the second specifies the word to emit. This code emits 8 words (16 bytes) of #12A5 values:\n.fillw 8,#12a5\nOf course, the bytes of a word are emitted in LSB/MSB order.","the-skip-pragma#The SKIP pragma":"The SKIP pragma, as its name suggests, skips the number of bytes from the current address to that specified in the first argument. It fills up the skipped bytes with 0xFF by default, but the fill value can be set with the second argument:\n.skip $+#05      ; fills next 5 bytes with 0xFF\n.skip $+#04, #3a ; fills next 4 bytes with 0x3A","the-extern-pragma#The EXTERN pragma":"The EXTERN pragma is kept for future extension. The current compiler accepts it but does not act when observing this pragma.","the-model-pragma#The MODEL pragma":"This pragma is used when you run or debug your Z80 code within the emulator. With Spectrum 128K, Spectrum +3, and Spectrum Next models, you can run the Z80 code in different contexts. The MODEL pragma lets you specify which model to run the code. You can use the SPECTRUM48, SPECTRUM128, SPECTRUMP3, or NEXT identifiers to choose the model (identifiers are case-insensitive):\n.model Spectrum48\n.model Spectrum128\n.model SpectrumP3\n.model Next\nFor example, when you create code for Spectrum 128K, and add the .model Spectrum48 pragma to the code, the Run command will start the virtual machine, turn the machine into Spectrum 48K mode, and ignite the code just after that.\nNote: With the #ifmod and #ifnmod directives, you can check the model type. For example, the following Z80 code results in a green background on Spectrum 48K and cyan on Spectrum 128K:\n    .model Spectrum48\n#ifmod Spectrum128\n    BorderColor: .equ 5\n    RetAddr: .equ #2604\n#else\n    BorderColor: .equ 4\n    RetAddr: .equ #12a2\n#endif\nStart:\n    .org #8000\n    ld a,BorderColor\n    out (#fe),a\n    jp RetAddr","the-align-pragma#The ALIGN pragma":"This pragma allows you to align the current assembly counter to the specified byte boundary. You can use this pragma with an optional expression. Look at these samples:\n.org #8000\n    nop\n.align 4\n    nop\n.align\nThe first pragma aligns the assembly counter to #8004, the next 4-byte boundary. With no value specified, .align uses #100, and thus the second .align in the sample sets the current assembly counter to the next page boundary, #8100.","the-trace-and-tracehex-pragmas#The TRACE and TRACEHEX pragmas":"These pragmas send trace information to the assembler output. In the Visual Studio IDE, these messages are displayed in the Z80 Build Output pane. List one or more expressions separated by a comma after the .trace token. TRACEHEX works like TRACE, but it displays integer numbers and strings in hexadecimal format.Let's assume you add these lines to the source code:\n.trace \"Hello, this is: \", 42\n.tracehex \"Hello, this is: \", 42\nWhen you compile the source, the lines above display these messages:\nTRACE: Hello, this is: 42\nTRACE: 48656C6C6F2C20746869732069733A20002A","the-rndseed-pragma#The RNDSEED pragma":"With the rnd() function, you can generate random numbers. The RNDSEED pragma sets the seed value to use for random number generation. If you use this pragma with an integer expression,\nthe seed is set to the value of that expression. If you do not provide the expression, the compiler uses the system clock to set up the seed.\n.rndseed ; sets the seed according to the system clock\n.rndseed 123 ; sets the seed to 123","the-defgx-pragma#The DEFGX pragma":"This pragma helps you define bitmaps in the code. This pragma excepts a string expression and utilizes that string as a pattern to generate bytes for the bitmap.\nNote: DEFGX has extra syntax variants: dgx, .dgx, DGX, and .DGX are accepted, too.\nIf the very first character of the string pattern is <, the pattern is left aligned and starts with the second character. Should the first character be >, the pattern is right aligned and starts with the second character. By default (if no < or > is used) the pattern is left-aligned.Spaces within the pattern are ignored and considered helpers. Other characters are converted into bits one by one.Before the conversion, the pragma checks if the pattern constitutes multiples of 8 bits. If not, it uses zeros as prefixes (right-aligned) or zeros as suffixes (left-aligned), so the pattern would be adjusted to contain entire bytes.The . (dot), - (dash), and _ (underscore) sign 0, and any other characters stand for 1. Every 8 bits in the pattern emit a byte.Here are a few samples:\n.dgx \"....OOOO\"         ; #0F\n.dgx \">....OOOO\"        ; #0F\n.dgx \"<----OOOO\"        ; #0F\n.dgx \"___OOOO\"          ; #1E\n.dgx \"....OOOO ..OO\"    ; #0F, #30\n.dgx \">....OO OO..OOOO\" ; #03, #CF","the-defg-pragma#The DEFG pragma":"This pragma helps you define bitmaps in the code. This pragma excepts a string pattern (note: not a string expression!)\nand utilizes that string as a pattern to generate bytes for the bitmap.\nNote: DEFG has extra syntax variants: dg, .dg, DG, and .DG are also accepted.\nSpaces within the pattern are ignored and considered helpers. Other characters are converted into bits one by one. The pixels in a byte are planted with the LSB as the most significant bit, and multiple bytes are planted LSB byte first.The . (dot), - (dash), and _ (underscore) sign 0, and any other characters stand for 1. Every 8 bits in the pattern emit a byte.Here are a few samples:\n.dg ....OOOO        ; #0F\n.dg ___OOOO         ; #1E\n.dg ....OOOO ..OO\"  ; #0F, #30\n.dg ....OO OO..OOOO ; #0F, #3C\nNote: Unlike in the pattern used with DEFGX, here, the leading > and < characters are taken as bit 1. They do not specify bit alignment.","the-error-pragma#The ERROR Pragma":"You can raise custom error messages with this pragma. ERROR accepts an expression and displays an error message with code Z0500 using your provided text. Here is a sample:\n.error \"The value must be greater than\" + str(minvalue)","the-includebin-pragma#The INCLUDEBIN Pragma":"You can include a binary file into the source code to emit all bytes as if you used the .defb pragma. You can include the entire file or a single segment of it. The pragma has a mandatory argument, the name of the binary file to include, and two optional ones, the start offset of the segment and its length, respectively. Let's see a few examples:\n.includebin \"./myfile.bin\"\n.includebin \"./myfile.bin\" 2\n.includebin \"./myfile.bin\" 2, 3\nThis snippet loads the myfile.bin file from the same directory that contains the source\nwith the .includebin directive.Let's assume that myfile.bin contains these bytes:\n#00, #01, #02, #03, #04, #05, #06, #07 \nThe three lines of code above are the same as if we had written these code lines:\n.defb #00, #01, #02, #03, #04, #05, #06, #07 ; .includebin \"./myfile.bin\"\n.defb #02, #03, #04, #05, #06, #07           ; .includebin \"./myfile.bin\" 2\n.defb #02, #03, #04                          ; .includebin \"./myfile.bin\" 2, 3\nNote: The compiler does not allow negative file offset or length. It else raises an error if you define a segment that does not fit into the binary file. You can use an alternative syntax for .includebin. The compiler accepts these tokens and their uppercase versions, too: includebin, .include_bin, and include_bin.","the-comparebin-pragma#The COMPAREBIN pragma":"When re-engineering a Z80 program from an exported disassembly, it is good to know that you do not break the original code. The .comparebin pragma helps you to check that you still compile what you expect. It loads a binary file and compares that file with the output of the current code segment.The pragma has a mandatory argument, the name of the binary file to include, and two optional ones, the start offset of the segment and its length, respectively. Let's see a few examples:\n.comparebin \"./myfile.bin\"\n.comparebin \"./myfile.bin\" 2\n.comparebin \"./myfile.bin\" 2, 3\nNote: The compiler does not allow negative file offset or length. It also raises an error if you define a segment that does not fit into the binary file. You can use alternative syntax for .comparebin. The compiler accepts these tokens, too: comparebin, .COMPAREBIN, and COMPAREBIN.\nWhen you compile the code, every .org pragma opens a new segment that starts from the point defined by .org.You can put it into the code in as many places as you want. As the compiler parses the code, it records the positions of .comparebin pragmas, the current output segment, and its length at the point where .comparebin is used. When the code compilation is ready, and there are no errors, the compiler executes a check. This check compares the emitted bytes with the recorded length to the bytes in the binary file.\nIf the length of the segment is greater than the size of the file, the compiler raises an error.\nThe comparison checks only the as many bytes as are in the output segment; if more are in the binary file, the remaining data is ignored.\nIf the compared data do not match, the assembler raises an error with the first unmatching position.\nLet's assume we have the origin.bin file that contains these six bytes:\n#00, #01, #02, #03, #04, #05\nTake a look at this code:\n  .org #8000\n  .defb #00, #01, #02\n  .comparebin \"origin.bin\"\n  .org #8100\n  .defb #03, #04, #05\n  .comparebin \"origin.bin\"\n  .comparebin \"origin.bin\", 3\nThis code contains two segments (it has two .org pragmas) and three .comparebin.\nThough origin.bin has six bytes, the first comparison succeeds, utilizing only the three bytes emitted in the first segment.\nThe second comparison fails, as the file starts with #00, #01, #02, while the segment emits #03, #04, and #05.\nThe third comparison succeeds, as it starts the examination from the 4th byte (offset 3) of the binary file.","the-onsuccess-pragma#The ONSUCCESS pragma":"This pragma declares an interactive Klive command that is executed when the code is successfully compiled. The argument of the pragma is a string literal that defines the command text (with its parameters) to execute.You can put this pragma anywhere in the source code and use multiple pragmas. The compiler collects them and executes the commands in their declaration order.Here is a sample:\n.onsuccess \"expc mycode.tap\"","the-savenex-pragma#The SAVENEX pragma":"The SAVENEX pragma is used to configure ZX Spectrum Next NEX file generation parameters. This pragma is only available when compiling for the ZX Spectrum Next (Model 4). The pragma uses a declarative syntax with subcommands to specify various aspects of the NEX file format, such as the output filename, RAM configuration, border color, core version requirements, entry points, screen loading, palette data, copper code, and loading bar settings.The pragma consists of the .savenex keyword followed by a subcommand and its parameters. You can use multiple .savenex pragmas throughout your source code to build up the complete NEX file configuration. The compiler collects all these declarations and assembles them into a complete configuration object.Here are a few examples:\n.savenex file \"myprogram.nex\"\n.savenex ram 768\n.savenex border 5\n.savenex core 3, 1, 10\nFor a complete reference of all .savenex subcommands, the NEX file format, and automatic Next conveniences, see the ZX Spectrum Next documentation."}},"/z80-assembly/macros":{"title":"Macros","data":{"":"The Klive Assembler provides a powerful way to declare and apply macros in the code. While in most programming languages and assemblers, the macros are preprocessor constructs and use simple\ntext replacement, the Klive implementation is different.\nNote: Unlike in C, C++ (and some Z80 Assemblers), Klive macros emit only code (through instructions and pragmas); they cannot be used as user-defined functions. When you pass parameters to macros, any parameter expression is evaluated instantly, so you cannot use unknown symbols or variables, ones that will get their values only somewhere later in the code.","getting-started-with-macros#Getting Started with Macros":"The best way to show you what macros can do is actual code. Let's start with a simple parameterless macro:\nDelay: \n    .macro()    \n    DelayLoop:\n        djnz DelayLoop\n    .endm\nYou can easily use this macro in your code:\nld b,#24\nDelay()\n; ...and later\nld b,#44\nDelay()\nThe assembler will emit the code like this:\nld b,#24\nDelayLoop_1: djnz DelayLoop_1\n; ...and later\nld b,#44\nDelayLoop_2: djnz DelayLoop_2\nAs you expect, it takes care that the DelayLoop label remains local within the scope of the macro; otherwise, it would lead to a duplicated label name.This macro is named Delay, and it uses the value of the B register to create a djnz loop. You can easily apply this macro.Now, let's enhance this macro with an argument:\nDelay: \n    .macro(wait)    \n        ld b,{{wait}}\n    DelayLoop:\n        djnz DelayLoop\n    .endm\nAs the body of the macro suggests, {{wait}} is a placeholder for the wait argument. While other assemblers do not use a separate markup for a placeholder (they'd just use wait),  Klive applies this markup for\ntwo reasons: first, it is visually better and more eye-catching; second, it allows the compiler to provide better performance.You can use this macro passing an argument value for wait:\nDelay(#24)\nDelay(d)\nAs you expect, the compiler now emits this code:\nld b,#24\nDelayLoop_1: djnz DelayLoop_1\n; ...and later\nld b,d\nDelayLoop_2: djnz DelayLoop_2\nMacros allow you to pass anything that could be an operand in a Z80 instruction, so this is entirely valid:\nDelay((ix+23))\nAs you can imagine, this macro invocation results as if you wrote this:\nld b,(ix+23)\nDelayLoop: djnz DelayLoop\nKlive macros do not stop here. You can define macros that receive an entire Z80 instruction as an argument:\nRepeatLight: \n    .macro(count, body)    \n        ld b,{{count}}\n    DelayLoop:\n        {{body}}\n        djnz DelayLoop\n    .endm\nThis macro is to repeat the body in count several times. This is how you can invoke it:\nRepeatLight(4, \"add a,c\")\nThe second argument of the macro is a string that names the add a,c operation. The result of this macro is this set of instructions:\nld b,4\nDelayLoop_1: \n  add a,c\ndjnz DelayLoop_1\nInstead of a run time loop, you can apply a compile time loop within the macro:\nRepeatLight: \n    .macro(count, body)\n      .loop {{count}}\n          {{body}}\n      .endl\n    .endm\nThe RepeatLight(3, \"add a,c\") line invokes the macro, and the macro's body translates to this:\n.loop 3\n    add a,c\n.endl\nAs you already learned, the compiler handles this as if you wrote:\nadd a,c\nadd a,c\nadd a,c\nKlive allows you to pass a set of lines as a macro argument. You can invoke RepeatLight like this:\nRepeatLigth(3, \"add a,c\" & \"add a,10\")\nOr, you can make it with variables:\nFirstOp = \"add a,c\"\nSecondOp = \"add a,10\"\nRepeatLight(3, FirstOp & SecondOp)\nNote: The & operator between the two string values concatenates them with a next-line character set (#0A and #0D). If you apply the + operator, the above code would fail: the assembler accepts only a single instruction in a text line and would reject multiple instructions.\nIn macros, you can use several unique functions, such as lreg() and hreg(). These work during parse time and retrieve the lower and higher 8-bit register of a 16-bit register pair:\nLdHl: \n    .macro(reg16)\n        ld h,hreg({{reg16}})\n        ld l,lreg({{reg16}})\n    .endm\nHere, you can apply the LdHl macro like this:\nLdHl(de)\nLdHl(bc)\nThe compiler translates these macro invocations into these Z80 instructions:\nld h,d\nld l,e\nld h,b\nld l,c\nWhen you invoke a macro, you can pass fewer parameters than the macro declares. Within the macro body, you can use the def() function to check whether the specified parameter has been passed:\nPush:\n    .macro(r1, r2, r3, r4)\n      .if def({{r1}})\n        push {{r1}}\n      .endif\n      .if def({{r2}})\n        push {{r2}}\n      .endif\n      .if def({{r3}})\n        push {{r3}}\n      .endif\n      .if def({{r4}})\n        push {{r4}}\n      .endif\n    .endm\nThe Push macro in this code snippet allows you to create a push instruction for up to 4 register pairs. Look at these usages:\nPush(af)\n; ... and later\nPush(bc, de, ix)\nThis is what the compiler generates:\npush af\n; ... and later\npush bc\npush de\npush ix\nYou can opt not to pass a macro parameter for a specific argument. Look at this macro declaration:\nLdBcDeHl:\n    .macro(bcVal, deVal, hlVal)\n      .if def({{bcVal}})\n        ld bc,{{bcVal}}\n      .endif\n      .if def({{deVal}})\n        ld de,{{deVal}}\n      .endif\n      .if def({{hlVal}})\n        ld hl,{{hlVal}}\n      .endif\n    .endm\nYou can invoke this macro in these ways, leaving a parameter empty to sign that you do not intend to use it:\nLdBcDeHl(,#1000,#2000)\n; ... and later\nLdBcDeHl(#3000,,#4000)\nThe compiler understands your intention and generates this output:\nld de,#1000\nld hl,#2000\n; ... and later\nld bc,#3000\nld hl,#4000\nIt's time to go deep into the nitty-gritty details of creating and using macros in Klive.","macro-declaration#Macro Declaration":"Macros must have a name. Each macro is named according to the label preceding its declaration, either in the same line as the .macro token or before it as a hanging label. Macros can have zero, one, or more named arguments separated by a comma. The macro declaration is closed with the .endm token:\nMacroWithHangingLabel:\n    .macro(myParam, otherParam)\n    ; Macro body\n    .endm\nMyMacro: macro()\n    ; Macro body\n    .endm\nEven if a macro does not have arguments, its declaration must contain the parentheses.The macro body can contain Z80 instructions, pragmas, or statements. The only exceptions are the ENT and XENT pragmas.As you already experienced, the Assembler supports syntax variants for the macro-related keywords. The Assembler accepts these tokens: .macro, macro, .MACRO, MACRO, .endm, endm, .ENDM, ENDM, .mend, mend, .MEND, and MEND.Within the macro's body, you can refer to the arguments of the macros wrapping them into double curly braces:\nMul10:\n    .macro(reg8)\n    push af\n    ld a,{{reg8}}\n    add a,a\n    push bc\n    ld b,a\n    add a,a\n    add a,a\n    add a,b\n    pop bc\n    ld {{reg8}},a\n    .endm\nArguments are identifiers. Thus, the corresponding naming rules are applied to them. You cannot use a reserved word (for example, a mnemonic like ldir or a register name like hl) as a macro argument.","macro-parameters#Macro Parameters":"You can invoke a macro with as many parameters as many arguments its declaration has or even with fewer parameters. If the macro invocation has more parameters than arguments, the compiler raises an error.Let's assume you've created this macro declaration:\nMyMacro: .macro(arg1, arg2, arg2)\n; Macro body\n.endm\nAll of these usages are valid:\nMyMacro()\nMyMacro(a)\nMyMacro(a, b)\nMyMacro(a, b, c)\nNonetheless, this usage is invalid since it passes more than three parameters:\nMyMacro(a, b, c, d) ; ERROR: To many parameters\nSometimes, it is convenient to omit not the last parameters but one at the beginning or the middle of the parameter list. You can do that: an empty comma separator signs that the preceding parameter is empty. Using this\nnotation, all these invocations of MyMacro are valid:\nMyMacro(,b)\nMyMacro(a,,c)\nMyMacro(,,)\nWithin the macro declaration, you can use the def() function to check if a particular argument has a value.\nLdBcDeHl:\n    .macro(bcVal, deVal, hlVal)\n      .if def({{bcVal}})\n        ld bc,{{bcVal}}\n      .endif\n      .if def({{deVal}})\n        ld de,{{deVal}}\n      .endif\n      .if def({{hlVal}})\n        ld hl,{{hlVal}}\n      .endif\n    .endm\nThe def() function accepts only a macro argument reference (the argument's name wrapped in double curly braces). This function evaluates to true only when the macro argument is not empty.You can use the logical NOT operator (!) combined with def() to check if an argument is empty.\nMyMacro: .macro(arg)\n  .if !def({{arg}})\n    ; generate something for empty arg\n  .endif\n.endm","passing-parameters-to-macros#Passing Parameters to Macros":"You can pass anything as a macro parameter that is a valid operand of a Z80 instruction:\nNames of 8-bit registers and 16-bit register pairs (e.g. a, b, ixl, hl sp, af, etc.)\nNames of conditions (e.g. z, nz, pe, m, etc.)\nMemory address indirection (e.g. (#4000), (#4000+#20))\nRegister pair indirection (e.g. (bc), (de), (hl), etc.)\nIndexed indirection (e.g. (ix+#20), (iy-12), etc.)\nC-port ((c))\nExpression (e.g. (MyId << 1) + 23, #4000, 12*sin(pi()/4), \"ld \" + \"a,b\", etc.)\nYou should be careful when you use parentheses in expressions. Let's assume you declare this macro:\nSetHlValue:\n    .macro(value)\n        ld hl,{{value}}\n    .endm\nWhen you use it, the first invocation uses an expression, and the second has a memory address indirection:\nSetHlValue(#4000+#20)\nSetHlValue((#4000+#20))\nThe compiler translates them to these instructions:\nld hl,#4020\nld hl,(#4020)\nTo avoid such issues, you can use the square brackets to group parts of expressions. When you invoke the SetHlValue macro with this way, both usage with generate a ld hl,#4020 statement:\nSetHlValue(#4000+#20)\nSetHlValue([#4000+#20])\nNote: When you pass parameters to macros, any parameter expression is evaluated instantly, so you cannot use unknown symbols or variables (ones that will get their values only somewhere later in the code.)\nThe compiler replaces the macro argument references to their current values passed in parameters. Whenever you use an expression, its value is converted into a string and put into the place of the macro argument.","passing-instructions-in-a-macro-parameter#Passing Instructions in a Macro Parameter":"Within a macro declaration, you can use a macro argument reference instead of an entire Z80 instruction. Take a look at this macro:\nShortDi:\n    .macro(body)\n        di\n        {{body}}\n        ei\n    .endm\nHere, the body argument is expected to get something the compiler can understand as an entire instruction. When you invoke the macro, you need to pass a string expression so that the compiler can replace the {{body}} reference. Here is an example:\nShortDi(\"in a,(#fe)\")\nAs you expect, the compiler generates this output:\ndi\nin a,(#fe)\nei\nYou are not obliged to use Z80 instructions; the compiler accepts pragmas, too:\nShortDi(\".db #00\")\nWell, the output is not pretty useful; nonetheless, the compiler generates this:\ndi\n.db #00\nei","passing-multiple-lines-in-a-macro-parameter#Passing Multiple Lines in a Macro Parameter":"If you pass multiple lines in a macro parameter where the corresponding argument reference is used instead of an entire instruction line, the compiler will apply all those lines. In this case, the individual lines should be separated by new line characters (\\r\\n). The & operator, when applied for two strings, does this step for you, as it concatenates the two strings with \\r\\n between them. Let's assume you invoke the ShortDi macro with this code:\nShortDi(\"ld a,#7f\" & \"in a,(#fe)\")\nNow, the compiler will generate this output:\ndi\nld a,#7f\nin a,(#fe)\nei\nBecause you can pass expressions as macro parameters, you can invoke the macro in this way, too:\nFirstOp = \"ld a,#7f\"\nSecondOp = \"in a,(#fe)\"\nShortDi(FirstOp & SecondOp)\nYou can pass not only instructions and pragmas to macros but also statements:\nLoopOp = \".loop 3\" & \"nop\" & \".endl\"\nShortDi(LoopOp)\nThe compiler will emit this code:\ndi\nnop\nnop\nnop\nei","labels-symbols-and-variables-in-macros#Labels, Symbols, and Variables in Macros":"Macros have a local scope for all labels, symbols, and variables created within their body, including the label attached to the .endm statement. The macro's name is a label that also represents the start of the macro.Take a look at this macro definition:\nGetBoundaries:\n    .macro(instr)\n        {{instr}}\n        ld de,EndLabel\n        ld hl,GetBoundaries\nEndLabel:\n    .endm\nHere, the ld hl,GetBoundaries instruction fills HL with the start address of the macro, while the ld de,EndLabel instruction puts the address of the next instruction following the macro into DE.Let's assume you use the macro this way:\n.org #8000\nGetBoundaries(\"nop\")\nGetBoundaries(\"ld ix,#ABCD\")\nThe compiler will create this output:\n#8000 GetBoundaries_1 nop\n#8001                 ld de,#8007 ; EndLabel_1\n#8004                 ld hl,#8000 ; GetBoundaries_1\n#8007 EndLabel_1\n      GetBoundaries_2 ld ix,#ABCD\n#800B                 ld de,#8011 ; Endlabel_2\n#800E                 ld hl,#8007 ; GetBoundaries_2\n#8011 EndLabel_2\nSymbols and variables within the context work exactly as they do with loops. Remember: Symbols are constant values, while variables may change!","invoking-macros-from-macros#Invoking Macros from Macros":"Klive allows you to invoke a macro from another macro, too. Here is a short sample:\nDelay:\n    .macro(wait)\n        ld b,{{wait}}\n        WaitLoop: djnz WaitLoop\n    .endm\nBorderPulse:\n    .macro(col1, wait1, col2, wait2)\n        ld a,{{col1}}\n        out (#fe),a\n        Delay({{wait1}})\n        ld a,{{col2}}\n        out (#fe),a\n        Delay({{wait2}})\n    .endm\nHere, the BorderPulse macro uses Delay as a helper macro. The BorderPulse(2, 10, 3, 20) invocation produces this output:\nld a,2\nout (#fe),a\nld b,10\nWaitLoop_1: djnz WaitLoop_1\nld a,3\nout (#fe),a\nld b,20\nWaitLoop_2: djnz WaitLoop_2","macro-related-parse-time-functions#Macro-Related Parse-Time Functions":"The Klive Assembler allows several parse-time functions with macro arguments similar to the def() function to check whether a macro argument has been passed to the macro invocation.These functions check if the argument is an operand the name of the function suggests. Each of them returns true, provided the function recognizes the operand; otherwise, false.The Assembler supports these functions:\nName\tDescription\tisreg8std()\tThe operand is an 8-bit register, one of these: a, b, c, d, e, h, l, i, r, xh (ixh), xl (ixl), yh (iyh), or yl (iyl)\tisreg8std()\tThe operand is a standard 8-bit register, one of these: a, b, c, d, e, h, or l\tisreg8spec()\tThe operand is a special 8-bit register, i, or r\tisreg8idx()\tOne of these 8-bit index registers: xh (ixh), xl (ixl), yh (iyh), or yl (iyl)\tisreg16()\tAny of these 16-bit registers: af, bc, de, hl, sp, ix or iy\tisreg16std()\tAny of the standard 16-bit registers: bc, de, hl, or sp\tisreg16idx()\tAny of the ix or iy registers\tisregindirect()\tThe operand is one of these: (bc), (de), (hl), or (sp)\tisindexedaddr()\tThe operand is an indexed address like (ix), (iy), (ix+#12), (iy-#23), and so on\tiscport()\tThe operand is (c) (e.g., in the out (c),a instruction)\tiscondition()\tThe operand is one of these conditions: z, nz, c, nc, po, pe, p, or m\tisexpr()\tThe operand is an expression, for example: 1 + 2, #1000, myvalue + 23, etc.\tisreg<reg>()\tThe operand is the register as given in <reg>. You can use these names: a, af, b, c, bc, d, e, de, h, l, hl, i, r, xh, xl, ix, yh, yl, iy, and sp. For example, isrega() tests if the specified register is A.\t\nNote: When you pass 'c' as a macro argument, both the isreg8() and iscondition() parse-time functions accept it, as the 'c' token can be either an 8-bit register or a condition (carry flag is set).\nHere is a short sample:\nMyRegMacro: .macro(arg)\n    .if isreg8({{arg}})\n        ld a,{{arg}}\n    .else\n        .error \"Only 8-bit registers are allowed\"\n    .endif\n.endm\nMyRegMacro allows using only an 8-bit register as its argument. If you provide another type of parameter, the macro raises an error."}},"/z80-assembly/statements":{"title":"Assembler Statements","data":{"":"Statements are Klive Assembler-specific control flow constructs that instruct the compiler about loop-like and conditional compilation. Thanks to Simon Brattel for the inspiration.\nNote: While directives help you to organize your code and include code files optionally according to the compilation context, statements provide you with more valuable tools to shorten the way you can declare Z80 assembly code.\nEach statement can be written with a leading dot or without it, and the compiler accepts both lowercase and uppercase versions. For example, all of these versions are valid: .if, if, .IF, and IF.","the-loop-block#The LOOP Block":"With the LOOP block, you can organize a cycle to emit code. Here is a sample that tells the gist:\n.loop 6\n  add hl,hl \n.endl\nThis construct is a shorter way to multiply HL with 64. It is equivalent to the following code:\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\nThe .loop statement accepts an expression. The compiler repeats the instructions within the\nloop's body according to the value of the expression. The .endl statement marks the end of the loop.\nNote: You can use many flavors for the .endl block closing statement. .endl, endl, .lend, lend are all accepted — with uppercase letters, too.\nLook at this code:\ncounter .equ 2\n; do something (code omitted)\n.loop counter + 1\n  .db #80, #00\n.endl\nThis code is as if you wrote this:\n  .db #80, #00\n  .db #80, #00\n  .db #80, #00","the-loop-scope#The LOOP Scope":"The .loop statement declares a scope for all labels, symbols, and variables in the loop's body. Every iteration has its separate local scope. When the assembler resolves symbols, it starts from the loop's scope and tries to resolve the symbol's value. If the lookup fails, it steps out to\nthe outer scope, and goes on with the resolution.Check this code:\nvalue .equ 2\n; do something (code omitted)\n.loop 2\n    value .equ 5\n    ld a,value\n.endl\nThe compiler takes it into account as if you wrote this:\n    ld a,5\n    ld a,5\nThe value symbol declared within the loop overrides value in the outer scope, and thus, 5 is used instead of 2.Nonetheless, when you utilize a different construct, it seems a bit strange at first:\nvalue .equ 2\n; do something (code omitted)\n.loop 2\n    ld a,value\n    value .equ 5\n    ld b,value\n.endl\nThe strange thing is that the compiler creates this:\n    ld a,2\n    ld b,5\n    ld a,2\n    ld b,5\nWhen the assembler resolves value in the ld a,value instruction, if finds value in the outer scope only, as it is not declared yet within the loop's scope. In the ld b,value instruction value gets resolved from the inner scope and takes 5.","variables-and-scopes#Variables and Scopes":"Unlike symbols that work as constant values, variables (declared with the .var pragma or its syntactical equivalents, the = or := tokens) can change their values.Take a look at this code:\ncounter = 4\n.loop 3\n    innercounter = 4\n    ld a,counter + innercounter\n    counter = counter + 1\n.endl\nHere, the counter variable is defined in the global scope (out of the loop's scope), while innercounter in the local scope of the loop. When evaluating the counter = counter + 1 statement, the compiler finds counter in the outer scope, so it uses that variable to increment its value. This code emits machine code for this source:\nld a,#08\nld a,#09\nld a,#0A\nNow, add a single line to the loop's code:\ncounter = 4\n.loop 3\n    innercounter = 4\n    ld a,counter + innercounter\n    counter = counter + 1\n.endl\nld b,innercounter\nThe compiler will not compile this code, as it cannot find the value for innercounter in the ld b,innercount instruction. Because innercounter is defined in the local scope of the loop, this scope is immediately disposed as the loop is completed. When the compiler processes the ld b,innercounter instruction, the local scope is not\navailable.","labels-and-scopes#Labels and Scopes":"Labels behave like symbols, and they work similarly. When you create a label within a loop, that label is created in\nthe local scope of the loop. The following code helps you understand which labels are part of the global scope and which are created in the loop's scope:\n.org #8000\nMyLoop: .loop 2\n    ld bc,MyLoop\nInner: \n    ld de,MyEnd\n    ld hl,Inner\n    ld ix,Outer\nMyEnd: .endl\nOuter: nop\nThe label of the .loop statement is part of the outer (global) scope, just like the label that follows the\n.endl statement. However, all labels declared within the loop's body, including the label of the .endl statement, belong to the local scope of the loop.Thus, the compiler translates the code above into this one:\n         (#8000): ld bc,#8000 (MyLoop)\nInner_1  (#8003): ld de,#800D (MyEnd_1)\n         (#8006): ld hl,#8003 (Inner_1)\n         (#8009): ld ix,#801A (Outer)\nMyEnd_1  (#800D): ld bc,#8000 (MyLoop)\nInner_2  (#8010): ld de,#801A (MyEnd_2)\n         (#8013): ld hl,#8010 (Inner_2)\n         (#8016): ld ix,#801A (Outer)\nMyEnd_2\nOuter    (#801A): nop\nHere, Inner_1, Inner_2, MyEnd_1, and MyEnd_2 represent the labels created in the local scope of the loop. The _1 and _2 suffixes indicate that each loop iteration has a separate local scope. As you can see, the last iteration of MyLabel points to the first outer address (Outer label).","nesting-loops#Nesting LOOPs":"Of course, you can nest loops, such as in this code:\n.loop 3\n  nop\n  .loop 2\n    ld a,b\n  .endl\n  inc b\n.endl\nThis code snippet translates to this:\nnop\nld a,b\nld a,b\ninc b\nnop\nld a,b\nld a,b\ninc b\nnop\nld a,b\nld a,b\ninc b\nWhen you nest loops, each loop has its separate scope.","the-cnt-value#The $CNT value":"It is handy to use the $cnt value that represents the current loop counter. It starts from 1 and increments to the maximum number of loops. This sample demonstrates how you can use it:\n.loop 2\n  outerCount = $cnt\n  .loop 3\n     .db #10 * outerCount + $cnt\n  .endl\n.endl\nThis code translates to this:\n.db #11\n.db #12\n.db #13\n.db #21\n.db #22\n.db #23\nYou can observe that each loop has its separate $cnt value.\nNote: The $cnt value has several syntax versions that the compiler accepts: $CNT, .cnt, and .CNT.","the-procendp-block#The PROC..ENDP Block":"In the previous section, you could understand how labels and scopes work for the .loop statement. You can utilize this scoping mechanism with the help of the .proc...endp statement. This sample code demonstrates the concepts (just as you learned earlier):\n.org #8000\nMyLabel:\n  ld de,Outer\n  ld hl,Mylabel\n  call MyProc\n  halt\nMyProc: \n  .proc\n    ld bc,MyProc\n  MyLabel: \n    ld de,MyEnd\n    ld hl,MyLabel\n    ld ix,Outer\n    ret\nMyEnd:\n    .endp\nOuter: nop\nThe first MyLabel label belongs to the global scope, while the second (within MyProc) to the local scope of the procedure wrapped between .proc and endp. MyProc belongs to the global scope, too, however, MyEnd is part of the MyProc scope, so it is visible only from\nwithin the procedure.The assembler emits this code:\nMyLabel  (#8000): ld de,#8018 (Outer)\n         (#8003): ld hl,#8000 (MyLabel)\n         (#8006): call #800A (MyProc)\n         (#8009): halt\nMyProc   (#800A): ld bc,#800A (MyProc)\nMyLabel_ (#800D): ld de,#8018 (MyEnd)\n         (#8010): ld hl,#800D (MyLabel_)\n         (#8013): ld ix,#8018 (Outer)\n         (#8017): ret\nMyEnd\nOuter    (#8018): nop\nYou can nest PROC blocks just as LOOP blocks. Each PROC block has its private scope. When the compiler sees a PROC block, it works as if you wrote .loop 1.\nNote: PROC is different than a loop. You cannot use the $cnt value. Similarly, the break and continue instructions are unavailable within a PROC block.\nNote: The assembler accepts these aliases for PROC and ENDP: .proc, proc, .PROC, PROC, .endp, .ENDP, endp, ENDP, .pend, .PEND, pend, and PEND.","the-repeatuntil-block#The REPEAT..UNTIL Block":"While the .loop statement works with an expression that specifies the loop counter, the .repeat...until block uses an exit condition to create more flexible loops. Here is a sample:\ncounter = 0\n.repeat \n    .db counter\n    counter = counter + 3\n.until counter % 7 == 0\nThe counter % 7 == 0 condition specifies when to exit the loop. Because the exit condition is examined only at the end of the loop, the .repeat blocks execute at least once.The sample above translates to this:\n.db 0\n.db 3\n.db 6\n.db 9\n.db 12\n.db 15\n.db 18\nThe .repeat block uses the same approach to handle its local scope, symbols, labels, and variables as the .loop block. The block also provides the $cnt loop counter that starts from 1 and increments in every loop cycle.This sample demonstrates the .repeat block in action:\n.org #8000\ncounter = 0\n.repeat \n    .db low(EndLabel), high(Endlabel), $cnt\n    counter = counter + 3\nEndLabel: .until counter % 7 == 0\nThe compiler translates the code to this:\n.db #03, #80, #01\n.db #06, #80, #02\n.db #09, #80, #03\n.db #0C, #80, #04\n.db #0F, #80, #05\n.db #12, #80, #06\n.db #15, #80, #07","the-whileendw-block#The WHILE..ENDW Block":"With .while loop, you can create another kind of block, which uses an entry condition. For example, the following code snippet generates instructions to create the sum of numbers from 1 to 9:\ncounter = 1\n    ld a,0\n.while counter < 10\n    add a,counter\n    counter = counter + 1\n.endw\nThe .while...endw block uses an entry condition declared in the .while statement. Provided this condition is true, the compiler enters into the body of the loop and compiles all instructions and statements\nuntil it reaches the .endw statement. The body of the loop may never be reached.The compiler translates the code snippet above to the following:\nld a,0\nadd a,1\nadd a,2\nadd a,3\nadd a,4\nadd a,5\nadd a,6\nadd a,7\nadd a,8\nadd a,9\nLike the .loop and the .repeat blocks, .while uses the same approach to handle its local scope, symbols, labels, and variables. This block also provides the $cnt loop counter that starts from 1 and increments in every loop cycle.This code demonstrates the .while block with labels and using the $cnt value:\ncounter = 0\n.while counter < 21 \n    .db low(EndLabel), high(Endlabel), $cnt\n    counter = counter + 3\nEndLabel: .endw\nThe compiler translates the code to this:\n.db #03, #80, #01\n.db #06, #80, #02\n.db #09, #80, #03\n.db #0C, #80, #04\n.db #0F, #80, #05\n.db #12, #80, #06\n.db #15, #80, #07\nNote: You can use many flavors for the .endw block closing statement. .endw, endw, .wend, and wend are all accepted — with uppercase letters, too.","the-fornext-loop#The FOR..NEXT Loop":"You can use the traditional .for...next loop to create a loop:\n.for myVar = 2 .to 5\n  .db 1 << int(myVar)\n.next\nThis loop uses the myVar variable as its iteration variable, which iterates from 1 to 4. As you expect, the compiler translates the for-loop into this:\n.db #04\n.db #08\n.db #10\n.db #20\nYou can specify a .step close to change the loop increment value:\n.for myVar = 1 .to 7 .step 2\n  .db 1 << int(myVar)\n.next\nNow, the code translates to this:\n.db #02\n.db #08\n.db #20\n.db #80\nYou can create a loop with decrementing iteration variable value:\n.for myVar = 7 .to 1 .step -2\n  .db 1 << int(myVar)\n.next\nAs you expect, now you get this translation:\n.db #80\n.db #20\n.db #08\n.db #02\nNote: As with the other statements, you can use the .for, .to, and .step keywords without the . prefix, so for, to, and step are also valid.\nThe for-loop can do the same stunts as the other loops; it handles labels, symbols, and variables similarly. There's only one exception: the loop iteration variable. If this variable is found in an outer scope, instead of using that value, the compiler raises an error. You can use the for-loop only with a freshly created variable.So, both cases in this code raise an error:\nmyVar = 0\n.for myVar = 1 .to 4 ; ERROR: Variable myVar is already declared\n  ; ...\n.next\n.for _i = 1 .to 3\n  .for _i = 3 .to 8 ; ; ERROR: Variable _i is already declared\n    ; ...\n  .next\n.next\nNote: As i is a reserved token (it represents the I register), you cannot use i as a variable name. Nonetheless, _i is a valid variable name.\nThe for-loop works with both integer and float variables. If the initial value, the last value (the one after .to), or the increment value (the one after .step) is a float value, the for-loop uses float operations; otherwise, it uses integer operations.This code snippet demonstrates the difference:\n.for myVar = 1 .to 4 .step 1\n  .db 1 << myVar\n.next\n.for myVar = 1 .to 4 .step 1.4\n  .db 1 << myVar ; ERROR: Right operand of the shift left operator must be integral\n.next\nNonetheless, you can solve this issue by applying the int() function:\n.for myVar = 1 .to 4 .step 1.4\n  .db 1 << int(myVar) ; Now, it's OK.\n.next\nNote: You can still use the $cnt value in for loops. Just like with other loops, it indicates the count of cycles starting from one and incremented by one in each iteration.","maximum-loop-count#Maximum Loop Count":"It's pretty easy to create an infinite (or at least a very long) loop. For example, these loops are infinite ones:\n.repeat\n.until false\n.while true\n.wend \nThe assembler checks the loop counter during compilation. Whenever it exceeds #FFFF (65535), it raises an error.","the-ifelifelseendif-statement#The IF..ELIF..ELSE..ENDIF Statement":"You can use the .if statement to create branches with conditions. For example, this code emits inc b or inc c statement depending on whether the value of branch is even or odd:\n.if branch % 2 == 0\n  inc b\n.else\n  inc c\n.endif\nYou do not have to specify an .else branch, so this statement is entirely valid:\n.if branch % 2 == 0\n  inc b\n.endif\nYou can nest if statements like this to manage four different code branches according to the value of branch:\n.if branch == 1\n  inc b\n.else\n  .if branch == 2\n    inc c\n  .else \n    .if branch == 3\n      inc d\n    .else\n      inc e\n    .endif\n  .endif\n.endif\nNonetheless, you can use the .elif statement to create the code snippet above more clearly:\n.if branch == 1\n  inc b\n.elif branch == 2\n  inc c\n.elif branch == 3\n  inc d\n.else\n  inc e\n.endif","if-and-scopes#IF and Scopes":"Unlike the loop statements, .if does not provide its local scope. Whenever you create a symbol, a label, or a variable, those get into the current scope. This code defines a label with the same name in each branch. Because the compiler evaluates the .if branches from top to down, it either compiles one of the .elif branches —\nthe first with a matching condition — or the else branch. Thus, this code does not define MyLabel twice:\nbranch = 4 ; Try to set up a different value\n; Do something (omitted from code)\n    ld hl,MyLabel\n.if branch == 1\n  inc b\n  MyLabel ld a,20\n.elif branch > 2\n  MyLabel ld a,30\n  inc c\n.elif branch < 6\n  inc d\n  MyLabel ld a,40\n.else\n  MyLabel ld a,50\n  inc e\n.endif\nGenerally, you can decorate any statement with labels. The .elif and .else statements are exceptions. If you do so, the compiler raises an error:\n.if branch == 1\n  inc b\n  MyLabel ld a,20\n.elif branch > 2\n  MyLabel ld a,30\n  inc c\nOther .elif branch < 6 ; ERROR: ELIF section cannot have a label\n  inc d\n  MyLabel ld a,40\nAnother .else          ; ERROR: ELSE section cannot have a label\n  MyLabel ld a,50\n  inc e\n.endif","if-nesting#IF Nesting":"When you nest .if statements, ensure each has a corresponding .endif. Whenever the compiler finds an .endif, it associates it with the closest .if statement before .endif. Use indentation to make the structure more straightforward, as the following code snippet shows:\nrow = 2\ncol = 2\n; Change row and col (omitted from code)\n.if row == 0\n  .if col == 0\n    .db #00\n  .elif col == 1\n    .db #01\n  .else\n    .db #02\n  .endif\n.elif row == 1\n  .if col == 0\n    .db #03\n  .elif col == 1\n    .db #04\n  .else\n    .db #05\n  .endif\n.elif row == 2\n  .if col == 0\n    .db #06\n  .elif col == 1\n    .db #07\n  .else\n    .db #08\n  .endif\n.else\n  .if col == 0\n    .db #09\n  .elif col == 1\n    .db #0A\n  .else\n    .db #0B\n  .endif\n.endif","the-ifusedifnused-statements#The IFUSED/IFNUSED Statements":"Klive offers a similar construct to IF..ELIF..ELSE..ENDIF, using the IFUSED or IFNUSED statement instead of IF. These new statements are specialized forms of IF. You can use these statements to emit code depending on whether a symbol (label, .EQU, .VAR, structure, or structure field) exists and has already been used by the code preceding the IFUSED/IFNUSED statement.Here are a few examples:\nMyProc:\n  ld hl,#5800\n  ld (hl),a\n  ret\n  ; some other code\n  .ifused MyProc\n    MyMsg: .defn \"MyProc is used\"\n  .else\n    MyMsg: .defn \"MyProc is not used\"\n  .endif\nMain:\n  ld hl,MyMsg\nHere, the .ifused statement will set the string the MyMsg label point to according to whether the MyProc label is used. As in this case, MyProc is defined but not invoked before the .ifused statement, HL will point to the \"MyProc is not used\" message.Should you call MyProc before .ifused, HL would point to the other message, \"MyProc is used\":\nMyProc:\n  ld hl,#5800\n  ld (hl),a\n  ret\n  ; some other code\n  call MyProc\n  ; some other code\n  .ifused MyProc\n    MyMsg: .defn \"MyProc is used\"\n  .else\n    MyMsg: .defn \"MyProc is not used\"\n  .endif\nMain:\n  ld hl,MyMsg\nThe .ifnused statement is the complement of .ifused. It is evaluated to a true condition value only if the symbol following .ifnused is not defined or, if defined, is not used.","ifusedifnused-syntax#IFUSED/IFNUSED Syntax":"You must specify a symbol after the .ifused  or .ifnused keywords. These symbols must follow the syntax of identifiers. They can be compound names used for modules and structures. So, all of these symbol names are correct:\nMyLabel\nMyStruct\nMyStruct.FieldX\nMyModule.Main\n::NestedModule.Start.MyProc\nNote: You can use these aliases for .ifused: .IFUSED, ifused, IFUSED. Similarly, .ifnused accept alternative tokens: .IFNUSED, ifnused, and IFNUSED.","ifusedifnused-semantics#IFUSED/IFNUSED Semantics":"The Klive Assembler accepts any .ifused and .ifnused statements until they are syntactically correct. When the assembler tests their condition, it works this way:\nIf the specified symbol does not exist, .ifused evaluates to false, while .ifnused evaluates to true.\nIf the particular symbol exists and is used in the code section preceding the .ifused or .ifnused statement, .ifused evaluates to true, and .ifnused to false.\nIf the particular symbol exists and it is not used in the code section preceding the .ifused or .ifnused statement, .ifused evaluates to false, .ifnused to true.\nThese statements do not support the look-ahead in the code. This behavior could lead to paradoxical situations, like in this example:\nMyFlag = true\nMyValue: .equ #1234\n  ; some other code that does not use MyValue\n  .ifused MyValue\n    MyFlag = false;\n  .endif\n  ; some other code that does not change MyFlag\n  .if MyFlag\n    ld a,MyValue\n  .endif\nShould .ifused work with look-ahead, this code would make the compiler scratch its virtual head. Because MyFlag is set to true, the .if statement at the bottom of the code would emit an ld a,MyValue instruction. The compiler would say that .ifused MyValue should be considered true. However, in this case, the body .ifused would set MyFlag to true, and that would prevent the bottom .if from emitting ld a,MyValue, and then MyValue would not be used at all.","block-statements-without-a-closing-statement#Block Statements without a Closing Statement":"The compiler automatically recognizes if a block does not have a closing statement and provides an error message accordingly.","orphan-closing-statements#Orphan Closing Statements":"When the compiler finds a closing statement (such as .endw, .endl, .until, .endif, etc.) it will issue an error.","the-break-statement#The BREAK statement":"You can exit the loop — independently of the loop's exit condition — with the .break statement:\n; LOOP sample\n.loop 5\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.endl\n; REPEAT sample\n.repeat\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.until $cnt == 5\n; WHILE sample\n.while $cnt < 5\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.endw\n; FOR-loop sample\n.for value = 1 to 5\n  .if value == 4\n    .break\n  .endif\n  .db value\n.next\nBecause all these loops are exited at the beginning of the 4th iteration, they produce this output:\n.db #01\n.db #02\n.db #03\nNote: You cannot use the .break statement outside a loop construct. If you do so, the compiler raises an error.","the-continue-statement#The CONTINUE Statement":"You can interrupt the current iteration of the loop and carry on the next iteration with the .continue statement:\n; LOOP sample\n.loop 5\n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.endl\n; REPEAT sample\n.repeat\n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.until $cnt == 5\n; WHILE sample\n.while $cnt <= 5 \n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.endw\n; FOR-loop sample\n.for value = 1 to 5\n  .if value == 4\n    .continue\n  .endif\n  .db value\n.next\nBecause all these loops skip the 4th iteration, they produce this output:\n.db #01\n.db #02\n.db #03\n; #04 is skipped\n.db #05\nNote: You cannot use the .continue statement outside of a loop construct. If you do so, the Assembler raises an error."}},"/z80-assembly/structs":{"title":"Structures","data":{"":"Klive allows you to use structure definitions and placements in your Z80 programs. If you know the struct construct from C, C++, or C#, the concept in Z80 is only partly similar.","understanding-structures#Understanding Structures":"In Klive Assembler, a structure definition is a placeholder that defines a byte pattern like this:\nObject2D: .struct\n    .defw 0\n    .defw 0\n    .defb 1\n    .defb 1\n  .ends\nThis definition says that Object2D is a structure of six bytes (two 16-bit words and two 8-bit bytes) with the following bytes emitted: #00, #00, #00, #00, #01, #01. Whenever you place a structure declaration in a program, just like in this sample, the assembler will emit the bytes you specified in the .struct definition:\n  Object2D() ; emits #00, #00, #00, #00, #01, #01\nAs you can see, six subsequent bytes do not tell enough about the semantics of Object2D. When we created this structure, the original concept was to use two 16-bit numbers to specify the X and Y coordinates of the object, plus two 8-bit numbers to describe its horizontal and vertical velocity. With field definitions (see X, Y, DX, and DY), the meaning of Object2D is more straightforward than it was before:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nOf course, we would like to initialize objects with different states. With field initializers, we can define structures with initial states that are different from the .struct definition:\nApple: Object2D()\n  X -> .defw 100\n  Y -> .defw 100\nPear: Object2D()\n  DX -> .defb -1\n  DY -> .defb -1\n  ; Some other code\n  ; ...\n  ld hl,Apple\n  ld de,Pear\nIn this sample, the Apple label (that the code later loads into HL) points to an Object2D declaration that holds 100 in its X and Y values. Another label, Pear, points to a different instance of Object2D (later, the code loads that address into DE). Pear has a converse velocity compared to Apple.The Assembler allows you to initialize structures with any pragma that emits bytes to the assembly output. For example, the following code snippet sets a new Object2D structure in a particular way:\nBanana: Object2D()\n  -> .defb 10, 1\n  -> .defb 12, 2\n  DX -> .defb 2, 2\nThe first .defb pragma (right after the first ->) emits two bytes, 10 and 1, respectively, and it sets the X field to 266 (10 + 1256). The second .defb sets Y to 524 (12 * 2256). The initialization of DX (DX -> .defb 2, 2) emits two bytes and sets both DX and DY to 2.","structure-definition#Structure Definition":"You can define structure between the .struct and .ends  statements. Each structure must have a unique name to declare with a label. The compiler accepts all of these definitions:\n; Version #1\nMyStruct .struct\n  ; ...\n  .ends\n; Version #2\nMyStruct: .struct\n  ; ...\n  .ends\n; Version #3\nMyStruct\n  .struct\n  ; ...\n  .ends\n; Version#4\nMyStruct:\n  .struct\n  ; ...\n  .ends\nNonetheless, it raises an error if you do not name the structure:\n.struct ; ERROR: .struct must have a name\n; ...\n.ends\nNote: The assembler accepts the following alternative keywords for .struct: .STRUCT, struct, or STRUCT. Similarly, .ends has these aliases, too: .ENDS, ends, and ENDS. Though you can define an empty structure, there is no practical reason to do so.\nIn the body of the structure, you can use only one of these byte-emitter pragmas: .defb, .defw, .defm, .defn, .defc, .defs, .fillb, .fillw, .defg,  or .defgx. If you try to use any other construct, the compiler raises an error message.As you saw earlier, you can specify field labels within the structure body. The assembler is flexible: you can omit field labels or even use multiple labels for a single field:\nObject2D_A: .struct\n  Coords:\n    X: .defw 0\n    Y: .defw 0\n  Velocity:\n    .defb 1\n    .defb 1\n  .ends\nHere, Object2D_A has two field name for the first .defw field, Coords, and X, respectively. The last .defb does not have its field name, unlike the one before, Velocity.","labels-and-field-names#Labels and Field Names":"The label assigned to the .struct definition has a dual role. When used in a structure initialization (for example, as Object2D is utilized in the Object2D() initializer), it identifies the structure. Nonetheless, you can use the label name in Z80 instructions, too. In this case, the label's value is the size of the structure. For example, these instructions are equivalent, as the size of the Object2D structure is six bytes:\nld a,Object2D ; Size of Object2D\n; ...\nld a,6 ; \nYou can allocate a memory block for 100 uninitialized instances of Object2D with this pragma:\nMy100Objects:\n  .defs 100 * Object2D\nNote: You cannot assign a label to the .ends statement. If you do, the compiler throws an error.\nLabels assigned to the body of the .struct definition are used as field names. You can use them only with the structure name:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nApple: Object2D()\n  ; ...\n  ld hl,Apple + Object2D.DX\n  ld a,(hl)\nField label values contain the offset of the particular field from the beginning of the structure. Thus, the last two instructions in the code above load the content of the Apple structure's DX field into A.According to these definitions, here are the field label values of Object2D:\nObject2D.X: 0\nObject2D.Y: 2\nObject2D.DX: 4\nObject2D.DY: 5","structure-initialization#Structure initialization":"The .struct definition does not emit any code; it just tells the compiler the layout and initial contents of a structure. To allocate space for a particular structure, you need to initialize it with the name of the structure plus a pair of opening and closing parentheses, just like these samples show:\n; Initalize an Object2D\nMyObject: Object2D()\n; Initialize another one\nOtherObject: Object2D()\nWhen you add a label to the structure initialization, that label's value points to the beginning of the structure in the memory.\nstart: .org #8000\nDistanceEntry:\n  .struct\n    Address: .defw $\n    SeqNo: .defb Index\n  .ends\nData: .org #9000\nIndex = 1;\nEntry1:\tDistanceEntry()\nIndex = 2;\nEntry2:\tDistanceEntry()\nIndex = 3;\nEntry3:\tDistanceEntry()\nThe compiler emits the initialization code for Entry1, Entry2, and Entry3 as if you wrote this:\nData .org #9000\nEntry1:\n  .defw #9000\n  .defb 1\nEntry2:\n  .defw #9003\n  .defb 2\nEntry3:\n  .defw #9006\n  .defb 03","field-initializers#Field Initializers":"Field initializers can be used to change the default structure initializer. A field initializer has this syntax:[identifier] -> byte-emitter-pragmaFor a moment, let's forget that identifier is optional. When you use it, it must be one of the structure's field names. The byte-emitter-pragma is one of the Klive pragmas you can use to define a structure body, namely these:  .defb, .defw, .defm, .defn, .defc, .defs, .fillb, .fillw, .defg,  or .defgx.\nNote: You can use the label syntax for field names; thus, you can add an optional colon after the identifier.\nYou can apply field initializer statements right after the structure initialization. Any other Z80 instruction, pragma, statement, or directive signs the end of the structure initialization. This code snippet shows two examples of setting up Object2D structures. The first is correct; however, the second one raises an error:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nObj1: Object2D()\n  DX -> .defb 2\n  DY -> .defb 2\n  ld a,b\n  ; ... Some other code\nObj2: Object2D()\n  X -> .defw 100\n  Y -> .defw 100\n  ld hl,#4000    ; Field initialization stops here\n  DX -> .defb 4  ; ERROR\nThe compiler does not care how you initialize fields. For example, even if you have created the X field of Object2D with a .defw pragma, you can set its value with .defb, like in this example:\nObj3: Object2D()\n  X -> .defb 100, 0\nYou can even initialize two fields with a simple initializer statement. For example, DX and DY are one byte each. You can initialize both of these fields in a single step, as these code snippet shows:\nObj4: Object2D()\n  DX -> .defb 2,2\nObj5: Object2D()\n  DX -> .defw #0202\nThe order of fields is unimportant; you can initialize them in any order:\nObj6: Object2D()\n  DX -> .defb 1\n  X -> .defw 100\n  DY -> .defb 1\n  Y -> .defw 200","fluent-structure-initialization#Fluent Structure Initialization":"The assembler allows flexible initialization, where you do not use field names. The compiler emits bytes as the byte emitter pragmas would do if you were not within a structure initialization. Let's assume you initialize an Object2D this way:\nObj7: Object2D()\n  -> .defb 1, 0\n  DX -> defw #0303\nWithout the field initializers, the structure would contain these six bytes:#00, #00, #00, #00, #01, #01However, the field initializers overwrote the default bytes with the ones displayed in boldface:#01, #00, #00, #00, #03, #03You can choose your preferred way to initialize a structure using a field or unnamed initializers. The compiler does not care how you assemble the set of bytes within the structure. However, it does not allow you to overflow the structure boundaries. This sample shows you two initializations of Object2D. The first is correct, as it emits exactly six bytes. However, the second raises an error since the initialization tries to put eight bytes into the structure:\nObj8: Object2D()\n  -> .defm \"012345\"\nObj9: Object2D()    ; ERROR: The code tries to initialize the structure with 8 bytes\n  X -> .defw 100\n  -> .defm \"012345\""}},"/z80-assembly/z80-assembler":{"title":"The Klive Z80 Assembler","data":{"":"The original goal of the Klive Assembler was to have a simple tool that allows you to compile Z80 assembly code and inject it into the ZX Spectrum virtual machine. As the community has started using it, the developers have been receiving feature requests to add some helpful capabilities to the Assembler.","main-features#Main Features":"Here is a list of essential features the Klive Assembler supports:\nFull Z80 instruction set, including the initially undocumented Z80 registers and instructions\n(such as the 8-bit halves of ix and iy, namely ixl, ixh, iyl, iyh).\nZX Spectrum Next extended Z80 instruction set\nAlternate syntax versions. All directives, pragmas, and statements have multiple versions; you can use your preferred notation. For example, you can use .loop, loop, .LOOP or LOOP to declare a loop. All of the .defb, DEFB, .db, DB (and a few other) tokens can be used for defining byte data.\nZ80 Preprocessor. With preprocessor directives, you can execute conditional compilation and include other source files, inject symbols for debug time, and run time compilations separately. In Klive\nyou can use powerful macros, too. Nonetheless, they are not preprocessor constructs (see below).\nFast compilation. Of course, it depends on the code, but the compiler can emit code for about ten thousand source code lines per second (MacBook Pro).\nRich expressions. The compiler can handle most arithmetic and logic operators in C, C++, C#, Java, and JavaScript. You can use integer, float, and string expressions. The language supports more than 40 functions that you can use in the expressions (e.g., Amp * sin($cnt * Pi() / 16))\nRich literal formats. Decimal, float, hexadecimal, binary, and string literals are available.\nYou can use multiple variants for hexadecimal numbers ($12ae, #12AE, 0x12AE, 12AEh), and binary numbers\n(0b00111100, %00111100, %0011_1100). In strings, you can use ZX Spectrum-specific escape codes, for example, \\i for INK, \\P for the pound sign, and many others.\nAssembler control flow statements. You can use loops (loop, repeat..until, while..wend, for..next) and conditional statements (if) to create an assembler control flow. These constructs\ncan be nested and provide local scope for labels, symbols, and variables.\nPowerful dynamic macros. You can create macros with arguments. In the macro bodies, the current values of arguments can replace entire instructions, operands, or parts of expressions. Moreover, through arguments, you can inject multiline instructions and statements into macro declarations.\nModules. You can use modules to serve both as logical containers to separate partitions of the code and namespaces to create scopes for labels and symbols.","how-the-assembler-works#How The Assembler Works":"The assembler compiles the code in these phases:\nIt takes the source code and runs a preprocessor that parses the entire code and applies the directives in the code. You can easily recognize directives starting with #, such as #ifdef, #endif, #define, #include, and others. During the preprocessing phase, the assembler detects the syntax errors and loads and processes the included files. The result is a digested syntax tree that does not contain directives anymore, only instructions, pragmas, and statements.\nThe assembler collects macro definitions and stores their syntax tree to later use them when macros are invoked with their actual parameters.\nThe assembler goes through the digested syntax tree and emits code. During this operation, it must evaluate expressions to resolve symbols and identifiers to their actual values. Because the assembler progresses from the first line to the last, it may happen that it cannot get the value of an identifier, which is defined somewhere later in the code. When the assembler detects such a situation, it notes it and creates a fixup entry.\nThe assembler goes through all fixup entries and resolves symbols not defined in the previous phase. Of course, it might find unknown symbols. If this happens, the assembler reports an error.\nNote: Several pragmas and statements intend to evaluate an expression in phase 3. If they find an unresolved symbol during that phase, they do not create a fixup entry but immediately report an error."}},"/z80-assembly/z80-instructions":{"title":"Accepted Z80 Instructions","data":{"":"The Klive Assembler implements every officially documented Z80 instruction as well as the non-official ones. During the implementation, the ClrHome.org was used as a reference.Z80 instructions may start with a label. Labels are identifiers that can be terminated by an optional colon (:). The compiler accepts both labels in these samples:\nStart: ld b,#f0\nWait   djnz Wait","z80-mnemonics#Z80 Mnemonics":"The compiler accepts these mnemonics:ADC, ADD, AND, BIT, CALL, CCF, CP, CPD,\nCPDR, CPI, CPIR, CPL, DAA, DEC, DI, DJNZ,\nEI, EX, EXX, HALT, IM, IN, INC, IND,\nINDR, INI, INIR, JP, JR, LD, LDD, LDDR, LDDRX*, LDRX*, LDDX*,\nLDI, LDIR, LDIRX*, LIRX*, LDIX*, LDPIRX*, LPRX*, MIRROR*, MIRR*, MUL*, NEG,\nNEXTREG*, NREG*, NOP, OR, OTDR, OTIR, OUT, OUTINB*, OTIB*,\nOUTD, OUTI, PIXELAD*, PXAD*, PIXELDN*, PXDN*, POP, PUSH, RES, RET, RETI, RETN,\nRL, RLA, RLC, RLCA, RLD, RR, RRA, RRC,\nRRCA, RRD, RST, SBC, SCF, SET, SETAE*, STAE*, SLA, SLL\nSRA, SRL, SUB, SWAPNIB*, SWAP*, TEST*, XOR.\nNote: The instructions marked with * can be used only with the ZX Spectrum Next model.","z80-registers#Z80 Registers":"The compiler uses the standard 8-bit and 16-bit register names, as specified in the official\nZilog Z80 documentation:\n8-bit registers: A, B, C, D, E, H, L, I, R\n16-bit registers: AF, BC, DE, HL, SP, IX, IY\nFor the 8-bit halves of the IX and IY index registers, the compiler uses these names: XL, XH, YL, YH. Alternatively, the compiler accepts these names, too: IXL, IXH, IYL, IYH. As a kind of exception to general naming conventions, these mixed-case names are also accepted: IXl, IXh, IYl, IYh.","jp-syntax#JP Syntax":"Z80 assemblers use two different syntax constructs for the indirect JP statements:\n; Notation #1\njp hl\njp ix\njp iy\n; Notation #2\njp (hl)\njp (ix)\njp (iy)\nThe Klive Assembler accepts both notations.","alu-operations-syntax#ALU operations syntax":"Three standard ALU operations between A and other operands (ADD, ADC, and SBC) sign A\nas their first operand:\nadd a,b\nadc a,(hl)\nsbc a,e\nHowever, the five other standard ALU operations between A and other operands (SUB, AND, XOR,\nOR, and CP) omit A from their notation:\nsub e\nand (hl)\nxor e\nor c\ncp b\nThe Klive compiler accepts the second group of ALU operations using the explicit A operand, too:\nsub a,e\nand a,(hl)\nxor a,e\nor a,c\ncp a,b"}},"/z80-assembly/zx-next":{"title":"ZX Spectrum Next Development","data":{"":"The ZX Spectrum Next assembler in Klive IDE provides a comprehensive development environment for the ZX Spectrum Next platform. This page covers all Next-specific features, including automatic conveniences, the .savenex pragma, and NEX file generation.","quick-start#Quick Start":"The simplest ZX Spectrum Next program in Klive IDE looks like this:\n.model next\n.savenex file \"myapp.nex\"\n; Your code starts at $8000 automatically\nmain:\n    ld a, 4\n    out (0xFE), a    ; Set border color to green\ntrap: \n    jr $\nWhen you use .model next, Klive automatically:\nSets .savenex ram 768 (768K RAM)\nSets .savenex border 7 (white border)\nSets .savenex entryaddr $8000 (entry at $8000)\nMaps unbanked code to bank 2 at address $8000","automatic-conveniences-for-model-next#Automatic Conveniences for .model next":"","default-savenex-values#Default .savenex Values":"When .model next is specified, these defaults are automatically applied:\nParameter\tDefault Value\tDescription\tram\t768\t768K RAM configuration\tborder\t7\tWhite border color\tentryaddr\t$8000\tEntry point at $8000\t\nYou can override any default by explicitly specifying the .savenex pragma:\n.model next\n.savenex file \"myapp.nex\"\n.savenex border 5        ; Override default (use cyan instead of white)\n.savenex ram 1792        ; Override default (use 1792K instead of 768K)\n; Code...","unbanked-code-automatic-bank-2-mapping#Unbanked Code (Automatic Bank 2 Mapping)":"When you write code without an explicit .bank pragma, it's considered \"unbanked\" code and automatically:\nStarts at $8000 - The default assembly address is $8000\nMaps to Bank 2 - During NEX export, unbanked code is written to bank 2\nUses the range $8000-$bfff - The standard 16KB bank 2 address range\nExample - Simple unbanked program:\n.model next\n.savenex file \"simple.nex\"\n; This code is unbanked - automatically starts at $8000 and maps to bank 2\nmain:\n    ld a, 3\n    call setborder\ntrap:\n    jr $\nsetborder:\n    out (0xFE), a\n    ret","address-range-warning-z0904#Address Range Warning (Z0904)":"The assembler warns you if unbanked code exceeds the typical bank 2 range ($bfff):\n.model next\n.savenex file \"test.nex\"\n.org $c000              ; ⚠️ Warning Z0904: Address $c000 exceeds $bfff\n    ld a, 7\ntrap:\n    jr $\nThe warning message is:\nWarning Z0904: Unbanked code address $c000 exceeds typical bank 2 range ($8000-$bfff). \nConsider using .bank pragma for explicit memory layout.\nNote: This is a warning, not an error. Your code will still compile and the NEX file will be generated, but you should review whether you intended to extend beyond the standard bank 2 range.","multiple-unbanked-sections#Multiple Unbanked Sections":"You can have multiple unbanked code sections at different addresses using .org:\n.model next\n.savenex file \"multi.nex\"\n; First section at $8000\n    ld a, 1\n    call routine1\n; Second section at $9000\n.org $9000\nroutine1:\n    out (0xFE), a\n    ret\n; Third section at $a000\n.org $a000\nroutine2:\n    ld a, 2\n    ret\nAll unbanked sections are collected and written to bank 2 in the NEX file at their respective addresses.","multi-bank-applications#Multi-Bank Applications":"For complex applications requiring multiple memory banks, use explicit .bank pragmas alongside unbanked code:\n.model next\n.savenex file \"screen-tests.nex\"\n.savenex core \"3.1.0\"\n; Unbanked code in bank 2 at $8000\nmain:\n    ; \n    ; Save the current MMU 5 value ($A000-$BFFF)\n    ld a,$55\n    ld bc,$243b\n    out (c),a\n    inc b\n    in a,(c)\n    push af\n    ;\n    ; Page in the first 8K of 16K Bank $20 to $A000-$BFFF\n    di\n    nextreg $55,$40\n    ;\n    ; Invoke the subrouting in Bank $20\n    call SetBorder\n    ;\n    ; Restore the old MMU 5 value\n    pop af\n    nextreg $55,a\n    ei\ntrap \n    jr $\n; Explicit bank $20 code\n.bank $20\n.org $0000\n.disp $a000\nSetBorder\n    ld a,3\n    out ($fe),a\n    ret","how-multi-bank-code-works#How Multi-Bank Code Works":"Unbanked code exports to bank 2 at the addresses where it's assembled ($8000-$bfff typically)\n.bank sections export to their specified bank (e.g., bank 5) at the addresses defined by .org and .disp\nBoth can coexist in the same source file\nEach bank section is independent\nThe .savenex pragma provides a declarative way to configure ZX Spectrum Next NEX file generation parameters directly in your assembly source code. This pragma is only available when targeting the ZX Spectrum Next (Model 4).","overview#Overview":"The .savenex pragma uses a subcommand syntax where each subcommand configures a specific aspect of the NEX file. You can use multiple .savenex pragmas throughout your source code, and the compiler will collect and merge all declarations into a complete NEX file configuration.Syntax:\n.savenex <subcommand> <parameters>\nThe pragma is case-insensitive, so .savenex, .SAVENEX, and .SaveNex are all valid.","subcommands#Subcommands":"","file---set-output-filename#FILE - Set Output Filename":"Specifies the name of the NEX file to be generated.Syntax:\n.savenex file <filename>\nfilename: String literal or expression that evaluates to a string\nExample:\n.savenex file \"myprogram.nex\"","ram---set-ram-configuration#RAM - Set RAM Configuration":"Specifies the amount of RAM required by the program.Syntax:\n.savenex ram <size>\nsize: Must be either 768 (for 768K RAM) or 1792 (for 1792K RAM)\nDefault when .model next is used: 768\nExamples:\n.savenex ram 768    ; 768K RAM (default for .model next)\n.savenex ram 1792   ; 1792K RAM","border---set-border-color#BORDER - Set Border Color":"Specifies the border color to be set when the program loads.Syntax:\n.savenex border <color>\ncolor: Integer value from 0 to 7\nDefault when .model next is used: 7 (white)\nExample:\n.savenex border 5   ; Cyan border\nBorder Colors:\nValue\tColor\t0\tBlack\t1\tBlue\t2\tRed\t3\tMagenta\t4\tGreen\t5\tCyan\t6\tYellow\t7\tWhite","core---specify-required-core-version#CORE - Specify Required Core Version":"Specifies the minimum ZX Spectrum Next core version required to run the program.Syntax:\n.savenex core <major>, <minor>, <subminor>\n; or\n.savenex core <version-string>\nmajor: Integer value from 0 to 255\nminor: Integer value from 0 to 255\nsubminor: Integer value from 0 to 255\nversion-string: String literal in the format \"major.minor.subminor\"\nExamples:\n.savenex core 3, 1, 10       ; Requires core version 3.1.10 or higher\n.savenex core \"3.1.10\"       ; Alternative string format\nNote: Both formats are supported. The string format is convenient when the version comes from a constant or macro, while the comma-separated format allows for calculated values.","stackaddr---set-stack-pointer-address#STACKADDR - Set Stack Pointer Address":"Specifies the initial stack pointer address.Syntax:\n.savenex stackaddr <address>\naddress: Integer value from 0 to 0xFFFF\nExample:\n.savenex stackaddr 0xFF00","entryaddr---set-entry-point-address#ENTRYADDR - Set Entry Point Address":"Specifies the program's entry point address.Syntax:\n.savenex entryaddr <address>\naddress: Integer value from 0 to 0xFFFF\nDefault when .model next is used: $8000\nExample:\n.savenex entryaddr 0x8000    ; Entry at $8000 (default for .model next)","entrybank---set-entry-bank#ENTRYBANK - Set Entry Bank":"Specifies the bank number to be paged in when the program starts.Syntax:\n.savenex entrybank <bank>\nbank: Integer value from 0 to 111\nExample:\n.savenex entrybank 5","filehandle---set-file-handle-mode#FILEHANDLE - Set File Handle Mode":"Specifies whether to close or keep open the NEX file handle after loading.Syntax:\n.savenex filehandle <mode>\nmode: Either \"close\" (close file after loading) or \"open\" (keep file open, pass handle in BC register)\nDefault: \"close\" (file is closed after loading)\nExamples:\n.savenex filehandle \"close\"  ; Close file after loading (default)\n.savenex filehandle \"open\"   ; Keep file open, pass handle in BC register\nNEX File Specification:\n\"close\" writes 0x0000 to offset 140 (file is closed by loader)\n\"open\" writes 0x0001 to offset 140 (file kept open, handle passed in BC register)","preserve---preserve-next-registers#PRESERVE - Preserve Next Registers":"Specifies whether to preserve the Next hardware registers after loading.Syntax:\n.savenex preserve <value>\nvalue: \"on\"/\"off\" or 1/0\nExamples:\n.savenex preserve \"on\"\n.savenex preserve 1\n.savenex preserve \"off\"\n.savenex preserve 0","screen---configure-loading-screen#SCREEN - Configure Loading Screen":"Specifies a loading screen to display while the program loads.Syntax:\n.savenex screen <type> [, <filename> [, <palette-offset>]]\ntype: Screen type - one of: \"layer2\", \"ula\", \"lores\", \"hires-color\", \"hires-mono\"\nfilename: (Optional) Filename of the screen data\npalette-offset: (Optional) Offset in the palette file (0-255)\nExamples:\n.savenex screen \"layer2\"\n.savenex screen \"layer2\", \"loading.scr\"\n.savenex screen \"layer2\", \"loading.scr\", 0","palette---set-palette-file#PALETTE - Set Palette File":"Specifies a palette file to load.Syntax:\n.savenex palette <filename>\nfilename: String literal with the palette filename\nExample:\n.savenex palette \"colors.nxp\"","copper---set-copper-code-file#COPPER - Set Copper Code File":"Specifies a copper code file to load and execute.Syntax:\n.savenex copper <filename>\nfilename: String literal with the copper code filename\nExample:\n.savenex copper \"effects.cu\"","bar---configure-loading-bar#BAR - Configure Loading Bar":"Configures the loading bar display.Syntax:\n.savenex bar <enabled> [, <color> [, <delay> [, <start-delay>]]]\nenabled: \"on\"/\"off\" or 1/0\ncolor: (Optional) Bar color (0-255)\ndelay: (Optional) Delay per bar step (0-255)\nstart-delay: (Optional) Delay before starting (0-255)\nExamples:\n.savenex bar \"on\"\n.savenex bar \"on\", 2\n.savenex bar \"on\", 2, 50\n.savenex bar \"on\", 2, 50, 100","nex-file-format#NEX File Format":"The NEX file format (see details here) is the native executable format for the ZX Spectrum Next. It's a container format that includes:\nHeader Information: File version, RAM requirements, entry points, etc.\nScreen Data: Optional loading screen in various formats\nPalette Data: Optional palette information\nCopper Code: Optional copper coprocessor code\nLoading Bar: Optional visual feedback during loading\nProgram Banks: The actual program code and data organized in 16K banks","nex-file-version#NEX File Version":"The .savenex pragma targets NEX file format version 1.2, which is the current standard for ZX Spectrum Next executables.","bank-organization#Bank Organization":"The NEX file organizes code and data into 16K banks that correspond to the Next's memory management system:\nBanks 0-1: ROM (read-only, system)\nBank 2: Default user code bank (unbanked code maps here automatically)\nBanks 3-4: Standard RAM banks\nBanks 5-111: Extended RAM banks available for paging","how-unbanked-code-maps-to-bank-2#How Unbanked Code Maps to Bank 2":"When you use .model next and write code without explicit .bank pragmas:\nYour code is assembled at addresses starting from $8000\nDuring NEX export, this \"unbanked\" code is written to bank 2\nThe offset calculation is: bank2_offset = address - $8000\nCode at $8000 goes to offset 0 in bank 2\nCode at $9000 goes to offset $1000 in bank 2\nAnd so on...\nExample:\n.model next\n.savenex file \"test.nex\"\n; Code at $8000 → bank 2, offset $0000\nmain:\n    ld a, 1\n; Code at $9000 → bank 2, offset $1000\n.org $9000\nroutine:\n    ld a, 2","loading-process#Loading Process":"When a NEX file loads on the ZX Spectrum Next:\nThe NEX loader reads the header to determine requirements\nIf specified, the loading screen is displayed\nIf enabled, the loading bar provides visual feedback\nProgram banks are loaded into the specified memory locations\nHardware registers are configured according to the NEX header\nControl is transferred to the entry point address with the entry bank paged in","default-values#Default Values":"Default values for .savenex parameters depend on whether you're using .model next:","with-model-next-automatic-conveniences#With .model next (Automatic Conveniences)":"Parameter\tDefault Value\tDescription\tram\t768\t768K RAM\tborder\t7\tWhite border\tentryaddr\t$8000\tEntry point at $8000\tentryBank\t0\tBank 0\tfileHandle\t\"close\"\tClose NEX file after loading\tpreserveRegs\tfalse\tDon't preserve registers","without-model-next-traditional-mode#Without .model next (Traditional Mode)":"Parameter\tDefault Value\tDescription\tram\t(none)\tMust be specified\tborder\t0\tBlack border\tentryaddr\t(none)\tMust be specified\tentryBank\t0\tBank 0\tfileHandle\t\"close\"\tClose NEX file after loading\tpreserveRegs\tfalse\tDon't preserve registers","error-handling#Error Handling":"The assembler will generate errors if:\nYou use .savenex when not targeting the ZX Spectrum Next (Model 4)\nInvalid values are provided (e.g., border color > 7, bank > 111)\nRequired parameters are missing\nInvalid screen types or modes are specified\nVersion numbers exceed 255\nThe assembler will generate warnings if:\nZ0904: Unbanked code address exceeds $bfff (typical bank 2 range)","notes#Notes":"The .savenex pragma only configures the NEX file parameters; it doesn't generate the actual NEX file. The file generation happens during the export process.\nMultiple .savenex pragmas with the same subcommand will use the last value specified.\nExpression support allows you to use symbols, calculations, and other expressions for numeric parameters.\nString parameters can be string literals or expressions that evaluate to strings.\nUnbanked code is automatically tracked and exported to bank 2 during NEX file generation.\nYou can mix unbanked code and explicit .bank sections in the same source file.","see-also#See Also":"Pragmas - Complete pragma reference\nKlive Z80 Assembler Overview - General assembler documentation\nZX Spectrum Next Documentation - Official Next documentation"}},"/book/app-B-nextreg-reference":{"title":"Appendix B: NextReg Reference","data":{"":"The original Spectrum gave you half a dozen ports to poke at. The ZX Spectrum Next extends that with the NextRegs: a bank of hardware registers addressed from 0x00 to 0xFF. Not all 256 addresses are used—many are reserved, some are gaps, and a few are write-only sentinels that exist only to protect against hardware conflicts. The registers that are implemented form a dense, organized control surface for everything the Next adds beyond the original hardware.Think of NextRegs as the control panel for the FPGA. Want full-color graphics? There's a register for that. Want your sprites to appear over the border? A register for that too. Need to set the CPU running at 28 MHz, then interrupt once per scanline, while a co-processor handles palette animations in the background? Yes—all of that lives in NextRegs.This reference organizes registers by what you can do with them, not just what number they are. Flipping through a register list sorted by address is about as useful as reading a dictionary to find a recipe. Instead, each section here covers a specific capability and explains which registers you need to achieve it.","how-to-access-nextregs#How to Access NextRegs":"Two I/O ports form the gateway:\nPort 0x243B — write the register number here to select it\nPort 0x253B — read or write the register value here","writing-a-register#Writing a Register":"The port method works everywhere—including in 48K mode or on any hardware where the Z80N extended instructions aren't available:\nld bc,$243b    ; point to the register select port\nld a,$07       ; register number (CPU speed)\nout (c),a\ninc b          ; point to the value port\nld a,$02       ; value: 14 MHz\nout (c),a\nThe Z80N instruction set adds two faster alternatives that fold the select and write into a single instruction:\nnextreg $07,$02   ; select register 0x07 and write 0x02 in one shot\nnextreg $07,a     ; write whatever is in A to register 0x07\nnextreg is the idiomatic way to configure hardware in Next-specific code—cleaner, faster, and easier to read than the port sequence.","reading-a-register#Reading a Register":"There is no nextreg form for reads—the Z80N instruction set only covers writes. To read a register value back, you always use the ports:\nld bc,$243b    ; point to the register select port\nld a,$07       ; register number (CPU speed)\nout (c),a\ninc b          ; point to the value port\nin a,(c)       ; read the current value into A\nThe select port (0x243B) remembers the last written register number, so if you've just written to a register via the port method, you can skip the select step and read straight from 0x253B. Don't rely on this across interrupt boundaries though—an ISR that touches NextRegs will clobber the selection.\nReset behavior: Every register has a defined reset state. Hard reset (power-on, F1, or writing 0x02 with bit 1) restores everything to factory defaults. Soft reset (F4 key or writing 0x02 with bit 0) restores a slightly different subset—some hardware settings survive a soft reset, others don't. Register descriptions below note which applies.","whats-in-here#What's in Here":"Rather than listing registers by number, this reference groups them by what you can accomplish with them. Here's the map:\nSystem Identity and Control — Identify the hardware, reset the machine, choose CPU speed and machine type, boot alternate cores.\nMemory Management — Map any 8KB page of the 2MB address space into the Z80's 64KB window; control legacy 128K paging and alternate ROMs.\nVideo: The Layer System — Set the rendering order for Sprites, Layer 2, and ULA; configure global transparency and the fallback color.\nVideo: Layer 2 — Full-color 256×192 (or higher) bitmap display: assign RAM banks, choose resolution, scroll in hardware.\nVideo: ULA and LoRes — Hardware scroll the classic ULA display, enable ULA+, stencil mode, LoRes and Radastan modes.\nVideo: Sprites — Select and stream attributes for up to 128 independent hardware sprites.\nVideo: Tilemap — Hardware-managed grid of up to 512 tiles: configure layout, memory locations, and smooth scrolling.\nPalettes and Colors — Load 8- or 9-bit colors into any of the eight palettes (two per layer), enable ULANext, swap palettes instantly.\nClip Windows — Restrict any layer to a sub-rectangle of the display for split-screen and HUD effects.\nThe Copper Co-Processor — Load and run a raster-synchronized program that modifies NextRegs in sync with the video beam, frame after frame, without touching the CPU.\nAudio — Select AY/YM chip mode, enable TurboSound (three AY chips), write directly to the four 8-bit DACs, configure I²S audio from the Raspberry Pi.\nInterrupts — Enable hardware IM2 mode with automatic vector generation, set per-scanline line interrupts, manage ten interrupt sources, configure stackless NMI.\nPeripheral Settings — Joystick modes, scandoubler, contention, hotkeys, mouse DPI, speaker routing, and more.\nInput: Keyboard and Key Reading — Reprogram the PS/2 keymap, read extended and cursor keys not in the original 8×5 matrix.\nDivMMC and Storage — Control which ROM addresses trigger transparent SD card automapping for ESXDOS/NextZXOS.\nExpansion Bus — Enable the edge connector, filter which ports reach external hardware, propagate internal state to bus peripherals.\nRaspberry Pi and GPIO — Drive GPIO pins, enable UART/I²C/SPI on the Pi connector, configure I²S audio direction and ESP Wi-Fi GPIO.\nDebugging — I/O traps for +3 FDC ports; XADC temperature/voltage monitoring and Xilinx DNA serial ID (Issue 4 boards only).","system-identity-and-control#System Identity and Control":"These registers tell you what machine you're running on, and let you control the most fundamental operations: reset, machine type, and boot behavior.","what-machine-is-this-0x00-0x01-0x0e-0x0f#What Machine Is This? (0x00, 0x01, 0x0E, 0x0F)":"Before you start poking hardware registers, it's sometimes worth checking what hardware you're actually talking to. Emulators and physical boards present the same register interface, but their IDs differ.Register 0x00 — Machine ID (read-only)Identifies the platform:\nValue\tPlatform\t0x08\tEmulator\t0x0A\tZX Spectrum Next (physical hardware)\t0xFA\tZX Spectrum Next Anti-brick\t0x9A–0xEA\tNext core on third-party FPGA boards (UnAmiga, SiDi, MIST, MiSTer, ZX-DOS)\t\nIf your code needs to behave differently on emulators versus real hardware, read this register first. Note that emulators report 0x08 regardless of which emulator they are.Register 0x01 — Core Version (read-only)Bits 7:4 hold the major version number, bits 3:0 hold the minor version. Read 0x0E for the sub-minor version. Together these form a three-part version like 3.1.5 where 0x01 contains 0x31 and 0x0E contains 0x05.Register 0x0F — Board ID (read-only)Identifies the hardware revision:\n0x00 / 0x01 — Issue 2 or 3 board (Xilinx Spartan-6 FPGA)\n0x02 — Issue 4 board (Xilinx Artix-7 FPGA, more resources)\nSome features (like the XADC diagnostic interface at 0xF0–0xFA) are Issue 4 only.","resetting-the-machine-0x02#Resetting the Machine (0x02)":"Register 0x02 — ResetReading this tells you what kind of reset last occurred:\nBit 1 set: last reset was a hard reset\nBit 0 set: last reset was a soft reset\nBits 2–4: whether NMIs from DivMMC, Multiface, or an I/O trap triggered the reset\nWriting triggers resets and NMIs:\nBit 1: generate a hard reset (reboots completely, restores all hard-reset defaults)\nBit 0: generate a soft reset\nBit 2: generate a DivMMC NMI\nBit 3: generate a Multiface NMI\nBit 7: assert and hold reset on the expansion bus and ESP Wi-Fi module\nThe typical \"restart cleanly\" pattern is just writing 0x02 to this register. Hard reset—bit 1—takes priority if you set both bits.","machine-type-and-display-timing-0x03-0x24#Machine Type and Display Timing (0x03, 0x24)":"Register 0x03 — Machine TypeThe Next can pretend to be several different Spectrum models—not just for nostalgia, but because some software depends on specific port decoding and memory contention behavior.Writing to this register also disables the boot ROM, which is the normal step after initialization is complete.Bits 2:0 select the emulated machine (only writable during config mode):\n001 — ZX Spectrum 48K\n010 — ZX Spectrum 128K/+2\n011 — ZX Spectrum +2A/+2B/+3\n100 — Pentagon\nBits 6:4 set display timing (you need bit 7 set to change these):\n001 — ZX 48K timing\n010 — ZX 128K/+2 timing\n011 — ZX +2A/+2B/+3 timing\n100 — Pentagon timing (forces 50 Hz)\nWhy does display timing matter? Because contention—the ULA stealing CPU cycles during screen memory access—is different across models. Running 128K software on 48K timing causes subtle speed differences. Programs that rely on precisely timed loops to generate audio or video effects care deeply about this.Register 0x24 — Reserved (Port Conflict Protection)This register exists to prevent an obscure conflict with the Disciple Disk Interface, which uses I/O port 0x3B. Because writing to port 0x3B in the Disciple's protocol could accidentally select a NextReg, 0x24 acts as a decoy: in 48K and 128K legacy modes, the internally selected NextReg is automatically forced to 0x24 whenever an OUT (0x3B),A instruction executes. Writes to 0x24 are silently discarded, reads return nothing meaningful. The hardware protects itself from Disciple-style I/O automatically—you never need to write to 0x24 yourself.","core-selection-and-boot-0x10#Core Selection and Boot (0x10)":"Register 0x10 — Core BootThe Next FPGA holds multiple \"cores\"—complete hardware designs that take over the machine. The default core is the ZX Spectrum Next. Other cores might implement a Sinclair QL, a Commodore 64, or custom hardware.Reading tells you the currently selected core ID and whether the DRIVE (DivMMC) or M1 (Multiface) buttons are physically pressed.Writing selects and launches a core:\nBits 4:0 select the core ID (0–31, config mode only)\nBit 7 starts the selected core\nWriting an out-of-range core ID is safely ignored—it's the documented way to probe the maximum supported ID. Keep writing IDs until you get no response, and you've found the limit.","cpu-speed-0x07#CPU Speed (0x07)":"Register 0x07 — CPU SpeedThe Next can run its Z80 at four different speeds. Reading gives you both the programmed speed (bits 1:0) and the actual current speed (bits 5:4)—these differ when the expansion bus is active and forces a lower clock.Writing bits 1:0:\n00 — 3.5 MHz (stock Spectrum speed, maximum legacy compatibility)\n01 — 7 MHz (double speed, good balance for enhanced software)\n10 — 14 MHz (quad speed)\n11 — 28 MHz (8× original, maximum performance)\nSpeed resets to 3.5 MHz on soft reset.Why four speeds instead of just \"fast\"? A program that counts clock cycles to measure time will play at double speed if you run it at 7 MHz without telling it. Many games, demo effects, and especially tape-loading routines are timing-sensitive. Pick 28 MHz for your own code, drop to 3.5 MHz for legacy software, and change mid-program when you need precision timing for one section.At 28 MHz the hardware automatically inserts wait states for external SRAM accesses—the memory isn't fast enough to respond without them. The CPU never notices; it just sees slightly longer memory cycles.\nHotkey: The F8 key toggles CPU speed at runtime if bit 7 of NextReg 0x06 is set (it is, by default after soft reset).","memory-management#Memory Management":"The Z80 can address 64KB. The Next has up to 2MB of RAM. Something has to bridge that gap—and that something is the MMU.","boot-time-bank-mapping-0x04#Boot-Time Bank Mapping (0x04)":"Register 0x04 — Config Mapping (write-only, config mode only)This register exists solely to help the boot ROM get RAM into view before the full MMU is configured. In config mode—before the machine type has been selected and the boot ROM dismissed—the normal 128K paging ports aren't active yet. This register provides a simple escape hatch: bits 6:0 specify a 16K RAM bank to map into addresses 0x0000–0x3FFF, overriding whatever the reset default placed there.Once you write to 0x03 (Machine Type) to select a machine and disable the boot ROM, config mode ends and 0x04 has no further effect. From that point forward, use the MMU slot registers (0x50–0x51) to control that address range.\nEven multiples of 256K are unreliable if you're storing data there that another core will read after a boot—don't put anything critical at those offsets.\nYou'll encounter this register when writing a custom boot loader or examining how NextZXOS initializes the hardware. For normal application code, it's irrelevant—the operating system has long since moved past config mode by the time your program runs.","the-eight-slots-0x500x57#The Eight Slots (0x50–0x57)":"Registers 0x50–0x57 — MMU Slots 0–7The Z80's 64KB address space is divided into eight slots of 8KB each:\nRegister\tSlot\tZ80 Address Range\t0x50\t0\t0x0000–0x1FFF\t0x51\t1\t0x2000–0x3FFF\t0x52\t2\t0x4000–0x5FFF\t0x53\t3\t0x6000–0x7FFF\t0x54\t4\t0x8000–0x9FFF\t0x55\t5\t0xA000–0xBFFF\t0x56\t6\t0xC000–0xDFFF\t0x57\t7\t0xE000–0xFFFF\t\nEach register holds the 8KB page number that occupies that slot. Pages run from 0 to 223 on a fully expanded Next (2MB ÷ 8KB = 256 pages, but the top 32 are reserved). Writing 255 to slots 0 or 1 makes the ROM appear there instead of RAM.The default configuration after soft reset mirrors the 128K Spectrum layout:\nSlots 0–1: ROM (value 255)\nSlots 2–3: Page 10 (Bank 5, the ULA screen bank—addresses 0x4000–0x7FFF)\nSlots 4–5: Page 4–5 (Bank 2)\nSlots 6–7: Pages 0–1 (Bank 0)\nTo access a physical address anywhere in the 2MB space, calculate the page number: page = physical_address ÷ 8192. Then write that page number to whichever slot you want to map it through. For example, to access the very end of RAM at physical address 0x1F'E000:\n; Map page 0xFF (address 0x1FE000-0x1FFFFF) into slot 6\nNEXTREG 0x56, 0xFF\n; Now read/write 0xC000-0xDFFF to access that physical memory","legacy-128k-memory-mapping-0x8e-0x8f#Legacy 128K Memory Mapping (0x8E, 0x8F)":"Many existing programs use the traditional Spectrum 128K port 0x7FFD for memory paging. The Next respects this fully—but also lets you change those mappings directly through NextRegs without issuing port writes.Register 0x8E — Spectrum 128K Memory MappingThis is a unified view of all the legacy paging ports. Writing here has the same effect as writing to the original ports:\nBits 6:4 — RAM bank selection (equivalent to port 0x7FFD bits 2:0)\nBit 7 — Extended bank bit (port 0xDFfd bit 0), reaching banks 8–15\nBit 2 — Paging mode: 0 = normal, 1 = all-RAM (+3 special mode)\nIn normal mode: bits 1:0 select the ROM (equivalent to ports 0x1FFD/0x7FFD)\nReading gives you the current state of all these port values in one shot—useful for saving/restoring context without reading three separate I/O ports.Register 0x8F — Memory Mapping ModeSelects how ports 0x7FFD, 0xDFFD, 0x1FFD, and 0xEFF7 interpret their bits:\n00 — Standard ZX 128K/+3 behavior\n10 — Pentagon 512K memory model\n11 — Pentagon 1024K memory model\nUse this when running software written for Pentagon clones that expects their larger memory model.","alternate-rom-0x8c#Alternate ROM (0x8C)":"Register 0x8C — Alternate ROMThe Next lets you substitute your own ROM for the standard one. Writing bit 7 enables it; the alternate ROM is taken from DivMMC page space. You can also lock the 48K or 128K ROMs individually so they don't get swapped out.This is primarily used by the boot ROM and operating system—but it's also how you'd implement your own custom ROM replacement or a debugging monitor that intercepts RST vectors.","video-the-layer-system#Video: The Layer System":"The Next composites up to five overlapping visual elements—ULA, LoRes, Tilemap, Layer 2, and Sprites—into a single final image. Before diving into each layer, you need to understand how they stack and how to configure that stack.","layer-priority-and-global-enable-0x15#Layer Priority and Global Enable (0x15)":"Register 0x15 — Sprite and Layers SystemThis single register controls the big picture of what appears on screen and in what order.Enabling layers:\nBit 0 — Enable sprites globally (sprites are invisible until this is set)\nBit 1 — Allow sprites to appear over the border area\nBit 7 — Enable LoRes mode (replaces standard ULA output)\nLayer priority (bits 4:2):The three layers—S (Sprites), L (Layer 2), and U (ULA, which includes Tilemap when active)—can appear in any order:\nBits 4:2\tOrder (front to back)\t000\tS → L → U\t001\tL → S → U\t010\tS → U → L\t011\tL → U → S\t100\tU → S → L\t101\tU → L → S\t110\tBlending mode (U|T)S(T|U)(B+L)\t111\tBlending mode (U|T)S(T|U)(B+L-5)\t\nThe default is 000: sprites on top, then Layer 2, then ULA at the back.Modes 110 and 111 blend Layer 2 and ULA channel colors together, clamped to the [0,7] range—useful for color mixing effects.Sprite priority within sprites (bit 6):\n0 — Sprite 127 rendered on top (higher-numbered sprites win)\n1 — Sprite 0 rendered on top (lower-numbered sprites win)\nSprite clipping over border (bit 5): when sprites extend into the border area, this enables the clip window to apply there too.","global-transparency-0x14-0x4a-0x4b-0x4c#Global Transparency (0x14, 0x4A, 0x4B, 0x4C)":"Every layer needs a \"nothing here, show whatever is below me\" color. There are several transparency registers because the layers use different color formats.Register 0x14 — Global Transparency ColourAn 8-bit color value in RRRGGGBB format. Any pixel in Layer 2 or the ULA that exactly matches this color (comparing against the top 8 bits of the 9-bit palette output) becomes transparent, showing layers below. Default is 0xE3.This is a global setting—it applies to Layer 2, ULA, and LoRes simultaneously. If you need a different transparent color for sprites or the tilemap, use the registers below.Register 0x4A — Fallback ColourWhen all layers are transparent at a pixel position—every layer shows nothing—this color fills in. It's the absolute bottom of the compositing stack. Also used as the paper/border color in ULANext's full-ink mode.Register 0x4B — Sprite Transparency IndexSprites use palette indices, not direct colors. Any sprite pixel with this palette index (0–255, or 0–15 for 4-bit sprites) is transparent. Default 0xE3.Register 0x4C — Tilemap Transparency IndexThe tilemap's transparent palette index (just the bottom 4 bits matter since the tilemap always uses 4-bit indices). Default 0xF.","active-video-line-0x1e-0x1f#Active Video Line (0x1E, 0x1F)":"Registers 0x1E/0x1F — Active Video LineReading these gives you the current raster line being generated. 0x1E bit 0 is the MSB, 0x1F is the LSB. Together they form a 9-bit line number. This is the software equivalent of asking \"where is the electron gun right now?\" Useful for the rare cases where you need raster-synchronized code without setting up a line interrupt.","video-layer-2#Video: Layer 2":"Layer 2 is the Next's full-color bitmap display. Forget the ULA's 8-color-attribute system—Layer 2 gives every pixel its own color from a 256-entry palette. It's how you draw photographs, smooth gradients, and any image that would turn into a color-clash disaster on a standard Spectrum.","assigning-memory-0x12-0x13-0x69#Assigning Memory (0x12, 0x13, 0x69)":"Register 0x12 — Layer 2 Active RAM BankLayer 2 stores its pixels in regular 16KB RAM banks—the same memory the CPU uses. This register selects which 16KB bank is the starting bank for the active display buffer. Since the standard 256×192×8 mode needs 48KB, Layer 2 actually occupies three consecutive 16KB banks starting from this one. Default is bank 8.Register 0x13 — Layer 2 Shadow RAM BankThe second buffer—while Layer 2 is displaying from the active bank, you can draw into the shadow bank, then swap them. Perfect for flicker-free animation. Default is bank 11. Swap the active and shadow banks by toggling bit 3 of port 0x123B.Register 0x69 — Display Control 1 (bit 7)Bit 7 is the main Layer 2 enable switch (alias of the Layer 2 control port 0x123B bit 1). Clear Layer 2 and only the ULA is visible; set it and Layer 2 composites into the frame according to the layer priority in 0x15.","resolution-0x70#Resolution (0x70)":"Register 0x70 — Layer 2 Resolution and PaletteBits 5:4 select the display resolution:\n00 — 256×192, 8bpp (standard mode, 48KB frame buffer)\n01 — 320×256, 8bpp (requires 80KB; uses more banks)\n10 — 640×256, 4bpp (doubled horizontal, 80KB)\nThe standard 256×192 mode fits neatly into three consecutive 16KB banks. The high-resolution modes need five banks and offer more screen area—340×256 fills a 16:10 display beautifully.Bits 3:0 are the palette offset: this shifts which palette entries Layer 2 uses. The full Layer 2 palette has 256 entries, but you can bias the lookup by this offset, cycling through different color ranges for palette animation effects.","scrolling-0x16-0x17-0x71#Scrolling (0x16, 0x17, 0x71)":"Registers 0x16/0x71 — Layer 2 X Scroll (LSB and MSB)The X scroll value wraps Layer 2 horizontally. Combine 0x71 bit 0 (MSB) and 0x16 (LSB) for a 9-bit offset, covering the full 320-pixel width of the high-res modes. In standard 256×192, only 8 bits matter.Register 0x17 — Layer 2 Y ScrollVertical scroll, wrapping within the active resolution height (0–191 for standard mode). The hardware shifts the display origin without touching any pixel data—instant, zero-cost scrolling.Scrolling Layer 2 is free. The CPU doesn't copy pixels; the compositor just starts reading the buffer at a different offset. This is how parallax background layers work: update the scroll register each frame and the background slides independently of the sprites or ULA layer above it.","video-ula-and-lores#Video: ULA and LoRes":"The ULA is the heart of every Spectrum that ever lived. The Next reproduces it faithfully—complete with color attributes, contention, and all the behaviors decades of software depend on. But it also gives you direct control over the ULA that the original never offered.","scrolling-the-ula-0x26-0x27#Scrolling the ULA (0x26, 0x27)":"Register 0x26 — ULA X Scroll\nRegister 0x27 — ULA Y ScrollHardware scroll registers for the ULA layer. Like Layer 2, the pixel data doesn't move—just the compositor's reading window. X wraps at 256, Y at 192.Classic Spectrum games scrolled by copying memory. Now you just write a value to 0x26 or 0x27. No CPU cycles eating into game logic, no screen tearing from partial updates.","ula-control-0x68#ULA Control (0x68)":"Register 0x68 — ULA ControlA collection of ULA-level settings:\nBit 7: Disable ULA output entirely. Useful when you want only Layer 2 visible, or when blanking the screen during heavy loading.\nBit 3: Enable ULA+ mode—an alternate palette system where a separate 64-entry palette replaces the 8-color ULA defaults, giving the classic display 64 colors instead of 8.\nBit 2: ULA half-pixel scroll—enables sub-pixel horizontal scrolling by activating an intermediate scroll position between whole pixels.\nBit 0: Enable stencil mode when both ULA and Tilemap are active. Rather than one overwriting the other, stencil mode logically ANDs their colors together—creating masked cutout effects.\nBit 4: Cancel extended key entries in the 8×5 key matrix—prevents extended keys from showing up as regular key presses.\nBits 6:5: Blending mode selection for SLU modes 6 and 7 (from 0x15): choose ULA, ULA/Tilemap mix, or Tilemap as the source for blending.","lores-mode-0x6a-0x15-bit-7-0x32-0x33#LoRes Mode (0x6A, 0x15 bit 7, 0x32, 0x33)":"Register 0x6A — LoRes ControlLoRes is a lower-resolution ULA mode: 128×96 pixels with 2 colors per 4×8 pixel block instead of the normal 8×8. Same memory as the ULA (so you can't have both simultaneously), but tighter attribute coverage.\nBit 5: Enable Radastan mode — a 128×96 display using 4bpp (16 colors per pixel instead of per block), requiring 6144 bytes. Raw color without attribute clash.\nBit 4: Radastan Timex display file XOR — toggles which display file drives LoRes in Radastan mode.\nBits 3:0: Palette offset for LoRes rendering.\nRegisters 0x32/0x33 — LoRes X/Y ScrollHardware scroll registers for LoRes, independent of the ULA scroll. LoRes scrolls in \"half-pixels\" at the same sub-pixel smoothness as Layer 2.","display-control-0x69#Display Control (0x69)":"Register 0x69 — Display Control 1Bit 7 enables Layer 2 (alias of the Layer 2 port). Bit 6 enables the ULA shadow display (alias of port 0x7FFD bit 3—using the second screen bank). Bits 5:0 alias port 0xFF for Timex display mode selection. This register is a convenient single-address view of display configuration that's otherwise scattered across multiple ports.","video-timing-0x11#Video Timing (0x11)":"Register 0x11 — Video Timing (writable in config mode only)Selects the pixel clock frequency for VGA output or locks to HDMI:\n000 — 28 MHz (base VGA, HDMI compatible)\n001 — 28.571 MHz (HDMI compatible VGA variant)\n010–110 — Higher VGA frequencies (up to 33 MHz)\n111 — HDMI mode (fixed timing)\nIf your VGA monitor won't sync, try different timing settings. The 50/60 Hz selection comes from 0x05 bit 2.","vertical-line-count-offset-0x64#Vertical Line Count Offset (0x64)":"Register 0x64 — Vertical Line Count OffsetNormally, the ULA's first pixel row aligns with vertical line 0 for purposes of the Copper and line interrupts. This register adds an offset, shifting the relationship. Setting it to 32 means vertical line 32 corresponds to the first ULA row—while vertical lines 0–31 correspond to the tilemap and sprite area above the ULA display.This is how you create multi-resolution split screens: sprites and tilemaps count \"raster lines\" from 0, but the ULA starts partway through the frame. A non-zero offset lets the Copper fire at the right line to switch modes cleanly.","video-sprites#Video: Sprites":"Sprites are the 128 independent movable objects the Next provides. Unlike the ULA where you manually erase and redraw pixels, sprites exist outside normal memory—you write their attributes to hardware registers, and the compositor handles placement and compositing automatically.","selecting-the-active-sprite-0x34#Selecting the Active Sprite (0x34)":"Register 0x34 — Sprite NumberEverything sprite-related works on one sprite at a time. Write the sprite number (0–127) here to select which sprite subsequent attribute writes go to. Reading always returns 0 in the top bit; the bottom 7 bits reflect the last written sprite number.When lockstep mode is enabled (0x09 bit 4), writing to 0x34 simultaneously writes to port 0x303B—keeping the two interfaces in sync if legacy code uses the port directly.You can also address sprite patterns here when bit 7 is set in lockstep mode—the bottom 6 bits become a pattern index (0–63).","writing-sprite-attributes-0x350x39-0x750x79#Writing Sprite Attributes (0x35–0x39, 0x75–0x79)":"Registers 0x35–0x39 — Sprite Attributes 0–4Each sprite has five attribute bytes controlling its appearance and position. Registers 0x35–0x39 write attributes to whichever sprite is currently selected by 0x34. The sprite number does not auto-advance.Registers 0x75–0x79 do the same thing but auto-increment the sprite number after each complete set of attributes. This lets you stream attributes for 128 sprites with a loop:\nNEXTREG 0x34, 0          ; start at sprite 0\nLD BC, 0x253B            ; value port\n; for each sprite, write the five attribute bytes to 0x75-0x79\n; after writing attribute 4 (0x79), sprite number advances automatically\nFull attribute byte documentation covers position, palette, scaling, rotation, mirroring, visible flag, and pattern selection. See the sprites documentation for the complete bit layout.","clip-window-for-sprites-0x19#Clip Window for Sprites (0x19)":"Register 0x19 — Clip Window SpritesFour consecutive writes define the sprite clip rectangle: X1, X2, Y1, Y2 (all inclusive). Sprites are clipped to this window. In \"over border\" mode, the X coordinates are internally doubled and the origin shifts to align with the sprite coordinate system inside the border.Reads do not advance the clip index—only writes do.","video-tilemap#Video: Tilemap":"The Tilemap gives you a hardware-managed grid of tiles—up to 256 different 8×8 tiles, arranged on a 40×32 or 80×32 grid. The CPU writes tile numbers to a map in RAM; the hardware looks up tile patterns and renders them automatically. No CPU cycles spent copying pixel data around.","enabling-and-configuring-the-tilemap-0x6b#Enabling and Configuring the Tilemap (0x6B)":"Register 0x6B — Tilemap Control\nBit 7: Enable the tilemap. Nothing appears until this is set.\nBit 6: Select layout — 0 for 40×32 tiles, 1 for 80×32 tiles.\nBit 5: Eliminate attribute entries from the tilemap. In the default two-byte format, each tile reference consists of a tile number byte plus an attribute byte (palette offset, mirroring, rotation). Setting this bit removes the attribute byte—every tile uses the default attributes from 0x6C instead. This halves map memory usage.\nBit 3: Enable text mode — tiles are rendered as character cells using the ULA font, suitable for terminal-style displays.\nBit 4: Palette select — choose between the tilemap's two palettes.\nBit 1: Enable 512 tile mode — the attribute byte's bit 0 extends the tile number to 9 bits, giving access to 512 different tile patterns instead of 256.\nBit 0: Force tilemap on top of ULA. Normally the tilemap composites behind ULA. This overrides that, letting individual tiles use ULA-over-tilemap via the attribute bit, but making the rest of the tilemap appear above ULA.","default-tile-attributes-0x6c#Default Tile Attributes (0x6C)":"Register 0x6C — Default Tilemap AttributeWhen attribute-less mode is enabled (0x6B bit 5), every tile in the map uses this attribute value:\nBits 7:4 — Palette offset (shifts which palette entries the tile uses)\nBit 3 — Mirror the tile horizontally\nBit 2 — Mirror the tile vertically\nBit 1 — Rotate the tile 90°\nBit 0 — ULA over tilemap for this tile (or bit 8 of tile number in 512-tile mode)","tilemap-and-tile-memory-locations-0x6e-0x6f#Tilemap and Tile Memory Locations (0x6E, 0x6F)":"Register 0x6E — Tilemap Base AddressPoints to where the tilemap data lives in RAM. The value in bits 5:0 represents the high byte of an address within Bank 5 (0x4000–0x7FFF) or Bank 7 (0xC000–0xFFFF, 8KB only). Think of it as: the base address = (bit7 ? Bank7 : Bank5) + (bits5:0 << 8).Default is 0x6C00 (within Bank 5).Register 0x6F — Tile Definitions Base AddressSame format as 0x6E, but points to the pattern data—the actual pixel graphics for each tile. Each tile occupies 32 bytes (in 4bpp mode) or 16 bytes (in text mode). Default is 0x4C00.Separating map and pattern addresses means you can store tiles used by multiple maps in one location, and swap maps without duplicating pattern data.","tilemap-scrolling-0x2f-0x30-0x31#Tilemap Scrolling (0x2F, 0x30, 0x31)":"Register 0x2F/0x30 — Tilemap X Scroll (MSB and LSB)The X scroll is 10 bits total (0x2F bits 1:0 are MSB, 0x30 is LSB). Valid range is 0–319 in 40-character mode, 0–639 in 80-character mode. This shifts the visible window over the tile grid—hardware managed, zero CPU cost.Register 0x31 — Tilemap Y ScrollVertical scroll, 0–255. Both X and Y scrolling wrap seamlessly.Smooth-scrolling a tilemap background takes one register write per frame. No page flipping, no pixel copying, no wasted CPU time.","clip-window-for-tilemap-0x1b#Clip Window for Tilemap (0x1B)":"Register 0x1B — Clip Window TilemapFour consecutive writes: X1, X2, Y1, Y2. The X coordinates are internally doubled (because tilemap columns are 8 pixels wide, but the clip is in pixel coordinates). Default clips to 0, 159, 0, 255—the full tilemap display area.","video-palettes-and-colors#Video: Palettes and Colors":"The Next's color system is more flexible than it first appears. Every graphics layer has its own palette, palettes can be swapped on the fly, and the 9-bit color depth gives you 512 possible colors—chosen from to fill 256-entry palettes.","selecting-a-palette-entry-0x40#Selecting a Palette Entry (0x40)":"Register 0x40 — Palette IndexSelects which palette entry to read or write next. The matching between index numbers and graphical elements depends on which palette is selected:\nULA: Indices 0–7 are INK colors, 8–15 are Bright INK, 16–23 are PAPER, 24–31 are Bright PAPER.\nULANext mode: INK colors come from indices 0–127 (how many depends on the attribute mask in 0x42), PAPER colors from 128–255.\nLayer 2 / Sprites / Tilemap: Indices map directly to 8bpp or 4bpp pixel values.","writing-colors-0x41-0x44#Writing Colors (0x41, 0x44)":"Register 0x41 — Palette Value (8-bit)Write an 8-bit color in RRRGGGBB format. The hardware extends the 2-bit blue to 3 bits by OR-ing blue bits 1 and 0—so 0b11111111 becomes 9-bit 0b111111111. After writing, if auto-increment is enabled in 0x43, the palette index automatically advances to the next entry.Use 0x41 for fast palette loading when you don't need precise control of the 9th bit.Register 0x44 — Palette Value (9-bit)Two consecutive writes give you full 9-bit color control:\nFirst write: RRRGGGBB (same as 0x41)\nSecond write: bit 0 = the LSB of Blue\nFor Layer 2 palettes, the second write's bit 7 marks this entry as a priority color: Layer 2 pixels with this palette entry jump above all other layers—even sprites. This is how you create floating foreground elements using Layer 2 without needing sprites.After two consecutive writes (or a single write to 0x41), the index auto-increments if enabled. Writes to 0x40, 0x41, or 0x43 reset the two-write sequence back to the first byte.","choosing-which-palette-to-edit-0x43#Choosing Which Palette to Edit (0x43)":"Register 0x43 — Palette ControlBits 6:4 select which palette's entries you're editing:\nBits 6:4\tPalette\t000\tULA first palette\t001\tLayer 2 first palette\t010\tSprites first palette\t011\tTilemap first palette\t100\tULA second palette\t101\tLayer 2 second palette\t110\tSprites second palette\t111\tTilemap second palette\t\nEach layer has two palettes. You load both, then use bits 3:1 of this register to instantly switch which palette each layer uses. This is palette animation without touching palette data: preload a sunset in palette A and a moonlit version in palette B, then toggle bit 2 once per frame.\nBit 7: Disable auto-increment of palette index after writes. Useful when you want to write the same index multiple times without the index wandering off.\nBit 0: Enable ULANext mode — an extended ULA color system where the attribute byte drives more than just 8-color INK/PAPER.","ulanext-0x42#ULANext (0x42)":"Register 0x42 — ULANext Attribute Byte FormatIn ULANext mode, the attribute byte's bits are split between INK and PAPER differently than the original:\nThe mask value tells the hardware how many low bits of the attribute byte represent INK; the remaining bits represent PAPER.\nValid masks: 0x01, 0x03, 0x07 (default), 0x0F, 0x1F, 0x3F, 0x7F, 0xFF.\nMask 0xFF = full INK mode: all 256 palette entries are INK colors, and PAPER/border come from the fallback color in 0x4A.\nWith mask 0x07 (default), bits 2:0 are INK (8 colors of ink palette), bits 7:3 are PAPER. With mask 0x3F, bits 5:0 are INK (64 ink colors), bits 7:6 are PAPER. This lets you trade PAPER color range for INK color range.","video-clip-windows#Video: Clip Windows":"Every graphics layer can be clipped to a rectangle smaller than the full display. This is how you create split-screen layouts, HUD overlays, or windowed displays within a larger scene.","setting-clip-rectangles-0x18-0x19-0x1a-0x1b#Setting Clip Rectangles (0x18, 0x19, 0x1A, 0x1B)":"Each clip register takes four consecutive writes in order—X1, X2, Y1, Y2—all inclusive pixel coordinates:\nRegister\tLayer\t0x18\tLayer 2 (default: 0, 255, 0, 191)\t0x19\tSprites (default: 0, 255, 0, 191)\t0x1A\tULA and LoRes (default: 0, 255, 0, 191)\t0x1B\tTilemap (default: 0, 159, 0, 255)\t\nReads return the current coordinate but do not advance the write index. To re-set coordinates without having to cycle through all four writes, use the reset bits in 0x1C.","checking-and-resetting-clip-indices-0x1c#Checking and Resetting Clip Indices (0x1C)":"Register 0x1C — Clip Window ControlReading shows the current write index for each layer (0–3, where 0 means the next write goes to X1):\nBits 7:6 — Tilemap clip index\nBits 5:4 — ULA/LoRes clip index\nBits 3:2 — Sprite clip index\nBits 1:0 — Layer 2 clip index\nWriting resets individual clip indices:\nBit 3: reset Tilemap clip index to 0 (X1)\nBit 2: reset ULA/LoRes clip index to 0\nBit 1: reset Sprite clip index to 0\nBit 0: reset Layer 2 clip index to 0\nYou need this when code runs at unknown points in the write sequence—reset first, then write all four coordinates cleanly.","the-copper-co-processor#The Copper Co-Processor":"The Copper is a tiny co-processor that watches the raster beam and modifies NextRegs at precise screen positions. It runs independently of the Z80, executing from its own 2KB instruction memory. You load programs into it, start it, and walk away—the Copper fires palette changes, scroll updates, layer switches, and more, frame after frame, without touching the CPU.","loading-copper-programs#Loading Copper Programs":"Register 0x60 — Copper Data (8-bit Write)\nRegister 0x63 — Copper Data (16-bit Write)0x60 writes one byte at a time to the Copper's instruction memory, auto-incrementing the address after each write. Since Copper instructions are 2 bytes, most programs use 0x63 instead—it writes a full 16-bit instruction at once, auto-incrementing past both bytes.Each Copper instruction is one of two types:\nWAIT: pause execution until the raster reaches a specific X,Y position. Encoded as two bytes with the MSB bit set.\nMOVE: write a value to a NextReg. Encoded as two bytes: the register number and the value.\nRegister 0x61 — Copper Address LSB\nRegister 0x62 bits 2:0 — Copper Address MSBTogether these form the 11-bit write address into Copper memory (0–0x7FF). Set the address before loading a new program.","starting-and-stopping-the-copper-0x62#Starting and Stopping the Copper (0x62)":"Register 0x62 — Copper ControlBits 7:6 control execution:\n00 — Copper fully stopped\n01 — Start from address 0, loop continuously\n10 — Start from last stopped position, loop continuously\n11 — Start from address 0, restart when raster reaches (0,0) (frame-synchronized)\nWriting the same start value twice doesn't reset the Copper—you'd need to stop it first, then start again.Mode 11 is the most useful for frame effects: the Copper restarts at the top of each frame automatically, so your scanline palette animations run in perfect sync with the display, no synchronization code required.\nCopper access: The Copper can read and write NextRegs 0x00–0x7F. Registers 0x80 and above are inaccessible to it—so the Copper can't touch memory mapping, expansion bus control, or interrupt configuration. Everything visual is fair game.","aligning-copper-timing-0x64#Aligning Copper Timing (0x64)":"Register 0x64 — Vertical Line Count OffsetThe Copper counts raster lines from 0, and normally line 0 coincides with the first ULA pixel row. This register adds an offset, shifting the alignment. If your Copper WAIT instructions target tilemap/sprite pixel positions that don't match ULA rows, set this offset to align them.","audio#Audio":"The Next's audio system layers multiple sources simultaneously: beeper, three AY-3-8912 chips (TurboSound), four 8-bit DACs, and I²S digital audio from the Raspberry Pi connector. Most sources mix automatically—you just enable what you need.","peripheral-settings-for-audio-0x06-0x08-0x09#Peripheral Settings for Audio (0x06, 0x08, 0x09)":"Register 0x06 — Peripheral 2 Setting (audio-relevant bits)\nBits 1:0 — Audio chip mode:\n00 — YM2149 (Yamaha, slightly different envelope behavior from AY)\n01 — AY-3-8910 (the authentic Spectrum 128K chip)\n10 — ZXN-8950 (experimental extended mode)\n11 — Hold all AY chips in reset (silence them)\nBit 6: Route the beeper exclusively to the internal speaker, keeping it off the audio output jacks. Useful when you want the click of a real speaker but clean audio on HDMI.\nRegister 0x08 — Peripheral 3 Setting (audio-relevant bits)\nBit 4: Enable the internal speaker (enabled by default)\nBit 3: Enable the four 8-bit DACs (A, B, C, D). DACs A+D are mono (or left+right pair), B is left, C is right\nBit 1: Enable TurboSound—the second and third AY chips. Without this, only AY 0 is active\nBit 5: AY stereo mode — 0 = ABC (left-center-right), 1 = ACB (left-right-center). ACB puts all action on the outer channels, which sounds wider on headphones\nRegister 0x09 — Peripheral 4 Setting (audio-relevant bits)\nBits 7:5: Force AY 2, AY 1, or AY 0 (respectively) into mono mode. Mono combines both stereo channels of that AY chip into one, useful when a mono music track sounds wrong when panned hard left or right\nBit 2: Silence HDMI audio output (audio still plays on analog jacks)","dac-output-0x2c-0x2d-0x2e#DAC Output (0x2C, 0x2D, 0x2E)":"Register 0x2C — DAC B Mirror (Left)\nRegister 0x2D — DAC A+D Mirror (Mono)\nRegister 0x2E — DAC C Mirror (Right)These are the direct write paths to the four DACs—accessible via NextReg as mirrors of the port-based DAC interface:\nWrite to 0x2C: set left DAC B to an 8-bit sample (0x80 = silence, 0x00 = full negative, 0xFF = full positive)\nWrite to 0x2E: set right DAC C similarly\nWrite to 0x2D: set both DAC A and D simultaneously (the mono/center pair)\nReading these registers returns the current sample being received from the Raspberry Pi I²S interface—useful for monitoring or routing Pi audio back through the Next's mixer.\nDMA-driven audio: For real-time music playback, use the DMA controller to stream samples from a buffer to the DAC ports automatically. The DMA's burst mode is purpose-built for this: set source address, destination port (DAC), byte count, repeat, and the music plays without consuming any CPU cycles.","raspberry-pi-is-audio-0xa2#Raspberry Pi I²S Audio (0xA2)":"Register 0xA2 — PI I²S Audio ControlThe Raspberry Pi connector carries I²S digital audio in both directions:\nBits 7:6 — I²S enable: Off, mono-right, mono-left, or stereo\nBit 4: Direction — 0 for sending audio to Pi hats, 1 for receiving audio from a Pi\nBits 3:2: Mute left or right channels independently\nBit 0: Route incoming I²S audio directly to the EAR input on port 0xFE—enabling the Pi to feed audio data as if from a tape, for software tape-loading over I²S","interrupts#Interrupts":"The original Spectrum's interrupt story was simple: one source, one vector, every 20ms. The Next adds nine more interrupt sources, a priority system, hardware-generated vectors, and the ability to interrupt a DMA transfer mid-stream.","interrupt-mode-control-0xc0#Interrupt Mode Control (0xC0)":"Register 0xC0 — Interrupt ControlThe fundamental interrupt configuration:\nBit 0: 0 = classic pulse-mode interrupts (compatible with all software), 1 = hardware IM2 mode with automatic vector generation\nBits 7:5: When in hardware IM2 mode, these are the top 3 bits of the interrupt vector generated. Choose a page-aligned location for your interrupt table\nBit 3: Enable stackless NMI response (see NMI registers below)\nBits 2:1: Read-only—reflects the current Z80 interrupt mode (0, 1, or 2)\nHardware IM2 mode is the key feature. In standard IM2, Z80 asks the interrupting device for a byte and uses it as the low byte of the vector. In hardware IM2 mode, the Next generates the vector automatically based on interrupt priority—no need for an interrupt-vector-supplying device on the bus.The generated vector's low bits encode the source:\n0 — Line interrupt (highest priority)\n1/2 — UART 0/1 Rx\n3–10 — CTC channels 0–7\n11 — ULA (frame interrupt)\n12/13 — UART 0/1 Tx (lowest priority)","line-interrupt-0x22-0x23#Line Interrupt (0x22, 0x23)":"Register 0x22 — Line Interrupt Control\nRegister 0x23 — Line Interrupt Value LSBA line interrupt fires when the raster reaches a specific scanline. Together with the MSB from 0x22 bit 0, 0x23 specifies which line (0–311, though lines above ~311 may not exist in practice).\nBit 2 of 0x22: Disable the ULA frame interrupt (the normal 50/60Hz tick). Clear this if you're using line interrupts instead and don't want ULA interrupts competing.\nBit 1 of 0x22: Enable the line interrupt.\nBit 7 of 0x22 (read-only): 1 if the ULA is currently asserting an interrupt.\nThese bits in 0x22 are also aliased in 0xC4 along with all other interrupt enables—so both registers show the same state.Line interrupts let you split the screen into zones with different rendering modes—switch graphics modes, palettes, or layer configurations at exactly the right scanline. This is how split-screen text-at-bottom, game-at-top displays work cleanly.","enabling-interrupt-sources-0xc4-0xc5-0xc6#Enabling Interrupt Sources (0xC4, 0xC5, 0xC6)":"Register 0xC4 — Interrupt Enables 0\nRegister 0xC5 — Interrupt Enables 1\nRegister 0xC6 — Interrupt Enables 2Enable bits for all interrupt sources. A disabled interrupt enters polled mode—you can check 0xC8–0xCA to see if it fired without taking an actual interrupt. This is how you check whether a CTC channel has counted out without needing an ISR.0xC4:\nBit 7: Expansion bus /INT\nBit 1: Line interrupt\nBit 0: ULA frame interrupt (default enabled)\n0xC5, bits 7:0: CTC channels 7–0 respectively0xC6:\nBits 6, 2: UART 1 and 0 Tx empty\nBits 5:4: UART 1 Rx near-full / available\nBits 1:0: UART 0 Rx near-full / available","forcing-interrupts-0x20#Forcing Interrupts (0x20)":"Register 0x20 — Generate Maskable InterruptWriting set bits here immediately generates maskable interrupts for those sources, regardless of whether they've actually fired. Reading shows which interrupts are currently pending. This is invaluable for testing interrupt handlers: write 0x80 (line interrupt—it's bit 7) or 0x40 (ULA frame interrupt—bit 6) and your ISR fires immediately without waiting for an actual raster event.The bit layout matches 0xC8: bit 7 = line, bit 6 = ULA, bits 3:0 = CTC channels 3–0.","checking-interrupt-status-0xc8-0xc9-0xca#Checking Interrupt Status (0xC8, 0xC9, 0xCA)":"Registers 0xC8–0xCA — Interrupt Status 0–2Mirror the layout of 0xC4–0xC6. Reading shows which interrupts have fired (set bits = fired or currently pending). Writing set bits clears those status flags.In polled mode—where an interrupt is disabled—you read these to detect events without taking an interrupt. Check frequently in a game loop if you need CTC timing without ISR overhead.","nmi-handling-0xc2-0xc3-0xc0-bit-3#NMI Handling (0xC2, 0xC3, 0xC0 bit 3)":"Registers 0xC2/0xC3 — NMI Return Address LSB/MSBDuring an NMI acknowledge cycle, the return address is always written here—regardless of the stackless setting. Read these in your NMI handler to know where the Z80 was interrupted.Register 0xC0 bit 3 — Stackless NMIWith stackless NMI enabled, the NMI return address goes into 0xC2/0xC3 instead of the actual stack. The stack pointer decrements and increments normally, but the memory write/read is intercepted. The first RETN instruction after the NMI reads the return address from these registers instead of memory.Why? Because NMI handlers for debugging tools (like Multiface) need to inspect the stack without disturbing it. Normally, acknowledging an NMI pushes the PC to the stack—corrupting the very memory you're trying to examine. Stackless mode neatly sidesteps this.","dma-interrupt-enables-0xcc-0xcd-0xce#DMA Interrupt Enables (0xCC, 0xCD, 0xCE)":"Registers 0xCC–0xCE — DMA Interrupt EnablesThe DMA controller can be interrupted while running a transfer. These registers specify which interrupt sources can pause a DMA operation. The layout mirrors 0xC4–0xC6.This is how audio streaming with DMA stays synchronized: enable the line interrupt in 0xCC so the DMA pauses at a scanline boundary—preventing audio sample tearing if you update the buffer.","reserved-interrupt-area-registers-0xc7-0xcb-0xcf#Reserved Interrupt-Area Registers (0xC7, 0xCB, 0xCF)":"Three reserved registers live within the interrupt register block. They serve no user-visible function, but they have specific values the hardware expects:\n0xC7 — Reserved; write 0x00\n0xCB — Reserved; write 0xFF\n0xCF — Reserved; write 0x00\nIf you're bulk-initializing the interrupt system, write these sentinel values to avoid unexpected behavior from unverified hardware state. Future firmware revisions might assign these registers real functions—for now, treat them as write-once housekeeping.","peripheral-settings#Peripheral Settings":"Four registers pack a lot of configuration into single bytes. They cover joystick modes, speaker control, AY audio, PS/2 input, hotkeys, and more.","joystick-configuration-0x05#Joystick Configuration (0x05)":"Register 0x05 — Peripheral 1 Setting\nBits 7:6 and 3 (together): Joystick 1 mode (3-bit value)\nBits 5:4 and 1 (together): Joystick 2 mode (3-bit value)\nBit 2: 50/60Hz display mode (0 = 50Hz, 1 = 60Hz)\nBit 0: Enable scandoubler (1 = VGA 31kHz mode, 0 = direct 15kHz for CRT monitors)\nJoystick modes:\nCode\tMode\t000\tSinclair 2 (keys 1–5)\t001\tKempston 1 (port 0x1F)\t010\tCursor (keys 5,6,7,8,0)\t011\tSinclair 1 (keys 6–0)\t100\tKempston 2 (port 0x37)\t101\tMD joystick 1 (3 or 6-button, port 0x1F)\t110\tMD joystick 2 (port 0x37)\t111\tUser-defined keys joystick\t\nThe user-defined keys joystick is programmed through the PS/2 keymap interface (0x28–0x2B): write 128 to 0x28 to select key joystick mode, then specify which keyboard matrix positions map to each joystick button.","joystick-io-mode-0x0b#Joystick I/O Mode (0x0B)":"Register 0x0B — Joystick I/O ModeRepurposes the joystick ports as general I/O:\nBit 7: Enable I/O mode (disables joystick reading; keyboard joystick types produce no readings)\nBits 5:4: Mode — bit-bang GPIO, clock output, or UART on left/right joystick port\nBit 0: Parameter value (GPIO output level in bit-bang, clock run in clock mode, UART redirect in uart mode)\nUART mode is particularly useful: it redirects either the ESP Wi-Fi UART or the Raspberry Pi UART to the joystick port pins, allowing communication with external hardware using standard DB9 joystick cables.","other-peripheral-control-0x06-0x08-0x09-0x0a#Other Peripheral Control (0x06, 0x08, 0x09, 0x0A)":"Register 0x06 — Peripheral 2 Setting (non-audio bits)\nBit 7: Enable F8 CPU-speed and F5/F6 expansion-bus hotkeys\nBit 5: Enable F3 50/60Hz toggle hotkey\nBit 4: Enable DivMMC NMI from DRIVE button\nBit 3: Enable Multiface NMI from M1 button\nBit 2: PS/2 mode — 0 = keyboard primary, 1 = mouse primary (config mode only)\nRegister 0x08 — Peripheral 3 Setting (non-audio bits)\nBit 7: Unlock port 0x7FFD (when the 128K ROM locks it, this undoes that)\nBit 6: Disable RAM and port contention. Turn this on if you're running code at high speed and don't need ULA-accurate timing. Games built for 48K timing may glitch; demos often want it on for maximum speed\nBit 2: Enable port 0xFF Timex video mode reads (hides the floating bus)\nBit 0: Issue 2 keyboard compatibility (affects how the keyboard matrix is decoded)\nRegister 0x09 — Peripheral 4 Setting (non-audio bits)\nBit 4: Sprite ID lockstep — keep 0x34 and port 0x303B always in sync\nBit 3: Reset the DivMMC mapram bit (port 0xE3 bit 6). Write-only, reads 0\nBits 1:0: Scanline weight for CRT scanline simulation:\n00 — No scanlines\n01 — 50% scanlines\n10 — 25% scanlines\n11 — 12.5% scanlines\nRegister 0x0A — Peripheral 5 Setting\nBits 7:6: Multiface type (config mode only) — +3, 128 v87.2, 128 v87.12, or Multiface 1. Determines which ports the Multiface responds to.\nBit 4: Enable DivMMC automap\nBit 3: Reverse left and right mouse buttons\nBits 1:0: Mouse DPI — low (00), default (01), medium (10), high (11)","input-keyboard-and-key-reading#Input: Keyboard and Key Reading":"","ps2-keymap-0x28-0x29-0x2a-0x2b#PS/2 Keymap (0x28, 0x29, 0x2A, 0x2B)":"The Next remaps PS/2 keyboard keys to the Spectrum's 8×5 keyboard matrix. The default mapping makes a PS/2 keyboard feel natural on a Spectrum, but you can reprogram individual keys.Register 0x28 — PS/2 Keymap Address MSB (on write)Writing here starts a keymap programming session. Bit 7 = 0 selects the PS/2 keymap; bit 7 = 1 selects the joystick keymap. Bit 0 is the MSB of the keymap address.Register 0x29 — PS/2 Keymap Address LSBThe LSB of the keymap read/write address.Register 0x2A — PS/2 Keymap Data MSB (write-only)Bit 0 of this register carries the MSB of the keymap data byte. Currently this bit is not used by the hardware—the keymap entries are all 8-bit values fitting in 0x2B alone. Write 0 here before writing 0x2B. It exists in the register map as a placeholder for potential future expansion of the keymap data width.Register 0x2B — PS/2 Keymap Data LSBWriting here writes the new key mapping entry and auto-increments the address. Each entry maps a PS/2 scan code to a Spectrum matrix position (bits 5:3 = row, bits 2:0 = column; 111 = no key pressed). Read back through 0x28 (reading returns the stored palette value, not keymap data—keymap is write-only).","extended-key-states-0xb0-0xb1-0xb2#Extended Key States (0xB0, 0xB1, 0xB2)":"The ZX Spectrum Next keyboard has keys the original never had. These registers expose them directly.Register 0xB0 — Extended Keys 0 (read-only)\nBit\tKey\t7\t;\t6\t\"\t5\t,\t4\t.\t3\tUP\t2\tDOWN\t1\tLEFT\t0\tRIGHT\t\nRegister 0xB1 — Extended Keys 1 (read-only)\nBit\tKey\t7\tDELETE\t6\tEDIT\t5\tBREAK\t4\tINV VIDEO\t3\tTRUE VIDEO\t2\tGRAPH\t1\tCAPS LOCK\t0\tEXTEND\t\nSetting bit 4 of 0x68 prevents these extended keys from also inserting entries into the 8×5 membrane matrix—so reading port 0xFE won't see spurious keypresses from them.Register 0xB2 — Extended MD Pad Buttons (read-only)For Mega Drive pad mode, reads the extra buttons (X, Z, Y, MODE) on both left and right joystick ports separately. Bits 7:4 = right pad, bits 3:0 = left pad.","divmmc-and-storage#DivMMC and Storage":"DivMMC handles transparent SD card access. The fundamental mechanism is automapping: when the Z80 fetches an instruction from specific addresses (typically ROM entry points), DivMMC pages its own RAM and ROM into the Z80's address space, runs the SD card routine, then pages itself out—the calling code never knows DivMMC was involved.","divmmc-entry-points-0xb8-0xb9-0xba-0xbb#DivMMC Entry Points (0xB8, 0xB9, 0xBA, 0xBB)":"Register 0xB8 — DivMMC Entry Points 0Controls which addresses trigger automapping (instruction fetch only). Individual bits enable specific RST vectors:\nBit 0: Address 0x0000\nBit 1: Address 0x0008\n...\nBit 7: Address 0x0038 (IM1 interrupt vector)\nThe default enables 0x0000 and 0x0038.Register 0xB9 — DivMMC Entry Points Valid 0For each entry point in 0xB8, this sets whether it triggers always (bit set) or only when ROM3 is paged in (bit clear). ROM3 is the 48K BASIC ROM—so most tape-loading traps are ROM3-only.Register 0xBA — DivMMC Entry Points Timing 0For each entry point, whether mapping is instant (bit set—maps before the instruction executes) or delayed (bit clear—maps after the instruction, for compatibility). RST 0 and NMI entry at 0x0066 need instant mapping; tape traps at ROM addresses work better delayed.Register 0xBB — DivMMC Entry Points 1Additional entry points beyond the RST vectors:\nBit 7: Addresses 0x3DXX (TR-DOS entry points, instant, ROM3)—for TR-DOS disk compatibility\nBit 6: Disable exit from automap at 0x1FF8–0x1FFF\nBits 5:4: Tape trap addresses for NextZXOS (0x056A, 0x04D7)\nBits 3:2: Tape trap addresses for ESXdos / original DivMMC (0x0562, 0x04C6)\nBit 1: 0x0066 instant (NMI handler)\nBit 0: 0x0066 delayed","expansion-bus#Expansion Bus":"The Next's edge connector is electrically compatible with the original Spectrum's expansion bus. Original Spectrum peripherals can connect and work, but the Next also gives you fine-grained control over which ports get routed internally versus passed through to external hardware.","enabling-the-bus-0x80#Enabling the Bus (0x80)":"Register 0x80 — Expansion Bus Enable\nBit 7 (immediate): Enable the expansion bus\nBit 6 (immediate): Enable ROMCS replacement from DivMMC banks 14/15\nBit 5 (immediate): Disable internal I/O cycles and ignore IORQULA—all I/O goes to the bus\nBit 4 (immediate): Disable internal memory cycles—all memory access goes to the bus\nBits 3:0 are the \"saved\" versions that take effect after soft reset (copied from bits 7:4 at soft-reset time).","bus-control-0x81#Bus Control (0x81)":"Register 0x81 — Expansion Bus Control\nBit 7 (read-only): ROMCS is currently asserted on the expansion bus\nBit 6: Allow bus peripherals to override ULA on even-port reads (needed for Rotronics Wafadrive)\nBit 5: Disable NMI button debounce on the expansion bus (for Opus Discovery compatibility)\nBit 4: Propagate the maximum CPU clock at all times, even when the bus is off","port-decoding-control-0x820x85-0x860x89#Port Decoding Control (0x82–0x85, 0x86–0x89)":"Registers 0x82–0x85 — Internal Port Decoding Enables (32-bit field, 0x85 = MSB)\nRegisters 0x86–0x89 — Expansion Bus Port Decoding Enables (32-bit field, 0x89 = MSB)Each bit enables or disables one port or group of ports. A clear bit means the internal device for that port is disabled; when the expansion bus is on, the corresponding I/O cycle propagates to external hardware.Key bits (by position in the combined 32-bit value):\nBit 0: Port 0xFF\nBit 1: Port 0x7FFD (128K paging)\nBit 5: Port 0x6B ZXN DMA\nBit 6: Port 0x1F Kempston/MD1 joystick\nBit 9: Multiface ports\nBit 14: Sprite ports (0x57, 0x5B, 0x303B)\nBit 15: Layer 2 port (0x123B)\nBit 16: AY ports (0xFFFD, 0xBFFD)\nBits 17–23: DAC ports (various Soundrive, Covox, Specdrum configurations)\nBit 24: ULA+ ports\nBit 25: Z80 DMA port\nBit 27: CTC ports\nInternal enables always apply. Expansion bus enables are ANDed with internal enables—you can't enable something on the bus that's disabled internally.","io-port-propagation-0x8a#I/O Port Propagation (0x8A)":"Register 0x8A — Expansion Bus I/O PropagateEven when a port is handled internally, you can still propagate its I/O cycles to the expansion bus so external hardware can monitor state changes:\nBit 0: Port 0xFE (ULA keyboard/border/EAR—enables external keyboards to mix their readings)\nBit 1: Port 0x7FFD\nBit 2: Port 0xDFFD\nBit 3: Port 0x1FFD\nBit 4: Port 0xFF\nBit 5: Port 0xEFF7\nThe 0xFE propagation is special: any value an external keyboard puts on the data bus during a port 0xFE read gets mixed into the keyboard result—making external keyboards work naturally.","alternate-rom-0x8c-1#Alternate ROM (0x8C)":"Register 0x8C — Alternate ROMReplaces the standard Spectrum ROM with custom pages from DivMMC banks. The \"immediate\" bits (7:4) take effect now; bits 3:0 are saved and restored after soft reset.\nBit 7 (or 3): Enable alternate ROM\nBit 6 (or 2): Make alternate ROM visible only during writes (not reads)—useful for write trapping\nBits 5,4 (or 1,0): Lock ROM1 (48K ROM) or ROM0 (128K ROM) in place, preventing them from being paged out","raspberry-pi-and-gpio#Raspberry Pi and GPIO":"The Next's edge connector includes a Raspberry Pi Zero footprint, and the Next FPGA connects to Pi GPIO pins. These NextRegs configure that bridge.","pi-gpio-output-enable-0x900x93#Pi GPIO Output Enable (0x90–0x93)":"Registers 0x90–0x93 — PI GPIO Output Enable (28-bit field)Each bit enables output mode on the corresponding Pi GPIO pin (0–27). Pins 0 and 1 are fixed as inputs (I²C by default). All other pins can be switched between input and output individually. A set bit = output enabled.After soft reset, all pins are inputs.","pi-gpio-state-0x980x9b#Pi GPIO State (0x98–0x9B)":"Registers 0x98–0x9B — PI GPIO State (28-bit field)Reading returns the current state of all 28 GPIO pins regardless of direction. Writing sets output levels on pins that have output enabled (via 0x90–0x93); writes to input-configured pins are ignored.","pi-peripheral-enable-0xa0#Pi Peripheral Enable (0xA0)":"Register 0xA0 — PI Peripheral EnableEnables dedicated Pi interfaces that share GPIO pins with general GPIO:\nBit 5: UART on GPIO 14 and 15 (overrides GPIO for those pins)\nBit 4: UART direction — 0 = Rx/GPIO15 Tx/GPIO14 (for Pi hats), 1 = reversed (for Pi itself)\nBit 3: I²C on GPIO 2 and 3\nBit 0: SPI on GPIO 7, 8, 9, 10, 11\nWhen any of these are enabled, the corresponding pins are no longer general-purpose GPIO.","esp-wi-fi-gpio-0xa8-0xa9#ESP Wi-Fi GPIO (0xA8, 0xA9)":"Registers 0xA8/0xA9 — ESP Wifi GPIOThe ESP8266 Wi-Fi module on the Pi connector exposes two GPIO pins: GPIO0 and GPIO2. Register 0xA8 enables output, 0xA9 reads/writes state. GPIO2 is read-only (its output enable bit is fixed at 0).These are used to hold the ESP in programming mode (GPIO0 low during reset) or to toggle module state. Normally the operating system handles this, but if you're implementing custom Wi-Fi control, these give you direct access.","debugging-features#Debugging Features":"","io-traps-0xd8-0xd9-0xda--experimental#I/O Traps (0xD8, 0xD9, 0xDA) — Experimental":"Register 0xD8 — I/O TrapsWith bit 0 set, I/O writes to ports 0x2FFD and 0x3FFD (the +3 FDC disk controller ports) generate a Multiface NMI instead of actually executing—trapping them for inspection or redirection. Useful for +3 disk DOS compatibility layers.The NMI status appears in 0x02 bit 4. In your NMI handler, check 0xDA to find the cause, and 0xD9 for the byte that was written.Traps cannot fire while DMA, DivMMC, Multiface, or an external NMI master is already active.","xadc-diagnostics-0xf0-0xf8-0xf9-0xfa--issue-4-only#XADC Diagnostics (0xF0, 0xF8, 0xF9, 0xFA) — Issue 4 Only":"The Artix-7 FPGA in Issue 4 boards includes XADC (Extended Analog-to-Digital Converter) and DNA (Device Unique ID) interfaces. These are exposed through a small state machine accessed via 0xF0.Register 0xF0 — XDEV CMDWrite 0x80 to enter select mode. Then write 0xC0 | device_id to select a device (DNA = 1, XADC = 2). Finally write 0 to exit select mode and start communicating with the selected device via the same register.Xilinx DNA mode: Read serial bit-by-bit; the first 8 bits give the DNA field length, followed by the unique device ID. This gives you a hardware serial number unique to each FPGA device.XADC mode: Trigger conversions and read analog measurements via 0xF8–0xFA. The XADC can measure internal chip temperature and supply voltages—useful for thermal diagnostics or detecting a stressed board. Consult Xilinx UG480 for the full DRP register map.","user-storage-0x7f#User Storage (0x7F)":"Register 0x7F — User Register 0Eight bits of scratch storage that the hardware ignores. Write anything, read it back later. Soft reset returns it to 0xFF.Not exactly a feature with a lot of drama, but it's occasionally useful: store a mode byte here that multiple interrupt handlers can read without needing to reserve precious RAM, or use it as a quick handshake flag between interrupt and main code.\nUpper limit: NextRegs 0x80 and above are inaccessible to the Copper but still reachable via I/O ports and NEXTREG instructions. Register 0xFF is reserved for internal use—don't write to it.","quick-reference-registers-by-category#Quick Reference: Registers by Category":"Category\tRegisters\tSystem identity\t0x00, 0x01, 0x0E, 0x0F\tSystem control\t0x02, 0x03, 0x07, 0x10, 0x24\tMemory (MMU)\t0x04, 0x50–0x57, 0x8C, 0x8E, 0x8F\tLayer system\t0x14, 0x15, 0x4A, 0x4B, 0x4C\tLayer 2\t0x12, 0x13, 0x16, 0x17, 0x18, 0x69, 0x70, 0x71\tULA / LoRes\t0x11, 0x1A, 0x26, 0x27, 0x32, 0x33, 0x64, 0x68, 0x69, 0x6A\tSprites\t0x19, 0x34, 0x35–0x39, 0x75–0x79\tTilemap\t0x1B, 0x2F, 0x30, 0x31, 0x6B, 0x6C, 0x6E, 0x6F\tPalettes\t0x40, 0x41, 0x42, 0x43, 0x44\tClip windows\t0x18–0x1C\tRaster / timing\t0x1E, 0x1F, 0x20, 0x22, 0x23\tCopper\t0x60, 0x61, 0x62, 0x63, 0x64\tAudio\t0x06, 0x08, 0x09, 0x2C, 0x2D, 0x2E, 0xA2\tInterrupts\t0xC0, 0xC2, 0xC3, 0xC4–0xC6, 0xC7, 0xC8–0xCA, 0xCB, 0xCC–0xCE, 0xCF\tJoystick\t0x05, 0x0B, 0xB2\tKeyboard\t0x28, 0x29, 0x2A, 0x2B, 0xB0, 0xB1\tPeripherals\t0x06, 0x08, 0x09, 0x0A\tDivMMC\t0xB8, 0xB9, 0xBA, 0xBB\tExpansion bus\t0x80, 0x81, 0x82–0x89, 0x8A\tRaspberry Pi / GPIO\t0x90–0x93, 0x98–0x9B, 0xA0, 0xA2, 0xA8, 0xA9\tDebugging\t0xD8, 0xD9, 0xDA, 0xF0, 0xF8–0xFA\tUser storage\t0x7F"}},"/":{"title":"Introduction to Klive IDE","data":{"":"Klive IDE is a retro computer emulator and Integrated Development Environment running on Mac and Windows.Klive offers not only the emulators but also debugging views, a multi-pane code editor, interactive commands, and other tools to create your Z80 Assembly and ZX BASIC (Boriel's Basic) programs.Klive IDE supports dual monitor mode to place the Emulator and IDE on different monitors while working with code.","supported-emulators#Supported Emulators":"Klive IDE intends to support retro computers with the Z80 family of CPUs. Klive supports these emulators:\nZX Spectrum 48K\nZX Spectrum 128K\nZX Spectrum +2E/+3E\nCambridge Z88\nZX Spectrum Next (in progress)\nZX 80/81 (in the future)","emulator-features#Emulator Features":"The emulator can run the selected machine with or without debugging. These modes can be changed without restarting the running machine:\nStarting, pausing, continuing to run\nStart or continue in debug mode\nSetting up breakpoints, step-in, step-over, step-out modes\nTo examine the state of the emulator, Klive offers several views:\nFull CPU view\nFull ULA view\nMemory view with live refresh\nDisassembly view with execution point tracking\nMonitoring system variable values\nDisplaying (and exporting) the current BASIC listing\nYou can quickly load and play programs (games) from files:\nLoading tape files (.tap and .tzx)\nFast load\nLoading from disk files (.dsk) with ZX Spectrum +3E\nWriting and formatting disk (.dsk) files (in progress)\nOther emulator features:\nVisual keyboard (ZX Spectrum 48K and ZX Spectrum 128K styles)\nMultiplying CPU clock speed (1-24 multiplier)\nSetting up the sound level, muting and unmuting sound\nPlanned features (in the future):\nUsing custom machine ROMs\nMemory read/write breakpoints\nI/O read/write breakpoints\nBreakpoints with hit count conditions","ide-features#IDE Features":"The IDE allows you to open project folders that keep the files belonging to a particular (development) project together. You can use Z80 Assembly language (with the built-in Klive Z80 Assembler) and ZX BASIC (Boriel's Basic) as your programming language.\nSyntax highlighting\nSource code debugging (works with the Klive Z80 Assembler)\nExporting the compiled code to tape files (.tap and .tzx) with BASIC loaders\nKlive's unique feature is the one-click start and debugging: With a click of one button, your code is compiled and injected into the selected emulator and immediately starts up. You can start your code with debugging (or pause it and continue with debugging).Commands: The IDE has an interactive command panel to issue CLI commands executed within the IDE.Planned features (in the future):\nWatch Panel: display runtime information about memory variables (expressions)\nConditional breakpoints\nIntegration with other assemblers, including compilation and optional source code debugging (if the particular compiler supports debug symbol information)."}}}