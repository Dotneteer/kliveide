{"/getting-started/creating-project":{"title":"Creating a Klive Project","data":{"":"The IDE supports developing applications with a Klive project. With the File | Open folder command, you can open the contents of a particular folder and display it. The IDE considers folders with a well-formed klive.project file within them a Klive project.","the-new-project-dialog#The New Project Dialog":"With the File | New project menu command, you can create a new Klive project:\nYou can select the machine type to use in the project (you can change it any time when the project is open)\nYou can specify a root folder for your project directory. The new project will be a subfolder of the root. If you leave it empty, the new project goes into your user home's KliveProjects folder.\nThe project requires a name (MyFirstKliveProject in the figure above).\nWhen you click Create, the IDE creates the new project folder and opens it.","the-project-structure#The Project Structure":"A Klive project is a folder with a klive.project file in it. The file is a JSON file that describes the project's properties. The IDE creates the following structure for a new project:\nThe little home icon to the left of the root folder name (MyFirstKliveProject) indicates that the open folder is a Klive project. The last file, klive.project, contains information about the current project. As you work with the project, this file may store more settings (e.g., breakpoints, some integration settings, etc.)When you open a folder that is not a Klive project, you cannot see the home icon:","the-build-root#The Build Root":"When you develop your code, you may work with multiple files — Klive needs to know the main file to compile it to machine code. The build root designates this main file. When you create a new project, Klive automatically assigns a file as the build root. In the Explorer, the \"combine\" icon to the right of the file name indicates this:\nYou can change the build root any time by right-clicking on a file and selecting the Promote to Build Root command.\nNote: The Promote to Build Root command is available only for particular file types Klive supports.","build-root-commands#Build Root commands":"When you select the build root in the Explorer, the content of the file opens in the code editor, and it displays four icons at the right side of the document tab bar:\nEach of these icons carries out a particular operation:\nIcon\tOperation\t\tThis command compiles the project using the build root file as the main file. This operation lets you check whether your code is free from compilation errors.\t\tThis command compiles the project. If the compilation is successful, it immediately injects the binary code into the memory of the paused machine. After the operation, you can resume the machine and execute the code (for example, with the RANDOMIZE USR(<address>) command).\t\tWith this command, you can start the compiled code.\t\tWith this command, you can start the compiled code in debug mode.\t\nWhen you start the code, Klive executes several steps to ensure a one-click user experience to run or debug the code:\nThe IDE compiles the code. If the compilation fails, no program is started.\nThe IDE restarts the current machine on successful compilation and runs while its OS reaches the main execution cycle. At this point, the IDE may emulate keystrokes to lead the OS to a point where code execution is safe.\nKlive pauses the machine and injects the code into the memory.\nKlive sets the Program Counter (PC) register to the entry point of the injected code and resumes the machine.\nThe injected code runs.","the-project-file#The Project File":"The klive.project file encapsulates information about the current project, including the machine type, UI settings, breakpoint, project state, and many others. While you work with the project, the IDE may update this file.The project file uses JSON format. When you click it in the Explorer, you can look at its content within the code editor. However, the IDE considers this file read-only; thus, it does not allow you to edit it directly. The little shield icon to the right of the filename indicates this read-only state.\nNote: Though you cannot edit this file with the IDE, you can modify it outside. Such modifications may lead to the loss of the project file if the IDE cannot parse klive.project while opening the project folder. If you ever decide to modify klive.project manually, make sure that particular project is not open in the IDE."}},"/getting-started/first-run":{"title":"Running Klive","data":{"":"The first time you start Klive, it displays the Emulator window. You can recognize it from the dark grey box representing a turned-off machine.Klive stores your last selected machine type and a few other settings when you close the app and reloads them automatically the next time you start Klive again.Klive has two separate windows; however, the first time you start it, the app shows only the Emulator window. Select the View | Show IDE menu command and Klive displays the IDE window:When you close the Emulator window, it automatically closes the IDE window, too. However, closing the IDE window keeps the Emulator window open. You can quit the Klive application by closing the Emulator window or selecting File | Exit on Windows or Klive | Quit klive-emu on Mac.\nNote: Klive saves the window positions when exiting the app. If you use multiple monitors, the windows will be restored according to their last display the next time you start Klive.","controlling-the-emulator#Controlling the Emulator":"You can start the emulated machine (ZX Spectrum 48K, by default) in several ways:\nPressing the F5 key.\nUsing the Machine | Start menu command\nClicking the Play toolbar button (the leftmost green button of the Emulator's toolbar)\nNote: You can also start the machine with the em-start (or :s) interactive command within the IDE.\nYou can control the running machine with other commands:\nPause: You can suspend running the machine with the Shift+F5 key, the Pause icon in the toolbar, or the Machine | Pause menu. Later, you can restore running the machine.\nStop: When turning the emulated machine off, use the F4 key, the Stop icon in the toolbar, or the Machine | Stop menu command. Though you can view the state of the stopped machine, you cannot continue running it.\nRestart: You can stop and immediately start the machine again with the Shift+F4 key. The same action is available with the Restart toolbar icon and the Machine | Restart menu.","debug-mode#Debug Mode":"The emulator supports running in debug mode. In this mode, the running machine will stop at designated breakpoints, allowing you to examine the current state.You can turn the machine on in debug mode with the Ctrl+F5 key, using the Machine | Start with Debugging menu, or selecting the \"Start with Debugging\" option from the toolbar's drop-down and pressing the play button.When you suspend (pause) the machine, you can continue running it in debug mode with Ctrl+F5. Also, while the machine is paused, you can move it into debug mode with any of these debugger commands:\nStep Into. This command executes the next Z80 instruction and pauses the machine again. Use the F10 key, the **Machine | Step Into command, or the Step Into toolbar key.\nStep Over. This command executes the next Z80 instruction and pauses the machine again. Suppose the instruction is a subroutine call, an RST call, or a block operation (e.g., LDIR). In that case, the entire instruction is executed, and the machine pauses again at the next instruction following the call or the block operation. Use the F11 key, the **Machine | Step Over command, or the Step Over toolbar key.\nStep Out. This command executes all Z80 instructions to the next return instruction and suspends running again at the return point. Use the Shift+F11 key, the **Machine | Step Over command, or the Step Over toolbar key.\nNote: The Step Out command may not work in every context. There are Z80 programs that do not use the RET statement (or its conditional equivalents) but manipulate the stack and use indirect jump statements. The Step Out command cannot work with such constructs.","changing-the-view#Changing the View":"In the View menu, you find several commands that allow changing  the view of the current window (Emulator or IDE):\nActual Size: Sets the view size to Normal (100%) according to the operating system on which you run Klive.\nZoom In: Enlarges the screen (including all text and graphics).\nZoom Out: Makes text and graphics smaller.\nToggle Full Screen: Turns on and off full-screen mode.\nNote: While the Toggle Full Screen command handles the Emulator and IDE windows independently, other commands affect both."}},"/getting-started/installation":{"title":"Installing Klive","data":{"":"Visit the project release page to get the install kits for Klive. You find the latest release at the top of the page. When you expand the Assets tab, it will list five files, including the three installation kits:\nKliveIdeSetup-{version}.AppImage: The Linux AppImage format to install Klive IDE on Linux without requiring an admin privilege to run\nKliveIdeSetup-{version}.exe: Self-extracting executable to install Klive IDE on Windows x64\nKliveIdeSetup-{version}.pkg: The standard PKG format to install Klive IDE on MacOS\n{version} is a placeholder for the version number of a particular release in the filename.Download the file according to the operating system to use, and follow the sections of this article.\nNote: Though there is an install kit for Linux, I have yet to test it thoroughly. If you plan to work with Klive IDE on Linux, please help me test it or even create additional install kits.","macos-installation#MacOS Installation":"Open the downloaded .pkg file. As the file comes from an untrusted source, the OS cannot install it directly. Click the OK button to close the message.\nNow, open the System Settings panel and navigate the Privacy & Security tab. As you scroll down, you can see the message with the blocked filename and the Open Anyway button. Click the button to sign that you intend to run the install kit.\nOpen the .pkg file again and select the Open button in the security dialog on the screen.\nNote: The OS may ask for your password to confirm the installation.\nClick Open to allow the installer to run. Follow the screenshots (use Continue) to complete the installation.\nNote: The installer will create a Klive IDE folder in the Applications folder and copy the required files into it. It will also create a shortcut in the Launchpad. When you complete the installation, MacOS may ask you for access to your Downloads folder to recycle the install set optionally.\nAfter the successful installation, you can find Klive IDE in your Applications folder.","windows-installation#Windows Installation":"The setup file is a self-extracting executable. Open it, and it will automatically extract itself and copy the executable files into the Programs (within your user home'sAppData/Local/Programs/klive-ide) directory.The setup kit will start Klive IDE after completion. Later, you can start Klive IDE again:Use the search in the Windows taskbar and type \"Klive\". The newly installed app shows up in the search results:\nClick on Klive IDE to start it.\nNote: When Klive IDE is selected in the search result list, the right pane shows the Pin to taskbar command. Use this to add the IDE to the taskbar; later, you can run it with a single click on the Klive IDE icon.","linux-installation#Linux Installation":"I have not tried to install Klive IDE on Linux. If you did and have a helpful description of the installation steps, please create a PR to extend the installation notes in this article."}},"/getting-started/keyboard":{"title":"Using the Keyboard","data":{"":"You can use the computer's physical keyboard or a virtual keyboard to emulate keystrokes. To let the Emulator process the computer's keyboard, the Emulator should have the focus. When you change the current window to the Emulator with your machine's keys or click it with the mouse, it is ready to receive keystrokes.Of course, you should start the machine and wait while it reaches its main execution cycles and starts watching for keys.","using-the-virtual-keyboard#Using the Virtual Keyboard":"If you do not find it easy to use the computer's physical keyboard, you can use the virtual keyboard. You can display (or hide) it with one of these actions:\nClick the View | Show the Virtual Keyboard menu command while in the Emulator window\nClick the Keyboard icon in the Emulator's toolbar\nWhen the keyboard is to show, Klive displays it according to the selected machine's type. These figures show the ZX Spectrum 48K keyboard and the ZX Spectrum 128L/+2E/+3E keyboard.To press a key, move the mouse over the particular virtual key and click it. If you keep the mouse button down, it's just like keeping the button pressed. Releasing the mouse button behaves as you released the real key.When you move the button slowly over a particular key, it will highlight the part of the button with the symbol shift-related and extended mode-related keys. When you click the mouse, it will automatically \"press\" the symbol shift or extended mode keys.You can use both the left and right mouse buttons. However, when using the right mouse button with normal buttons, the key behaves as if you pressed the CAPS SHIFT button simultaneously.This table shows a few examples:\nExample\tDescription\t\tThe click will display INPUT (i) when you use the left mouse button or INPUT (I) with the right mouse button, depending on the current ZX Spectrum cursor mode.\t\tThe click will result in AT regardless of which mouse button you click.\t\tThe click will show CODE regardless of which mouse button you click..\t\tThe click will display IN regardless of which mouse button you click.\t\tThe click will display a glyph with its top-left corner set if you click the left mouse button and the inverse of that glyph when you use the right mouse button.","resizing-the-virtual-keyboard#Resizing the Virtual Keyboard":"When you move the mouse to the top border of the virtual keyboard, a sizing splitter bar appears:\nHold down the mouse key while over the splitter, and move it. As you move, Klive changes the keyboard size and resizes the emulator display accordingly:\nWhen you reach the desired size, release the mouse button.","known-issues-with-the-virtual-keyboard#Known Issues with the Virtual Keyboard":"Klive uses some cheats with the glyphs over the numeric buttons. It emulates that you press the GRAPHICS button to turn on the graphics mode, then emulates the keypress, after that releases the key, and then emulates GRAPHICS again. While keeping the key pressed (the mouse button is held down) works for other keys, this behavior is ignored for glyphs.If you click a glyph button several times repeatedly, the ZX Spectrum OS may not process the emulation of GRAPHICS quickly enough, and thus, the editor does not get out of the graphics mode.\nNote: Sorry for that; it is a kind of issue that is hard to manage. I do not intend to find a fix for it. Please be patient and type a bit slower when you're about to use glyphs."}},"/getting-started/save-programs":{"title":"Saving Files","data":{"":"When you issue a SAVE operation that targets the tape (with ZX Spectrum +3E, you can save the code to disks), Klive saves the code into a .tzx file. Klive saves these files into the Klive/SavedFiles folder within your home directory.\nNote: As of now, you cannot change this default location. However, in the future, Klive will have a setting to define another folder for saved files according to your preference.\nYou can move the saved files to any other location. Using the Machine | Set Tape File command, you can mount that file to load later."}},"/getting-started/tapes":{"title":"Loading from Tape","data":{"":"Klive can emulate playing back tape files with .tap and .tzx extensions. Before utilizing them with the LOAD Basic command, select them with the Machine | Select Tape File function. This command opens a file selection dialog where you can select a .tap or .tzx file. You can select files with other extensions. In that case, the Emulator tries to read them as tape files, trying to parse them.On successful read, you can issue a LOAD Basic command (or use the Tape Loader from the startup menu of ZX Spectrum 128/+2E/+3E). The running LOAD command will playback the selected file.\nNote: You can change the tape file any time, even when the machine is stopped, paused, or running. The effect of such a change is similar to ejecting a tape from a physical tape player and inserting a new one.","normal-and-fast-load#Normal and Fast Load":"Loading ZX Spectrum programs and tapes may take a long time, especially for large files. Besides the normal loading mode, Klive supports fast load, which reads the program instantly, in a fraction of a second.You can turn on or off fast load with the Machine | Fast Load command or by clicking the Fast Load icon (rocket) in the toolbar.You can change the Fast Load mode even while loading a game. However, the change will take effect only when you start loading a program next time.\nNote: By default, fast load is turned on.","revinding-the-tape#Revinding the Tape":"When the loading completes or gets interrupted, the tape position stays as if you stopped the physical tape player. When you issue the LOAD command again, the load operation starts searching the following file header from the position where it has been stopped.You can rewind the tape to its beginning just as you can do it with a physical tape cassette. Click the Rewind icon in the toolbar (the one to the right of the rocket icon) or execute the Machine | Rewind Tape command.\nNote: Klive allows you to examine the contents of a particular tape file. You can learn about it in the IDE documentation.","how-fast-load-works#How Fast Load Works":"The Fast Load mode applies a powerful technique: ROM hooking. While the emulator runs, it observes when the OS reaches a particular entry point of the load subroutine (by examining the value of the PC register) in the ZX Spectrum ROM, including all ZX Spectrum models.When the execution reaches the load routine, the Fast Load mechanism suspends the machine and injects the data from the tape file directly into the memory. While doing this, the algorithm sets the Z80 registers (including the flags) in the same way as the algorithm in the ROM.When the data is loaded, the mechanism sets the current value of the PC register to the exit point of the load routine as if the CPU has executed that and exits the fast mode.If there is some error during the load, the fast load mechanism sets PC to the beginning of the method that reports tape error."}},"/working-with-ide/basic":{"title":"The BASIC Listing","data":{"":"TBD"}},"/working-with-ide/breakpoints":{"title":"The Breakpoints View","data":{}},"/working-with-ide/commands":{"title":"Interactive Commands","data":{"":"TBD"}},"/working-with-ide/cpu":{"title":"The CPU View","data":{"":"TBD"}},"/working-with-ide/disassembly":{"title":"The Disassembly View","data":{"":"TBD"}},"/working-with-ide/editing-code":{"title":"Editing code","data":{"":"TBD"}},"/working-with-ide/ide-settings":{"title":"IDE Settings","data":{"":"TBD"}},"/working-with-ide/memory":{"title":"Displaying the Memory Contents","data":{"":"TBD"}},"/working-with-ide/project-explorer":{"title":"The Project Explorer","data":{"":"TBD"}},"/working-with-ide/run-debug":{"title":"Running and Debugging code","data":{"":"TBD"}},"/working-with-ide/system-vars":{"title":"The System Variables View","data":{}},"/working-with-ide/ula":{"title":"The ULA View","data":{"":"TBD"}},"/working-with-ide/zxb":{"title":"ZX Basic Integration","data":{"":"Klive IDE supports ZX Basic out-of-the-box. After setting up ZX Basic integration, you can use Klive IDE to edit and run ZX Basic programs.\nNote: The current version of ZX Basic does not provide debug information, so source code debugging is not available with the IDE yet.\nAs Klive IDE does not know where to find the ZX Basic compiler on your machine, you must set it up before using it.","setting-up-zx-basic#Setting up ZX BASIC":"You need to download and install ZX Basic. Note the installation folder; you will need it to set up the integration with Klive.The IDE provides a command, zxb-reset (or shorter, zxbr), to connect Klive with ZX BASIC. You can issue this command from the Command window:\nThe command expects one to three parameters:\nThe path to the ZX Basic compiler (required)\nThe path to access the Python interpreter (optional; you may need it on Mac and Linux)\nThe machine code origin address (optional, $8000, if omitted)\nNote #1: The ZX Basic compiler is a Python script, so you need to have Python installed on your machine. On Windows, the IDE can find the Python interpreter automatically. On Mac and Linux, you must provide the path to the Python interpreter.\nNote #2: You can learn more about how settings are stored.","windows-integration#Windows Integration":"Windows 10 and 11 usually install Python with the OS. If not, you can install Python from here. ZX Basic requires Python 3.10 or higher. The installer adds its folder to the PATH environment variable, so you can use zxb-reset with a single command parameter:\nzxb-reset <full path to zxbc.exe>\nWhen you define the path, you should provide the reference for the zxbc.exe file within the folder. For example, if you installed ZX BASIC into the C:\\Users\\joe\\zxbasic folder, use this command:\nzxb-reset C:\\Users\\joe\\zxbasic\\zxbc.exe\nWhen you have a space anywhere in the path, wrap the path into double quotes:\nzxb-reset \"C:\\My folder with spaces\\zxbasic\\zxbc.exe\"","macos-integration#MacOS Integration":"On MacOS, use the zxb-reset command with a full path to the zxbc.py file, like in this example:\nzxb-reset /Users/joe/zxbasic/zxbc.py\nMost of the time, you must also specify the Python interpreter path:\nzxb-reset /Users/joe/zxbasic/zxbc.py /opt/homebrew/bin\nNote: You can find the path of the Python installation with the which python3 command. Do not forget that the last segment is the python3 executable; you should omit it from the path specification.","linux-integration#Linux Integration":"I have not tried to integrate Klive IDE with ZX Basic on Linux. If you did and have a helpful description of the integration steps, please create a PR to extend the installation notes in this article.","using-zx-basic#Using ZX Basic":"Klive IDE considers files with .zxbas extension to be ZX Basic source files. When you open such a file in the code editor (select a file in Explorer), the IDE applies the syntax highlighting of ZX Basic.When you create a new project, by default, the code/code.kz80.asm file is the build root. However, when you right-click the code/program.zxbas file and use the Promote build root command, this file becomes the new build root. From now on, you can use the commands in the document tab toolbar when the program.zxbas file is open.\nYou can use the toolbar buttons to compile, inject, start, or debug the code as described in this article .When you run the ZX Basic code in the default Klive project template, you can see the result in the Emulator window:"}},"/z80-assembly/expressions":{"title":"Expressions","data":{"":"The Klive Assembler has a rich syntax for evaluating expressions. You can use the same syntax with the #if directives, the Z80 instructions, and the compiler statements.You can use operands and operators just like in most programming languages. Nevertheless, the Klive implementation has its particular way of evaluating expressions:\nExpressions can be one of these types:\nBooleans (true or false)\nintegers (64-bit)\nfloating point numbers (64-bit precision)\nstrings (with 8-bit characters)\nThe assembler applies implicit conversion whenever it's possible.\nFloating point numbers are truncated to integer values.\nThe true Boolean literal is represented with the integer value 1; false with 0.\nWhen the assembler needs a Boolean value, 0 is considered false, and any other values as true.\nThere is no implicit conversion between strings and any numeric values.\nWhen the compiler needs a 16-bit value (for example, ld hl,NNNN), it uses the rightmost 16 bits of an expression's value.\nWhen a Z80 operation (for example, ld a,NN) needs an 8-bit value, it utilizes the rightmost 8 bits.\nBesides the parentheses — ( and ) — you can use square brackets\n— [ and ] — to group operations and change operator precedence.\n; This is valid\nld hl,(Offset+#20)*2+BaseAddr\n; Just like this\nld hl,[Offset+#20]*2+BaseAddr","instant-and-late-expression-evaluation#Instant and Late Expression Evaluation":"Depending on the context in which an expression is used, the compiler evaluates it instantly or decides to postpone the evaluation. For example, when you use the .org pragma, the compiler applies immediate evaluation. Let's assume this is your code:\nStart: .org #8000 + Later\n; code body (omitted)\nLater: .db #ff\nThe value of Later depends on the address in .org, and the .org address depends on Later, so this declaration could not be adequately resolved; it's like a deadlock. The .org pragma would raise an error to avoid such situations, as at the moment of its evaluation, the Later symbol's value is unknown.For most Z80 instructions, the compiler uses late evaluation:\nStart: .org #6000\n    ld hl,(MyVar)\n    ; code body omitted\n    ret\nMyVar: .defs 2\nWhen the compiler reaches the ld hl,(MyVar) instruction, it does not know the value of MyVar. Nonetheless, it does not stop with an error but generates the machine code for ld hl,(0), namely #21, #00, and #00;\ntakes a note (it is called a fixup) when MyVal gets a value, the two #00 bytes generated at address #6001\nshould be updated accordingly.","operands#Operands":"You can use the following operands in expressions:\nBoolean, Decimal and hexadecimal literals\nCharacter literals\nIdentifiers\nThe current assembly address\nNote: String literals cannot be used as operands.","operators#Operators":"You can use about a dozen operators, including unary, binary, and ternary. In this section, you will learn about them. They will be introduced in descending order of their precedence.","conditional-operator#Conditional Operator":"The assembler supports using only one ternary operator, the conditional operator:conditional-expression ? true-value : false-valueThis operation results in -1:2 > 3 ? 2 : -1When the conditional-expression evaluates to true, the operation results\nin true-value; otherwise in false-value.\nNote: Conditional expressions are evaluated from right to left, unlike binary operators, which use left-to-right evaluation.","binary-bitwise-operators#Binary Bitwise Operators":"Operator token\tPrecedence\tDescription\t`\t`\t1\tBitwise OR\t^\t2\tBitwise XOR\t&\t3\tBitwise AND — string concatenation with new line\t\nNote: The & operator can be applied to two strings. If you do so, the compiler concatenates the two strings and puts a \\r\\n (new line) character pair between them.","relational-operators#Relational Operators":"Operator token\tPrecedence\tDescription\t==\t4\tEquality\t!=\t4\tNon-equality\t<\t5\tLess than\t<=\t5\tLess than or equal\t>\t5\tGreater than\t>=\t5\tGreater than or equal","shift-operators#Shift Operators":"The bits of the left operand are shifted by the number of bits given by the right operand.\nOperator token\tPrecedence\tDescription\t<<\t6\tShift left\t>>\t6\tShift right","basic-arithmetic-operators#Basic Arithmetic Operators":"Operator token\tPrecedence\tDescription\t+\t7\tAddition — string concatenation\t-\t7\tSubtraction\t*\t8\tMultiplication\t/\t8\tDivision\t%\t8\tModulo calculation\t\nOperator token\tPrecedence\tDescription\t<?\t9\tMinimum of the left and right operand\t>?\t9\tMaximum of the left and right operand","unary-operators#Unary operators":"Operator token\tPrecedence\tDescription\t+\t10\tUnary plus\t-\t10\tUnary minus\t~\t10\tUnary bitwise NOT\t!\t10\tUnary logical NOT\t\nDo not forget, you can change the default precedence with ( and ), or with [ and ].","functions#Functions":"The Z80 assembler provides a number of functions that can have zero, one, or more arguments.\nSeveral functions (for example as rnd()) have overloads with different signatures. Each\nfunction has a name and a parameter list wrapped into parentheses, the parameters are separated\nby a comma. Of course, parameters can be expressions, and they may invoke other functions, too.\nHere are a few samples:\nlength(\"Hello\" + \" world\")\nmax(value1, value2)\nsin(pi()/2)\nsqrt(pear + 3.0)\nThe Klive support these function signatures:\nSignature\tValue\tDescription\tabs(integer)\tinteger\tThe absolute value of an integer number.\tabs(float)\tfloat\tThe absolute value of a float number.\tacos(float)\tfloat\tThe angle whose cosine is the specified number.\tasin(float)\tfloat\tThe angle whose sine is the specified number.\tatan(float)\tfloat\tThe angle whose tangent is the specified number.\tatan2(float, float)\tfloat\tThe angle whose tangent is the quotient of two specified numbers.\tattr(integer, integer, boolean, boolean)\tinteger\tRetrieves the color attribute byte value defined by ink (first argument, 0 to 7), paper (second argument, 0 to 7), bright (third argument, 0 - non-zero), and flash (fourth argument, 0 - non-zero). The bright and flash values are optional.\tattraddr(integer, integer)\tinteger\tReturns the memory address of the byte specified screen attribute in the given line (first argument, from top to bottom, 0-192) and column (second argument, from left to right, 0-255).\tbright(boolean)\tinteger\tRetrieves the bright flag defined by the attribute (0 - non-zero). It can be ORed to create a color attribute value.\tceiling(float)\tfloat\tThe smallest integral value greater than or equal to the specified number.\tcos(float)\tfloat\tThe cosine of the specified angle.\tcosh(float)\tfloat\tThe hyperbolic cosine of the specified angle.\texp(float)\tfloat\te raised to the specified power.\tfill(string, integer)\tstring\tCreates a new string by concatenating the specified one with the given times.\tflash(boolean)\tinteger\tRetrieves the flash flag defined by the argument (0 - non-zero). It can be ORed to create a color attribute value.\tfloor(float)\tfloat\tThe largest integer less than or equal to the specified number.\tfrac(float)\tfloat\tThe fractional part of the specified number.\thigh(integer)\tinteger\tThe leftmost 8 bits (MSB) of a 16-bit integer number.\tink(integer)\tinteger\tRetrieves the three ink bits defined by the color argument (0 to 7). It can be ORed to create a color attribute value.\tint(float)\tinteger\tThe integer part of the specified number.\tlcase(string)\tstring\tThe lowercase version of the input string.\tleft(string, integer)\tstring\tTakes the leftmost characters of the string with the length specified.\tlen(string)\tinteger\tThe length of the specified string.\tlength(string)\tinteger\tThe length of the specified string.\tlog(float)\tfloat\tThe natural (base e) logarithm of a specified number.\tlog(float, float)\tfloat\tThe logarithm of a specified number in a specified base.\tlog10(float)\tfloat\tThe base 10 logarithm of a specified number.\tlow(integer)\tinteger\tThe rightmost 8 bits (LSB) of an integer number.\tlowercase(string)\tstring\tThe lowercase version of the input string.\tmax(integer, integer)\tinteger\tThe larger of two integer numbers.\tmax(float, float)\tfloat\tThe larger of two float numbers.\tmin(integer, integer)\tinteger\tThe smaller of two integer numbers.\tmin(float, float)\tfloat\tThe smaller of two float numbers.\tnat()\tfloat\tRepresents the natural logarithmic base, specified by the constant, e.\tpaper(integer)\tinteger\tretrieves the three paper bits defined by the argument (0 to 7). It can be ORed to create a color attribute value.\tpi()\tfloat\tRepresents the ratio of the circumference of a circle to its diameter, specified by the constant, π.\tpow(float, float)\tfloat\tThe specified number raised to the specified power.\tright(string, integer)\tstring\tTakes the rightmost characters of the string with the length specified.\tround(float)\tfloat\tRounds a float value to the nearest integral value.\tround(float, int)\tfloat\tRounds a float value to a specified number of fractional digits.\trnd()\tinteger\tReturns a random 32-bit number.\trnd(integer, integer)\tinteger\tReturns a random 32-bit integer between the first and second number.\tscraddr(integer, integer)\tinteger\tRetrieves the memory address of the screen pixel byte in the specified line (first argument, from top to bottom, 0-192) and in the specified column (second argument, from left to right, 0-255).\tsign(integer)\tinteger\tReturns an integer that indicates the sign of an integer number.\tsign(float)\tinteger\tReturns an integer that indicates the sign of a float number.\tsin(float)\tfloat\tThe sine of the specified angle.\tsinh(float)\tfloat\tThe hyperbolic sine of the specified angle.\tsqrt(float)\tfloat\tThe square root of a specified number.\tstr(bool)\tstring\tConvert the input value to a string.\tstr(integer)\tstring\tConvert the input value to a string.\tstr(float)\tstring\tConvert the input value to a string.\tsubstr(string, integer, integer)\tstring\tTakes a substring of the specified string from the given position (zero-based) and length.\ttan(float)\tfloat\tThe tangent of the specified angle.\ttanh(float)\tfloat\tThe hyperbolic tangent of the specified angle.\ttruncate(float)\tinteger\tCalculates the integral part of a specified number.\tucase(string)\tstring\tThe uppercase version of the input string.\tuppercase(string)\tstring\tThe uppercase version of the input string.\tword(integer)\tinteger\tThe rightmost 16 bits of an integer number.\t\nFunctions have the same precedence as the unary operators (such as the unary + and -).","parse-time-functions#Parse Time Functions":"The compiler provides a construct, parse time functions. These functions can receive a Z80 assembly language token and transform them into other language constructs. As the name suggests, these functions run in the parsing phase before the compiler emits code.","the-lreg-and-hreg-parse-time-functions#The lreg() and hreg() Parse Time Functions":"These functions accept a 16-bit register pair token (BC, DE, HL, IX, or IY) and retrieve the lower\nor higher 8-bit register half of their input. Here is a sample code snippet:\nld a,lreg(bc)\nld c,hreg(hl)\nld a,lreg(ix)\nld l,hreg(de)\nThe compiler sees as if you wrote this:\nld a,c\nld c,h\nld a,ixl\nld l,d","the-textof-parse-time-function#The textof() Parse Time Function":"You can use textof(), which accepts these kinds of tokens: mnemonic, register, register indirection, C port, or condition. This function translates these tokens into uppercase string constants that represent them.\nHere is a sample:\n.dm textof(ldir)\n.dm textof(bc)\n.dm textof((de))\n.dm textof((c))\n.dm textof(nz)\nThe compiler sees as if you wrote this code:\n.dm \"LDIR\"\n.dm \"BC\"\n.dm \"(DE)\"\n.dm \"(C)\"\n.dm \"NZ\""}},"/z80-assembly/language-structure":{"title":"Klive Z80 Assembly Language Structure","data":{"":"Each line of the source code is a declaration unit and is parsed in its context. Such a source code line can be one of these constructs:\nA Z80 instruction, which can be directly compiled to binary code (such as ld bc,#12AC)\nA directive that is used by the compiler's preprocessor (e.g. #include, #if, etc.)\nA pragma that emits binary output or instructs the compiler about code emission (.org, .defb, etc.)\nA compiler statement (or shortly, a statement) that implements control flow operations for the compiler (e.g., .loop, .repeat...until, .if...elif...else...endif)\nA comment that helps the understanding of the code.","syntax-basics#Syntax Basics":"The assembler language uses a unique way of case sensitivity. You can write reserved words (such as assembly instructions, pragmas, or directives) with lowercase or uppercase letters, but you cannot mix these cases. For example, these instructions use the proper syntax:\nLD c,A\nJP #12ac\nldir\ndjnz MyLabel\nHowever, in these samples, character cases are mixed, and the compiler will refuse them:\nLd c,A\nJp #12ac\nldIR\ndjNZ MyLabel\nIn symbolic names (labels, identifiers, etc.), you can mix lowercase and uppercase letters. Nonetheless, the compiler applies case-insensitive comparison when matching symbolic names. So, these statement pairs are equivalent to each other:\njp MainEx\njp MAINEX\ndjnz mylabel\ndjnz MyLabel\nld hl,ErrNo\nld hl,errNo","comments#Comments":"The language supports two types of comments: end-of-line and block comments.En-of-line comments start with a semicolon (;) or double forward slash (//). The compiler takes the rest of the line into account as the body of the comment. This sample illustrates this concept:\n; This line is a comment-only line\nWait:   ld b,8     ; Set the counter\nWait1:  djnz Wait1 // wait while the counter reaches zero\nBlock comments can be put anywhere within an instruction line between /* and */ tokens until they do not break other tokens. Nonetheless, block comments cannot span multiple lines; they must start and end within the same source code line. All of the block comments in this code snippet are correct:\nSetAttr:\n\tld b,32\nfill:\n  /* block */\n  /* b2 */ ld (hl),a\n  inc /* b3 */ hl\n  djnz /* b4 */ fill /* b5 */\n  ret\nHowever, this will result in a syntax error:\n/* \n  This block comment spans multiple lines,\n  and thus, it is invalid\n*/\nSetAttr:\n\tld b,32\nNote: If you need multi-line comments, you can add single-line comments after each other. The Z80 assembly does not have separate multi-line comment syntax.","literals#Literals":"The language syntax provides these types of literals:\nBoolean values. The following tokens represent Booleans: .false, false, .true, and true.\nDecimal numbers. You can use up to 5 digits (0..9) to declare a decimal number. For example: 16, 32768, 2354.\nFloating point numbers. You can use the same notation for floating point numbers as in C/C++/Java/C#. Here are a few samples:\n.25\n123.456\n12.45E34\n12.45e-12\n3e+4\nHexadecimal numbers. You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare a hexadecimal literal. The compiler looks for a #, 0x, or $ prefix or one of the h or H suffixes to recognize them as hexadecimal. If you use the h or H suffixes, the hexadecimal number should start with a decimal digit 0...9; otherwise, the assembler interprets it as an identifier (label). Here are a few samples:\n#12AC\n0x12ac\n$12Ac\n12ACh\n12acH\n0AC34H\nBinary numbers. Literals starting with one of the %, or 0b prefixes (or with the b or B suffix) are considered binary literals. You can follow the prefix with up to 16 0 or 1 digits. To make them more readable, you can separate adjacent digits with the underscore (_) or single quote (') character. These are all valid binary literals:\n%01011111\n0b01011111\n0b_0101_1111\n0101_1111b\n0b'0101'1111\nOctal numbers. You can use up to 6 digits (0..7) with an o, O (letter O), q, or Q suffix to declare an octal number. Examples: 16o, 327q, 2354Q.\nNote: You can use negative numbers with the minus sign in front of them. The sign is not part of the numeric literal; it is an operator.\nCharacters. You can put a character between single quotes (for example: 'Q').\nStrings. You can put a series of characters between double quotes (for example: \"Sinclair\").\nNote: You can use escape sequences to define non-visible or control characters, as you will learn soon.\nThe $, * or . tokens. These literals are equivalent; all represent the current assembly address.","identifiers#Identifiers":"You can use identifiers to refer to labels and other constants. Identifiers must start with a letter (a...z or A...Z) or with one of these characters: ` (backtick), _ (underscore), @, !, ?, or #. The subsequent ones can be digits and any start characters except backtick. Here are a few examples:\nMyCycle\nERR_NO\nCycle_4_Wait\n`MyTemp\n@ModLocal\nIsLastLine?\nNote: Some strings can be identifiers or hexadecimal literals with the H or h suffix, like AC0Fh, or FADH. The assembler considers such strings as identifiers. To sign a hexadecimal literal, use a 0 prefix: 0FADH is a hexadecimal literal, while FADH is an identifier.\nNote: Theoretically, you can use arbitrary long identifiers. I suggest you make them no longer than 32 characters so readers can read your code easily.","scoped-identifiers#Scoped Identifiers":"As you will later learn, the Klive Assembler supports modules like namespaces in other languages (Java, C#, C++, etc.) to encapsulate labels and symbols. To access symbols within modules, you can use scoped identifiers with this syntax:::? identifier (. identifier)*The optional :: token means the name should start in the outermost (global) scope. The module and identifier segments are separated with a dot. Examples:\n::FirstLevelModule.Routine1\nNestedModule.ClearScreen\nFirstLevelModule.NestedModule.ClearScreen","characters-and-strings#Characters and Strings":"You have already learned that you can utilize character and string literals (wrapped into single or double quotes, respectively), such as in these samples:\n\"This is a string. The next sample is a single character:\"\n'c'\nZX Spectrum has a character set with special control characters such as AT, INK, PAPER, etc. The Assembler allows you to define these with special escape sequences:\nEscape\tCode\tCharacter\t\\i\t0x10\tINK\t\\p\t0x11\tPAPER\t\\f\t0x12\tFLASH\t\\b\t0x13\tBRIGHT\t\\I\t0x14\tINVERSE\t\\o\t0x15\tOVER\t\\a\t0x16\tAT\t\\t\t0x17\tTAB\t\\P\t0x60\tpound sign\t\\C\t0x7F\tcopyright sign\t\\\\\t0x5C\tbackslash\t\\'\t0x27\tsingle quote\t\\\"\t0x22\tdouble quote\t\\0\t0x00\tbinary zero\t\nNote: Some of these sequences have different values than their corresponding pairs in other languages, such as C, C++, C#, or Java.\nTo declare a character by its binary code, you can use the \\xH or\n\\xHH sequences (H is a hexadecimal digit). For example, these\nescape sequence pairs are equivalent:\n\"\\i\"\n\"\\x10\"\n\"\\C by me\"\n\"\\x7f \\x62y me\"","labels-and-symbols#Labels and Symbols":"In Klive Z80 Assembly, you can define labels and symbols. Both constructs are syntactically the same, but there is some difference in their semantics. While we define labels to mark addresses (code points) in the program so that we can jump to those addresses and read or write their contents, symbols are not as specific; they just store values we intend to use.From now on, I will mention \"label\" for both constructs and do otherwise only when the context requires it.When you write a Klive Assembly instruction, you can start the line with a label:\nMyStart: ld hl,0\nHere, in this sample, MyStart is a label. The assembler allows you to omit the colon after the label name, so this line is valid:\nMyStart ld hl,0\nSome developers like to put a label in a separate line from the instruction to which it belongs. You can use the same hanging label style within Klive. In this case, the label should go before its instruction. Take a look at this code snippet:\nMyStart:\n  ld hl,0\nMyNext\n  ; Use B as a counter\n  ld b,32\nThis code is entirely correct. Note the ld b,32 instruction belongs to the MyNext label. As you see from the sample, the colon character is optional for hanging labels, too. You can have multiple line breaks between a label and its instruction, and the space can include comments.","label-and-symbol-declarations#Label and Symbol Declarations":"As you will learn later, you can define symbols with the .EQU or .VAR pragmas. While .EQU allows you to assign a constant value to a symbol, it cannot change its value after the declaration. .VAR lets you re-assign the initial value.Klive supports the idea of lexical scopes. When you create the program, it starts with a global (outermost) lexical scope. Particular language elements, such a statements create their nested lexical scope. Labels and symbols are always created within the current lexical scope. Nonetheless, when resolving them, the assembler starts with the innermost scope and goes through all outer scopes until it finds the label declaration.This mechanism means that you can declare labels within a nested scope so that those hide labels and symbols in outer scopes.Klive also supports modules, which allow you to use namespace-like constructs.","temporary-labels#Temporary Labels":"The assembler considers labels that start with a backtick (`) character as temporary labels. Their scope is the area between the last persistent label preceding the temporary one and the first persistent label following the temporary one.This code snippet demonstrates this concept:\nSetPixels:        ; Persistent label\n  ld hl, #4000\n  ld a,#AA\n  ld b,#20\n`loop:            ; Temporary label (scope #1)\n  ld (hl),a\n  inc hl\n  djnz `loop\nSetAttr:          ; Persistent label, scope #1 disposed here\n  ld hl,#5800\n  ld a,#32\n  ld b,#20\n`loop:            ; Temporary label (scope #2)\n  ld (hl),a\n  inc hl\n  djnz `loop\n  ret\n; scope #2 still lives here\n; ...\nAnother: ; Persistent label, scope #2 disposed here\n  ld a,b\nAs you see, the two occurrences of  `loop  belong to two separate temporary scopes. The first scope is the one between SetPixels and SetAttr, the second one between SetAttr and Another."}},"/z80-assembly/macros":{"title":"Macros","data":{"":"The Klive Assembler provides a powerful way to declare and apply macros in the code. While in most programming languages and assemblers, the macros are preprocessor constructs and use simple\ntext replacement, the Klive implementation is different.\nNote: Unlike in C, C++ (and some Z80 Assemblers), Klive macros emit only code (through instructions and pragmas); they cannot be used as user-defined functions. When you pass parameters to macros, any parameter expression is evaluated instantly, so you cannot use unknown symbols or variables, ones that will get their values only somewhere later in the code.","getting-started-with-macros#Getting Started with Macros":"The best way to show you what macros can do is actual code. Let's start with a simple parameterless macro:\nDelay: \n    .macro()    \n    DelayLoop:\n        djnz DelayLoop\n    .endm\nYou can easily use this macro in your code:\nld b,#24\nDelay()\n; ...and later\nld b,#44\nDelay()\nThe assembler will emit the code like this:\nld b,#24\nDelayLoop_1: djnz DelayLoop_1\n; ...and later\nld b,#44\nDelayLoop_2: djnz DelayLoop_2\nAs you expect, it takes care that the DelayLoop label remains local within the scope of the macro; otherwise, it would lead to a duplicated label name.This macro is named Delay, and it uses the value of the B register to create a djnz loop. You can easily apply this macro.Now, let's enhance this macro with an argument:\nDelay: \n    .macro(wait)    \n        ld b,{{wait}}\n    DelayLoop:\n        djnz DelayLoop\n    .endm\nAs the body of the macro suggests, {{wait}} is a placeholder for the wait argument. While other assemblers do not use a separate markup for a placeholder (they'd just use wait),  Klive applies this markup for\ntwo reasons: first, it is visually better and more eye-catching; second, it allows the compiler to provide better performance.You can use this macro passing an argument value for wait:\nDelay(#24)\nDelay(d)\nAs you expect, the compiler now emits this code:\nld b,#24\nDelayLoop_1: djnz DelayLoop_1\n; ...and later\nld b,d\nDelayLoop_2: djnz DelayLoop_2\nMacros allow you to pass anything that could be an operand in a Z80 instruction, so this is entirely valid:\nDelay((ix+23))\nAs you can imagine, this macro invocation results as if you wrote this:\nld b,(ix+23)\nDelayLoop: djnz DelayLoop\nKlive macros do not stop here. You can define macros that receive an entire Z80 instruction as an argument:\nRepeatLight: \n    .macro(count, body)    \n        ld b,{{count}}\n    DelayLoop:\n        {{body}}\n        djnz DelayLoop\n    .endm\nThis macro is to repeat the body in count several times. This is how you can invoke it:\nRepeatLight(4, \"add a,c\")\nThe second argument of the macro is a string that names the add a,c operation. The result of this macro is this set of instructions:\nld b,4\nDelayLoop_1: \n  add a,c\ndjnz DelayLoop_1\nInstead of a run time loop, you can apply a compile time loop within the macro:\nRepeatLight: \n    .macro(count, body)\n      .loop {{count}}\n          {{body}}\n      .endl\n    .endm\nThe RepeatLight(3, \"add a,c\") line invokes the macro, and the macro's body translates to this:\n.loop 3\n    add a,c\n.endl\nAs you already learned, the compiler handles this as if you wrote:\nadd a,c\nadd a,c\nadd a,c\nKlive allows you to pass a set of lines as a macro argument. You can invoke RepeatLight like this:\nRepeatLigth(3, \"add a,c\" & \"add a,10\")\nOr, you can make it with variables:\nFirstOp = \"add a,c\"\nSecondOp = \"add a,10\"\nRepeatLight(3, FirstOp & SecondOp)\nNote: The & operator between the two string values concatenates them with a next-line character set (#0A and #0D). If you apply the + operator, the above code would fail: the assembler accepts only a single instruction in a text line and would reject multiple instructions.\nIn macros, you can use several unique functions, such as lreg() and hreg(). These work during parse time and retrieve the lower and higher 8-bit register of a 16-bit register pair:\nLdHl: \n    .macro(reg16)\n        ld h,hreg({{reg16}})\n        ld l,lreg({{reg16}})\n    .endm\nHere, you can apply the LdHl macro like this:\nLdHl(de)\nLdHl(bc)\nThe compiler translates these macro invocations into these Z80 instructions:\nld h,d\nld l,e\nld h,b\nld l,c\nWhen you invoke a macro, you can pass fewer parameters than the macro declares. Within the macro body, you can use the def() function to check whether the specified parameter has been passed:\nPush:\n    .macro(r1, r2, r3, r4)\n      .if def({{r1}})\n        push {{r1}}\n      .endif\n      .if def({{r2}})\n        push {{r2}}\n      .endif\n      .if def({{r3}})\n        push {{r3}}\n      .endif\n      .if def({{r4}})\n        push {{r4}}\n      .endif\n    .endm\nThe Push macro in this code snippet allows you to create a push instruction for up to 4 register pairs. Look at these usages:\nPush(af)\n; ... and later\nPush(bc, de, ix)\nThis is what the compiler generates:\npush af\n; ... and later\npush bc\npush de\npush ix\nYou can opt not to pass a macro parameter for a specific argument. Look at this macro declaration:\nLdBcDeHl:\n    .macro(bcVal, deVal, hlVal)\n      .if def({{bcVal}})\n        ld bc,{{bcVal}}\n      .endif\n      .if def({{deVal}})\n        ld de,{{deVal}}\n      .endif\n      .if def({{hlVal}})\n        ld hl,{{hlVal}}\n      .endif\n    .endm\nYou can invoke this macro in these ways, leaving a parameter empty to sign that you do not intend to use it:\nLdBcDeHl(,#1000,#2000)\n; ... and later\nLdBcDeHl(#3000,,#4000)\nThe compiler understands your intention and generates this output:\nld de,#1000\nld hl,#2000\n; ... and later\nld bc,#3000\nld hl,#4000\nIt's time to go deep into the nitty-gritty details of creating and using macros in Klive.","macro-declaration#Macro Declaration":"Macros must have a name. Each macro is named according to the label preceding its declaration, either in the same line as the .macro token or before it as a hanging label. Macros can have zero, one, or more named arguments separated by a comma. The macro declaration is closed with the .endm token:\nMacroWithHangingLabel:\n    .macro(myParam, otherParam)\n    ; Macro body\n    .endm\nMyMacro: macro()\n    ; Macro body\n    .endm\nEven if a macro does not have arguments, its declaration must contain the parentheses.The macro body can contain Z80 instructions, pragmas, or statements. The only exceptions are the ENT and XENT pragmas.As you already experienced, the Assembler supports syntax variants for the macro-related keywords. The Assembler accepts these tokens: .macro, macro, .MACRO, MACRO, .endm, endm, .ENDM, ENDM, .mend, mend, .MEND, and MEND.Within the macro's body, you can refer to the arguments of the macros wrapping them into double curly braces:\nMul10:\n    .macro(reg8)\n    push af\n    ld a,{{reg8}}\n    add a,a\n    push bc\n    ld b,a\n    add a,a\n    add a,a\n    add a,b\n    pop bc\n    ld {{reg8}},a\n    .endm\nArguments are identifiers. Thus, the corresponding naming rules are applied to them. You cannot use a reserved word (for example, a mnemonic like ldir or a register name like hl) as a macro argument.","macro-parameters#Macro Parameters":"You can invoke a macro with as many parameters as many arguments its declaration has or even with fewer parameters. If the macro invocation has more parameters than arguments, the compiler raises an error.Let's assume you've created this macro declaration:\nMyMacro: .macro(arg1, arg2, arg2)\n; Macro body\n.endm\nAll of these usages are valid:\nMyMacro()\nMyMacro(a)\nMyMacro(a, b)\nMyMacro(a, b, c)\nNonetheless, this usage is invalid since it passes more than three parameters:\nMyMacro(a, b, c, d) ; ERROR: To many parameters\nSometimes, it is convenient to omit not the last parameters but one at the beginning or the middle of the parameter list. You can do that: an empty comma separator signs that the preceding parameter is empty. Using this\nnotation, all these invocations of MyMacro are valid:\nMyMacro(,b)\nMyMacro(a,,c)\nMyMacro(,,)\nWithin the macro declaration, you can use the def() function to check if a particular argument has a value.\nLdBcDeHl:\n    .macro(bcVal, deVal, hlVal)\n      .if def({{bcVal}})\n        ld bc,{{bcVal}}\n      .endif\n      .if def({{deVal}})\n        ld de,{{deVal}}\n      .endif\n      .if def({{hlVal}})\n        ld hl,{{hlVal}}\n      .endif\n    .endm\nThe def() function accepts only a macro argument reference (the argument's name wrapped in double curly braces). This function evaluates to true only when the macro argument is not empty.You can use the logical NOT operator (!) combined with def() to check if an argument is empty.\nMyMacro: .macro(arg)\n  .if !def({{arg}})\n    ; generate something for empty arg\n  .endif\n.endm","passing-parameters-to-macros#Passing Parameters to Macros":"You can pass anything as a macro parameter that is a valid operand of a Z80 instruction:\nNames of 8-bit registers and 16-bit register pairs (e.g. a, b, ixl, hl sp, af, etc.)\nNames of conditions (e.g. z, nz, pe, m, etc.)\nMemory address indirection (e.g. (#4000), (#4000+#20))\nRegister pair indirection (e.g. (bc), (de), (hl), etc.)\nIndexed indirection (e.g. (ix+#20), (iy-12), etc.)\nC-port ((c))\nExpression (e.g. (MyId << 1) + 23, #4000, 12*sin(pi()/4), \"ld \" + \"a,b\", etc.)\nYou should be careful when you use parentheses in expressions. Let's assume you declare this macro:\nSetHlValue:\n    .macro(value)\n        ld hl,{{value}}\n    .endm\nWhen you use it, the first invocation uses an expression, and the second has a memory address indirection:\nSetHlValue(#4000+#20)\nSetHlValue((#4000+#20))\nThe compiler translates them to these instructions:\nld hl,#4020\nld hl,(#4020)\nTo avoid such issues, you can use the square brackets to group parts of expressions. When you invoke the SetHlValue macro with this way, both usage with generate a ld hl,#4020 statement:\nSetHlValue(#4000+#20)\nSetHlValue([#4000+#20])\nNote: When you pass parameters to macros, any parameter expression is evaluated instantly, so you cannot use unknown symbols or variables (ones that will get their values only somewhere later in the code.)\nThe compiler replaces the macro argument references to their current values passed in parameters. Whenever you use an expression, its value is converted into a string and put into the place of the macro argument.","passing-instructions-in-a-macro-parameter#Passing Instructions in a Macro Parameter":"Within a macro declaration, you can use a macro argument reference instead of an entire Z80 instruction. Take a look at this macro:\nShortDi:\n    .macro(body)\n        di\n        {{body}}\n        ei\n    .endm\nHere, the body argument is expected to get something the compiler can understand as an entire instruction. When you invoke the macro, you need to pass a string expression so that the compiler can replace the {{body}} reference. Here is an example:\nShortDi(\"in a,(#fe)\")\nAs you expect, the compiler generates this output:\ndi\nin a,(#fe)\nei\nYou are not obliged to use Z80 instructions; the compiler accepts pragmas, too:\nShortDi(\".db #00\")\nWell, the output is not pretty useful; nonetheless, the compiler generates this:\ndi\n.db #00\nei","passing-multiple-lines-in-a-macro-parameter#Passing Multiple Lines in a Macro Parameter":"If you pass multiple lines in a macro parameter where the corresponding argument reference is used instead of an entire instruction line, the compiler will apply all those lines. In this case, the individual lines should be separated by new line characters (\\r\\n). The & operator, when applied for two strings, does this step for you, as it concatenates the two strings with \\r\\n between them. Let's assume you invoke the ShortDi macro with this code:\nShortDi(\"ld a,#7f\" & \"in a,(#fe)\")\nNow, the compiler will generate this output:\ndi\nld a,#7f\nin a,(#fe)\nei\nBecause you can pass expressions as macro parameters, you can invoke the macro in this way, too:\nFirstOp = \"ld a,#7f\"\nSecondOp = \"in a,(#fe)\"\nShortDi(FirstOp & SecondOp)\nYou can pass not only instructions and pragmas to macros but also statements:\nLoopOp = \".loop 3\" & \"nop\" & \".endl\"\nShortDi(LoopOp)\nThe compiler will emit this code:\ndi\nnop\nnop\nnop\nei","labels-symbols-and-variables-in-macros#Labels, Symbols, and Variables in Macros":"Macros have a local scope for all labels, symbols, and variables created within their body, including the label attached to the .endm statement. The macro's name is a label that also represents the start of the macro.Take a look at this macro definition:\nGetBoundaries:\n    .macro(instr)\n        {{instr}}\n        ld de,EndLabel\n        ld hl,GetBoundaries\nEndLabel:\n    .endm\nHere, the ld hl,GetBoundaries instruction fills HL with the start address of the macro, while the ld de,EndLabel instruction puts the address of the next instruction following the macro into DE.Let's assume you use the macro this way:\n.org #8000\nGetBoundaries(\"nop\")\nGetBoundaries(\"ld ix,#ABCD\")\nThe compiler will create this output:\n#8000 GetBoundaries_1 nop\n#8001                 ld de,#8007 ; EndLabel_1\n#8004                 ld hl,#8000 ; GetBoundaries_1\n#8007 EndLabel_1\n      GetBoundaries_2 ld ix,#ABCD\n#800B                 ld de,#8011 ; Endlabel_2\n#800E                 ld hl,#8007 ; GetBoundaries_2\n#8011 EndLabel_2\nSymbols and variables within the context work exactly as they do with loops. Remember: Symbols are constant values, while variables may change!","invoking-macros-from-macros#Invoking Macros from Macros":"Klive allows you to invoke a macro from another macro, too. Here is a short sample:\nDelay:\n    .macro(wait)\n        ld b,{{wait}}\n        WaitLoop: djnz WaitLoop\n    .endm\nBorderPulse:\n    .macro(col1, wait1, col2, wait2)\n        ld a,{{col1}}\n        out (#fe),a\n        Delay({{wait1}})\n        ld a,{{col2}}\n        out (#fe),a\n        Delay({{wait2}})\n    .endm\nHere, the BorderPulse macro uses Delay as a helper macro. The BorderPulse(2, 10, 3, 20) invocation produces this output:\nld a,2\nout (#fe),a\nld b,10\nWaitLoop_1: djnz WaitLoop_1\nld a,3\nout (#fe),a\nld b,20\nWaitLoop_2: djnz WaitLoop_2","macro-related-parse-time-functions#Macro-Related Parse-Time Functions":"The Klive Assembler allows several parse-time functions with macro arguments similar to the def() function to check whether a macro argument has been passed to the macro invocation.These functions check if the argument is an operand the name of the function suggests. Each of them returns true, provided the function recognizes the operand; otherwise, false.The Assembler supports these functions:\nName\tDescription\tisreg8std()\tThe operand is an 8-bit register, one of these: a, b, c, d, e, h, l, i, r, xh (ixh), xl (ixl), yh (iyh), or yl (iyl)\tisreg8std()\tThe operand is a standard 8-bit register, one of these: a, b, c, d, e, h, or l\tisreg8spec()\tThe operand is a special 8-bit register, i, or r\tisreg8idx()\tOne of these 8-bit index registers: xh (ixh), xl (ixl), yh (iyh), or yl (iyl)\tisreg16()\tAny of these 16-bit registers: af, bc, de, hl, sp, ix or iy\tisreg16std()\tAny of the standard 16-bit registers: bc, de, hl, or sp\tisreg16idx()\tAny of the ix or iy registers\tisregindirect()\tThe operand is one of these: (bc), (de), (hl), or (sp)\tisindexedaddr()\tThe operand is an indexed address like (ix), (iy), (ix+#12), (iy-#23), and so on\tiscport()\tThe operand is (c) (e.g., in the out (c),a instruction)\tiscondition()\tThe operand is one of these conditions: z, nz, c, nc, po, pe, p, or m\tisexpr()\tThe operand is an expression, for example: 1 + 2, #1000, myvalue + 23, etc.\tisreg<reg>()\tThe operand is the register as given in <reg>. You can use these names: a, af, b, c, bc, d, e, de, h, l, hl, i, r, xh, xl, ix, yh, yl, iy, and sp. For example, isrega() tests if the specified register is A.\t\nNote: When you pass 'c' as a macro argument, both the isreg8() and iscondition() parse-time functions accept it, as the 'c' token can be either an 8-bit register or a condition (carry flag is set).\nHere is a short sample:\nMyRegMacro: .macro(arg)\n    .if isreg8({{arg}})\n        ld a,{{arg}}\n    .else\n        .error \"Only 8-bit registers are allowed\"\n    .endif\n.endm\nMyRegMacro allows using only an 8-bit register as its argument. If you provide another type of parameter, the macro raises an error."}},"/z80-assembly/pragmas":{"title":"Pragmas","data":{"":"The compiler understands several pragmas that — thought they are not Z80 instructions — they influence the emitted code. Each pragma has two alternative syntax constructs, one with a dot prefix and another without.For example, you can write ORG or .ORG to use the ORG pragma.","the-org-pragma#The ORG pragma":"With the ORG pragma, you define where to place the compiled Z80 code when you run it.For example, the following line sets this location to the 0x6000 address:\n.org #6000\nIf you do not use ORG, the default address is 0x8000.You can apply multiple ORG pragmas in your source code. Each usage creates a new segment in the assembler output. Take a look at this code:\nld h,a\n.org #8100\nld d,a\n.org #8200\nld b,a\nThis code generates three output segments, each with one emitted byte representing the corresponding LD operation. The first segment will start at 0x8000 (default), the second at 0x8100, and the third at 0x8200.","the-xorg-pragma#The XORG pragma":"With the XORG pragma, you define the start address of a specific code section (the section started with the previous .ORG) to use when exporting to Intel HEX format.For example, the following line sets this location to the 0x0000 address; however, the code section starts at 0x6000.\n.org #6000\n.xorg #0\nIf you try to use multiple .XORG within a code section, the assembler raises an error:\n.org #6000\n.xorg #0\n    ld a,b\n    ; ...\n.xorg #1000 ; This line will cause an error message","the-ent-pragma#The ENT pragma":"The ENT pragma defines the entry code of the program when you start it. If you do not apply ENT in your code, the entry point will be the first address of the very first output code segment. Here's a sample:\n.org #6200\nld hl,#4000\n.ent $\njp #6100\n.org #6100\ncall MyCode\n...\nThe .ent $ pragma will sign the address of the jp #6100 instruction as the entry address of the code. Should you omit the ENT pragma from this code, the entry point would be0x6200, as that is the start of the very first output segment, even though there is another segment starting at 0x6100.","the-xent-pragma#The XENT pragma":"The IDE provides a command, Export Code, which allows you to create a LOAD block that automatically starts the code. When you run the code from the IDE, the address specified with the ENT pragma is used. However, the auto LOAD block uses the RANDOMIZE USR address pattern, and you may need to define a different entry address that can be closed with a RET statement. The XENT pragma sets this address.Here's a sample:\nstart: \n\t.org #8000\n\t.ent #8000\n\tcall SetBorder\n\tjp #12ac\nSetBorder:\n\t.xent $\n\tld a,4\n\tout (#fe),a\n\tret\nThe IDE will use #8000 — according to the .ent #8000 pragma — when starting the code from the IDE. Nonetheless, the exported code will offer #8006 — according to the .xent $ pragma — as the startup code address.","the-disp-pragma#The DISP pragma":"The DISP pragma allows you to define a displacement for the code. The value affects the $ token representing the current assembly address. Your code is placed according to the ORG of the particular output segment, but the assembly address is always displaced with the value according to DISP. Take a look at this sample:\n.org #6000\n.disp #1000\nld hl,$\nThe ld hl,$ instruction will be placed to the 0x6000 address, but it will be equivalent\nwith the ld hl,#7000 statement due to the .disp #1000 displacement.\nOf course, you can use negative displacement, too.","the-bank-pragma#The BANK pragma":"The ZX Spectrum 128K/2A/+2A/+3/+3E models handle 16K memory pages (banks) that can be paged into particular memory slots. (You can find more information about this here.)The BANK pragma lets you declare that you want to put the Z80 Assembly code in a specific memory bank. When you export the compiled output, the Export code command of the IDE creates a loader that reads the code and places it on the specified memory page.The BANK pragma accepts two parameters. The first is the bank number (so it must be between 0 and 7). The second one is an optional offset value (between 0 and 16383), which indicates the start offset within the bank. If you omit this, the default value is zero. By default, the Klive Assembler assumes that the start address of the code in the bank is $C000. Nonetheless, you can specify any other value.\nNote: You need to apply the .model Spectrum128 pragma at the top of your code so that you can use .bank.","using-bank-without-an-offset#Using BANK without an offset":"Let's assume you have this code:\n.model Spectrum128\n; ...\n.bank 3\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nThe compiler emits this code (and later, the loader takes care that it goes to bank #3):\n0000: call #C004  ; yellow\n0003: ret\n0004: ld a,#06    ; this is yellow (#C004)\n0006: out (#FE),a\nThe offset values at the beginning of the lines show the byte offset within the 16K memory bank.","using-bank-with-an-offset#Using BANK with an offset":"Let's modify the previous code by adding an offset value:\n.model Spectrum128\n; ...\n.bank 3, #100\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nNow, the compiler emits similar code, but its start address is #C100 (#100 away from the default #C000):\n0100: call #C104  ; yellow\n0103: ret\n0104: ld a,#06    ; this is yellow (#C104)\n0106: out (#FE),a\nThough we're wasting the first 256 bytes of the page, the Export command does not output those bytes. The loader knows that it should load the code from address #C100.","using-bank-with-org#Using BANK with ORG":"Though the default address to compile the code is #C000, you can change it. For example, Bank #2 is paged into the #8000-#BFFF\nmemory range (slot 2), so it seems natural to use the #8000 address like this:\n.model Spectrum128\n; ...\n.bank 2\n.org #8000\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nAs you expect, this is the output:\n0000: call #8004  ; yellow\n0003: ret\n0004: ld a,#06    ; this is yellow (#8004)\n0006: out (#FE),a","using-bank-with-offset-and-org#Using BANK with offset and ORG":"You can combine the offset of the bank with ORG:\n.bank 2, #100\n.org #8000\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nThe output is probably different from the one you expect:\n0100: call #8004  ; yellow\n0103: ret\n0104: ld a,#06    ; this is yellow (#8004)\n0106: out (#FE),a\nAs you can see, the code stream is the same as in the previous case; however, here, the code starts at offset #100.","using-multiple-bank-directives#Using multiple BANK directives":"As you may need multiple memory banks in your program, you can use multiple BANK pragmas, like in this example:\n.bank 1\n; Here is the code for bank #1\n; ...\n.bank 3\n; Here is the code for bank #3\n; ...","restrictions-with-bank#Restrictions with BANK":"BANK cannot have a label.\nBANK cannot be used with the ZX Spectrum 48 model type.\nThe BANK value must be between 0 and 7\nThe offset must be between 0 and 16383\nYou can use the BANK pragma for a particular bank page only once, so, for example, the following code raises\nan error message:\n.bank 1\n; ...\n.bank 3\n; ...\n.bank 1 ; This line raises the error\n; ...\nNote: This is a temporary restriction. In the future, it may be removed.","the-equ-pragma#The EQU pragma":"The EQU pragma allows you to assign a value to an identifier. The label before EQU is the name of the identifier (or symbol), and the expression used in EQU is the variable's value. Here is a short example:\n      .org #6200\n      ld hl,Sym1\nSym1: .equ #4000\n      ld bc,Sym2\nSym2: .equ $+4\nThis sample is equivalent to this one:\n.org #6200\nld hl,#4000 ; Sym1 <-- #4000\nld bc,#620a ; Sym2 <-- #620a as an ld bc,NNNN operation and\n                       an ld hl,NNNN each takes 3 bytes","the-var-pragma#The VAR pragma":"The VAR pragma works similarly to EQU. However, while EQU does not allow the use of the same symbol with multiple value assignments, VAR assigns a new value to the symbol every time it is used.\nNote: The VAR pragma accepts extra syntax alternatives: =, :=","the-injectopt-pragma#The INJECTOPT pragma":"The INJECTOPT pragma expects an identifier-like option tag after the starting pragma keyword. This keyword identifies an option for injecting the code into an emulated machine. The Klive Assembler supports two options:","cursork#cursork":"When you run the ZX Spectrum virtual machine from the IDE, it injects the machine code into the memory and sets up the system as if you started the code from BASIC with the RUN command. By default, it sets the cursor to \"L\" mode.\nHowever, in several cases, you'd like to keep the cursor in \"K\" mode, for example, when you intend to start the code with the\nRANDOMIZE USER addr command (here, addr is the entry address). In this case, you can add the INJECTOP pragma to the code:\n.injectopt cursork","subroutine#subroutine":"This option instructs the IDE to call your code (terminated with RET) and not to jump directly to its start address.\nNote: You can use any other options; the compiler will not raise an exception; it ignores the unknown options.","the-defb-pragma#The DEFB pragma":"The DEFB pragma emits 8-bit expressions (bytes) from the current assembly position. Here is a sample:\n.org #6000\n.defb #01, #02, $, #04\nThe DEFB pragma will emit these four bytes starting at 0x6000: 0x01, 0x02, 0x03, 0x04.\nThe $ expression will emit 0x03, because, at the emission point, the current assembly address is 0x6003. The DEFB program considers only the rightmost 8 bits of any expression: this is how $ results in 0x03.\nDEFB has extra syntax variants: db, .db, DB, and .DB are accepted, too.","the-defw-pragma#The DEFW pragma":"The DEFW pragma is similar to DEFB, but it emits 16-bit values with LSB, MSB order.\n.defw #1234, #abcd\nThis simple code above will emit these four bytes: 0x34, 0x12, 0xcd, 0xab.\nDEFW has extra syntax variants: dw, .dw, DW, and .DW are accepted, too.","the-defm-pragma#The DEFM pragma":"The DEFM pragma emits the byte-array representation of a string. Each character in the string is replaced with the corresponding byte. Take a look at this code:\n.defm \"\\C by me\"\nHere, the DEFM pragma emits 7 bytes for the seven characters (the first escape sequence represents the copyright sign): 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0x65.\nDEFM has extra syntax variants: dm, .dm, DM, and .DM are accepted, too.","the-defn-pragma#The DEFN pragma":"The DEFN pragma works just like the DEFM pragma, but it emits an additional 0x00 byte to terminate the string. Look at this code:\n.defn \"\\C by me\"\nHere, the DEFN pragma emits 8 bytes for the seven characters (the first escape sequence represents the copyright sign) plus the terminating zero: 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0x65, 0x00.\nNote: DEFN has extra syntax variants: dn, .dn, DN, and .DN are also accepted.","the-defc-pragma#The DEFC pragma":"The DEFC pragma works just like the DEFM pragma, but it sets Bit 7 of the last emitted character. Look at this code:\n.defc \"\\C by me\"\nHere, the DEFC pragma emits 7 bytes for the seven characters (the first escape sequence represents the copyright sign) with Bit 7 of the last character (0x65) set (so it becomes 0xE5): 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0xE5.\nNote: DEFC has extra syntax variants: dc, .dc, DC, and .DC are also accepted.","the-defh-pragma#The DEFH pragma":"The DEFH pragma uses a string with an even number of hexadecimal digits to emit a byte-array representation of the input. Each character pair in the string is replaced with the corresponding byte. Take a look at this code:\n.defh \"12E4afD2\"\nHere, the DEFH pragma emits 4 bytes: 0x12, 0xe4, 0xaf, 0xd2.\nNote: DEFH has extra aliases: dh, .dh, DH, and .DH.","the-defs-pragma#The DEFS pragma":"You can emit zero (0x00) bytes with this pragma. It accepts a single argument, the number of zeros to emit. This code sends 16 zeros to the generated output:\n.defs 16\nNote: DEFS has extra syntax variants: ds, .ds, DS, and .DS are also accepted.","the-fillb-pragma#The FILLB pragma":"With FILLB, you can emit a particular count of a specific byte. The first argument of the pragma sets the count, and the second specifies the byte to emit. This code emits 24 bytes of #A5 values:\n.fillb 24,#a5","the-fillw-pragma#The FILLW pragma":"With FILLW, you can emit a particular count of a 16-bit word. The first argument of the pragma sets the count, and the second specifies the word to emit. This code emits 8 words (16 bytes) of #12A5 values:\n.fillw 8,#12a5\nOf course, the bytes of a word are emitted in LSB/MSB order.","the-skip-pragma#The SKIP pragma":"The SKIP pragma, as its name suggests, skips the number of bytes from the current address to that specified in the first argument. It fills up the skipped bytes with 0xFF by default, but the fill value can be set with the second argument:\n.skip $+#05      ; fills next 5 bytes with 0xFF\n.skip $+#04, #3a ; fills next 4 bytes with 0x3A","the-extern-pragma#The EXTERN pragma":"The EXTERN pragma is kept for future extension. The current compiler accepts it but does not act when observing this pragma.","the-model-pragma#The MODEL pragma":"This pragma is used when you run or debug your Z80 code within the emulator. With Spectrum 128K, Spectrum +3, and Spectrum Next models, you can run the Z80 code in different contexts. The MODEL pragma lets you specify which model to run the code. You can use the SPECTRUM48, SPECTRUM128, SPECTRUMP3, or NEXT identifiers to choose the model (identifiers are case-insensitive):\n.model Spectrum48\n.model Spectrum128\n.model SpectrumP3\n.model Next\nFor example, when you create code for Spectrum 128K, and add the .model Spectrum48 pragma to the code, the Run command will start the virtual machine, turn the machine into Spectrum 48K mode, and ignite the code just after that.\nNote: With the #ifmod and #ifnmod directives, you can check the model type. For example, the following Z80 code results in a green background on Spectrum 48K and cyan on Spectrum 128K:\n    .model Spectrum48\n#ifmod Spectrum128\n    BorderColor: .equ 5\n    RetAddr: .equ #2604\n#else\n    BorderColor: .equ 4\n    RetAddr: .equ #12a2\n#endif\nStart:\n    .org #8000\n    ld a,BorderColor\n    out (#fe),a\n    jp RetAddr","the-align-pragma#The ALIGN pragma":"This pragma allows you to align the current assembly counter to the specified byte boundary. You can use this pragma with an optional expression. Look at these samples:\n.org #8000\n    nop\n.align 4\n    nop\n.align\nThe first pragma aligns the assembly counter to #8004, the next 4-byte boundary. With no value specified, .align uses #100, and thus the second .align in the sample sets the current assembly counter to the next page boundary, #8100.","the-trace-and-tracehex-pragmas#The TRACE and TRACEHEX pragmas":"These pragmas send trace information to the assembler output. In the Visual Studio IDE, these messages are displayed in the Z80 Build Output pane. List one or more expressions separated by a comma after the .trace token. TRACEHEX works like TRACE, but it displays integer numbers and strings in hexadecimal format.Let's assume you add these lines to the source code:\n.trace \"Hello, this is: \", 42\n.tracehex \"Hello, this is: \", 42\nWhen you compile the source, the lines above display these messages:\nTRACE: Hello, this is: 42\nTRACE: 48656C6C6F2C20746869732069733A20002A","the-rndseed-pragma#The RNDSEED pragma":"With the rnd() function, you can generate random numbers. The RNDSEED pragma sets the seed value to use for random number generation. If you use this pragma with an integer expression,\nthe seed is set to the value of that expression. If you do not provide the expression, the compiler uses the system clock to set up the seed.\n.rndseed ; sets the seed according to the system clock\n.rndseed 123 ; sets the seed to 123","the-defgx-pragma#The DEFGX pragma":"This pragma helps you define bitmaps in the code. This pragma excepts a string expression and utilizes that string as a pattern to generate bytes for the bitmap.\nNote: DEFGX has extra syntax variants: dgx, .dgx, DGX, and .DGX are accepted, too.\nIf the very first character of the string pattern is <, the pattern is left aligned and starts with the second character. Should the first character be >, the pattern is right aligned and starts with the second character. By default (if no < or > is used) the pattern is left-aligned.Spaces within the pattern are ignored and considered helpers. Other characters are converted into bits one by one.Before the conversion, the pragma checks if the pattern constitutes multiples of 8 bits. If not, it uses zeros as prefixes (right-aligned) or zeros as suffixes (left-aligned), so the pattern would be adjusted to contain entire bytes.The . (dot), - (dash), and _ (underscore) sign 0, and any other characters stand for 1. Every 8 bits in the pattern emit a byte.Here are a few samples:\n.dgx \"....OOOO\"         ; #0F\n.dgx \">....OOOO\"        ; #0F\n.dgx \"<----OOOO\"        ; #0F\n.dgx \"___OOOO\"          ; #1E\n.dgx \"....OOOO ..OO\"    ; #0F, #30\n.dgx \">....OO OO..OOOO\" ; #03, #CF","the-defg-pragma#The DEFG pragma":"This pragma helps you define bitmaps in the code. This pragma excepts a string pattern (note: not a string expression!)\nand utilizes that string as a pattern to generate bytes for the bitmap.\nNote: DEFG has extra syntax variants: dg, .dg, DG, and .DG are also accepted.\nSpaces within the pattern are ignored and considered helpers. Other characters are converted into bits one by one. The pixels in a byte are planted with the LSB as the most significant bit, and multiple bytes are planted LSB byte first.The . (dot), - (dash), and _ (underscore) sign 0, and any other characters stand for 1. Every 8 bits in the pattern emit a byte.Here are a few samples:\n.dg ....OOOO        ; #0F\n.dg ___OOOO         ; #1E\n.dg ....OOOO ..OO\"  ; #0F, #30\n.dg ....OO OO..OOOO ; #0F, #3C\nNote: Unlike in the pattern used with DEFGX, here, the leading > and < characters are taken as bit 1. They do not specify bit alignment.","the-error-pragma#The ERROR Pragma":"You can raise custom error messages with this pragma. ERROR accepts an expression and displays an error message with code Z0500 using your provided text. Here is a sample:\n.error \"The value must be greater than\" + str(minvalue)","the-includebin-pragma#The INCLUDEBIN Pragma":"You can include a binary file into the source code to emit all bytes as if you used the .defb pragma. You can include the entire file or a single segment of it. The pragma has a mandatory argument, the name of the binary file to include, and two optional ones, the start offset of the segment and its length, respectively. Let's see a few examples:\n.includebin \"./myfile.bin\"\n.includebin \"./myfile.bin\" 2\n.includebin \"./myfile.bin\" 2, 3\nThis snippet loads the myfile.bin file from the same directory that contains the source\nwith the .includebin directive.Let's assume that myfile.bin contains these bytes:\n#00, #01, #02, #03, #04, #05, #06, #07 \nThe three lines of code above are the same as if we had written these code lines:\n.defb #00, #01, #02, #03, #04, #05, #06, #07 ; .includebin \"./myfile.bin\"\n.defb #02, #03, #04, #05, #06, #07           ; .includebin \"./myfile.bin\" 2\n.defb #02, #03, #04                          ; .includebin \"./myfile.bin\" 2, 3\nNote: The compiler does not allow negative file offset or length. It else raises an error if you define a segment that does not fit into the binary file. You can use an alternative syntax for .includebin. The compiler accepts these tokens and their uppercase versions, too: includebin, .include_bin, and include_bin.","the-comparebin-pragma#The COMPAREBIN pragma":"When re-engineering a Z80 program from an exported disassembly, it is good to know that you do not break the original code. The .comparebin pragma helps you to check that you still compile what you expect. It loads a binary file and compares that file with the output of the current code segment.The pragma has a mandatory argument, the name of the binary file to include, and two optional ones, the start offset of the segment and its length, respectively. Let's see a few examples:\n.comparebin \"./myfile.bin\"\n.comparebin \"./myfile.bin\" 2\n.comparebin \"./myfile.bin\" 2, 3\nNote: The compiler does not allow negative file offset or length. It also raises an error if you define a segment that does not fit into the binary file. You can use alternative syntax for .comparebin. The compiler accepts these tokens, too: comparebin, .COMPAREBIN, and COMPAREBIN.\nWhen you compile the code, every .org pragma opens a new segment that starts from the point defined by .org.You can put it into the code in as many places as you want. As the compiler parses the code, it records the positions of .comparebin pragmas, the current output segment, and its length at the point where .comparebin is used. When the code compilation is ready, and there are no errors, the compiler executes a check. This check compares the emitted bytes with the recorded length to the bytes in the binary file.\nIf the length of the segment is greater than the size of the file, the compiler raises an error.\nThe comparison checks only the as many bytes as are in the output segment; if more are in the binary file, the remaining data is ignored.\nIf the compared data do not match, the assembler raises an error with the first unmatching position.\nLet's assume we have the origin.bin file that contains these six bytes:\n#00, #01, #02, #03, #04, #05\nTake a look at this code:\n  .org #8000\n  .defb #00, #01, #02\n  .comparebin \"origin.bin\"\n  .org #8100\n  .defb #03, #04, #05\n  .comparebin \"origin.bin\"\n  .comparebin \"origin.bin\", 3\nThis code contains two segments (it has two .org pragmas) and three .comparebin.\nThough origin.bin has six bytes, the first comparison succeeds, utilizing only the three bytes emitted in the first segment.\nThe second comparison fails, as the file starts with #00, #01, #02, while the segment emits #03, #04, and #05.\nThe third comparison succeeds, as it starts the examination from the 4th byte (offset 3) of the binary file."}},"/z80-assembly/statements":{"title":"Assembler Statements","data":{"":"Statements are Klive Assembler-specific control flow constructs. — thanks again for the inspiration by Simon Brattel — that instruct the compiler about loop-like and conditional compilation.\nNote: While directives help you to organize your code and include code files optionally according to the compilation context, statements provide you with more valuable tools to shorten the way you can declare Z80 assembly code.\nEach statement can be written with a leading dot or without it, and the compiler accepts both lowercase and uppercase versions. For example, all of these versions are valid: .if, if, .IF, and IF.","the-loop-block#The LOOP Block":"With the LOOP block, you can organize a cycle to emit code. Here is a sample that tells the gist:\n.loop 6\n  add hl,hl \n.endl\nThis construct is a shorter way to multiply HL with 64. It is equivalent to the following code:\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\nThe .loop statement accepts an expression. The compiler repeats the instructions within the\nloop's body according to the value of the expression. The .endl statement marks the end of the loop.\nNote: You can use many flavors for the .endl block closing statement. .endl, endl, .lend, lend are all accepted — with uppercase letters, too.\nLook at this code:\ncounter .equ 2\n; do something (code omitted)\n.loop counter + 1\n  .db #80, #00\n.endl\nThis code is as if you wrote this:\n  .db #80, #00\n  .db #80, #00\n  .db #80, #00","the-loop-scope#The LOOP Scope":"The .loop statement declares a scope for all labels, symbols, and variables in the loop's body. Every iteration has its separate local scope. When the assembler resolves symbols, it starts from the loop's scope and tries to resolve the symbol's value. If the lookup fails, it steps out to\nthe outer scope, and goes on with the resolution.Check this code:\nvalue .equ 2\n; do something (code omitted)\n.loop 2\n    value .equ 5\n    ld a,value\n.endl\nThe compiler takes it into account as if you wrote this:\n    ld a,5\n    ld a,5\nThe value symbol declared within the loop overrides value in the outer scope, and thus, 5 is used instead of 2.Nonetheless, when you utilize a different construct, it seems a bit strange at first:\nvalue .equ 2\n; do something (code omitted)\n.loop 2\n    ld a,value\n    value .equ 5\n    ld b,value\n.endl\nThe strange thing is that the compiler creates this:\n    ld a,2\n    ld b,5\n    ld a,2\n    ld b,5\nWhen the assembler resolves value in the ld a,value instruction, if finds value in the outer scope only, as it is not declared yet within the loop's scope. In the ld b,value instruction value gets resolved from the inner scope and takes 5.","variables-and-scopes#Variables and Scopes":"Unlike symbols that work as constant values, variables (declared with the .var pragma or its syntactical equivalents, the = or := tokens) can change their values.Take a look at this code:\ncounter = 4\n.loop 3\n    innercounter = 4\n    ld a,counter + innercounter\n    counter = counter + 1\n.endl\nHere, the counter variable is defined in the global scope (out of the loop's scope), while innercounter in the local scope of the loop. When evaluating the counter = counter + 1 statement, the compiler finds counter in the outer scope, so it uses that variable to increment its value. This code emits machine code for this source:\nld a,#08\nld a,#09\nld a,#0A\nNow, add a single line to the loop's code:\ncounter = 4\n.loop 3\n    innercounter = 4\n    ld a,counter + innercounter\n    counter = counter + 1\n.endl\nld b,innercounter\nThe compiler will not compile this code, as it cannot find the value for innercounter in the ld b,innercount instruction. Because innercounter is defined in the local scope of the loop, this scope is immediately disposed as the loop is completed. When the compiler processes the ld b,innercounter instruction, the local scope is not\navailable.","labels-and-scopes#Labels and Scopes":"Labels behave like symbols, and they work similarly. When you create a label within a loop, that label is created in\nthe local scope of the loop. The following code helps you understand which labels are part of the global scope and which are created in the loop's scope:\n.org #8000\nMyLoop: .loop 2\n    ld bc,MyLoop\nInner: \n    ld de,MyEnd\n    ld hl,Inner\n    ld ix,Outer\nMyEnd: .endl\nOuter: nop\nThe label of the .loop statement is part of the outer (global) scope, just like the label that follows the\n.endl statement. However, all labels declared within the loop's body, including the label of the .endl statement, belong to the local scope of the loop.Thus, the compiler translates the code above into this one:\n         (#8000): ld bc,#8000 (MyLoop)\nInner_1  (#8003): ld de,#800D (MyEnd_1)\n         (#8006): ld hl,#8003 (Inner_1)\n         (#8009): ld ix,#801A (Outer)\nMyEnd_1  (#800D): ld bc,#8000 (MyLoop)\nInner_2  (#8010): ld de,#801A (MyEnd_2)\n         (#8013): ld hl,#8010 (Inner_2)\n         (#8016): ld ix,#801A (Outer)\nMyEnd_2\nOuter    (#801A): nop\nHere, Inner_1, Inner_2, MyEnd_1, and MyEnd_2 represent the labels created in the local scope of the loop. The _1 and _2 suffixes indicate that each loop iteration has a separate local scope. As you can see, the last iteration of MyLabel points to the first outer address (Outer label).","nesting-loops#Nesting LOOPs":"Of course, you can nest loops, such as in this code:\n.loop 3\n  nop\n  .loop 2\n    ld a,b\n  .endl\n  inc b\n.endl\nThis code snippet translates to this:\nnop\nld a,b\nld a,b\ninc b\nnop\nld a,b\nld a,b\ninc b\nnop\nld a,b\nld a,b\ninc b\nWhen you nest loops, each loop has its separate scope.","the-cnt-value#The $CNT value":"It is handy to use the $cnt value that represents the current loop counter. It starts from 1 and increments to the maximum number of loops. This sample demonstrates how you can use it:\n.loop 2\n  outerCount = $cnt\n  .loop 3\n     .db #10 * outerCount + $cnt\n  .endl\n.endl\nThis code translates to this:\n.db #11\n.db #12\n.db #13\n.db #21\n.db #22\n.db #23\nYou can observe that each loop has its separate $cnt value.\nNote: The $cnt value has several syntax versions that the compiler accepts: $CNT, .cnt, and .CNT.","the-procendp-block#The PROC..ENDP Block":"In the previous section, you could understand how labels and scopes work for the .loop statement. You can utilize this scoping mechanism with the help of the .proc...endp statement. This sample code demonstrates the concepts (just as you learned earlier):\n.org #8000\nMyLabel:\n  ld de,Outer\n  ld hl,Mylabel\n  call MyProc\n  halt\nMyProc: \n  .proc\n    ld bc,MyProc\n  MyLabel: \n    ld de,MyEnd\n    ld hl,MyLabel\n    ld ix,Outer\n    ret\nMyEnd:\n    .endp\nOuter: nop\nThe first MyLabel label belongs to the global scope, while the second (within MyProc) to the local scope of the procedure wrapped between .proc and endp. MyProc belongs to the global scope, too, however, MyEnd is part of the MyProc scope, so it is visible only from\nwithin the procedure.The assembler emits this code:\nMyLabel  (#8000): ld de,#8018 (Outer)\n         (#8003): ld hl,#8000 (MyLabel)\n         (#8006): call #800A (MyProc)\n         (#8009): halt\nMyProc   (#800A): ld bc,#800A (MyProc)\nMyLabel_ (#800D): ld de,#8018 (MyEnd)\n         (#8010): ld hl,#800D (MyLabel_)\n         (#8013): ld ix,#8018 (Outer)\n         (#8017): ret\nMyEnd\nOuter    (#8018): nop\nYou can nest PROC blocks just as LOOP blocks. Each PROC block has its private scope. When the compiler sees a PROC block, it works as if you wrote .loop 1.\nNote: PROC is different than a loop. You cannot use the $cnt value. Similarly, the break and continue instructions are unavailable within a PROC block.\nNote: The assembler accepts these aliases for PROC and ENDP: .proc, proc, .PROC, PROC, .endp, .ENDP, endp, ENDP, .pend, .PEND, pend, and PEND.","the-repeatuntil-block#The REPEAT..UNTIL Block":"While the .loop statement works with an expression that specifies the loop counter, the .repeat...until block uses an exit condition to create more flexible loops. Here is a sample:\ncounter = 0\n.repeat \n    .db counter\n    counter = counter + 3\n.until counter % 7 == 0\nThe counter % 7 == 0 condition specifies when to exit the loop. Because the exit condition is examined only at the end of the loop, the .repeat blocks execute at least once.The sample above translates to this:\n.db 0\n.db 3\n.db 6\n.db 9\n.db 12\n.db 15\n.db 18\nThe .repeat block uses the same approach to handle its local scope, symbols, labels, and variables as the .loop block. The block also provides the $cnt loop counter that starts from 1 and increments in every loop cycle.This sample demonstrates the .repeat block in action:\n.org #8000\ncounter = 0\n.repeat \n    .db low(EndLabel), high(Endlabel), $cnt\n    counter = counter + 3\nEndLabel: .until counter % 7 == 0\nThe compiler translates the code to this:\n.db #03, #80, #01\n.db #06, #80, #02\n.db #09, #80, #03\n.db #0C, #80, #04\n.db #0F, #80, #05\n.db #12, #80, #06\n.db #15, #80, #07","the-whileendw-block#The WHILE..ENDW Block":"With .while loop, you can create another kind of block, which uses an entry condition. For example, the following code snippet generates instructions to create the sum of numbers from 1 to 9:\ncounter = 1\n    ld a,0\n.while counter < 10\n    add a,counter\n    counter = counter + 1\n.endw\nThe .while...endw block uses an entry condition declared in the .while statement. Provided this condition is true, the compiler enters into the body of the loop and compiles all instructions and statements\nuntil it reaches the .endw statement. The body of the loop may never be reached.The compiler translates the code snippet above to the following:\nld a,0\nadd a,1\nadd a,2\nadd a,3\nadd a,4\nadd a,5\nadd a,6\nadd a,7\nadd a,8\nadd a,9\nLike the .loop and the .repeat blocks, .while uses the same approach to handle its local scope, symbols, labels, and variables. This block also provides the $cnt loop counter that starts from 1 and increments in every loop cycle.This code demonstrates the .while block with labels and using the $cnt value:\ncounter = 0\n.while counter < 21 \n    .db low(EndLabel), high(Endlabel), $cnt\n    counter = counter + 3\nEndLabel: .endw\nThe compiler translates the code to this:\n.db #03, #80, #01\n.db #06, #80, #02\n.db #09, #80, #03\n.db #0C, #80, #04\n.db #0F, #80, #05\n.db #12, #80, #06\n.db #15, #80, #07\nNote: You can use many flavors for the .endw block closing statement. .endw, endw, .wend, and wend are all accepted — with uppercase letters, too.","the-fornext-loop#The FOR..NEXT Loop":"You can use the traditional .for...next loop to create a loop:\n.for myVar = 2 .to 5\n  .db 1 << int(myVar)\n.next\nThis loop uses the myVar variable as its iteration variable, which iterates from 1 to 4. As you expect, the compiler translates the for-loop into this:\n.db #04\n.db #08\n.db #10\n.db #20\nYou can specify a .step close to change the loop increment value:\n.for myVar = 1 .to 7 .step 2\n  .db 1 << int(myVar)\n.next\nNow, the code translates to this:\n.db #02\n.db #08\n.db #20\n.db #80\nYou can create a loop with decrementing iteration variable value:\n.for myVar = 7 .to 1 .step -2\n  .db 1 << int(myVar)\n.next\nAs you expect, now you get this translation:\n.db #80\n.db #20\n.db #08\n.db #02\nNote: As with the other statements, you can use the .for, .to, and .step keywords without the . prefix, so for, to, and step are also valid.\nThe for-loop can do the same stunts as the other loops; it handles labels, symbols, and variables similarly. There's only one exception: the loop iteration variable. If this variable is found in an outer scope, instead of using that value, the compiler raises an error. You can use the for-loop only with a freshly created variable.So, both cases in this code raise an error:\nmyVar = 0\n.for myVar = 1 .to 4 ; ERROR: Variable myVar is already declared\n  ; ...\n.next\n.for _i = 1 .to 3\n  .for _i = 3 .to 8 ; ; ERROR: Variable _i is already declared\n    ; ...\n  .next\n.next\nNote: As i is a reserved token (it represents the I register), you cannot use i as a variable name. Nonetheless, _i is a valid variable name.\nThe for-loop works with both integer and float variables. If the initial value, the last value (the one after .to), or the increment value (the one after .step) is a float value, the for-loop uses float operations; otherwise, it uses integer operations.This code snippet demonstrates the difference:\n.for myVar = 1 .to 4 .step 1\n  .db 1 << myVar\n.next\n.for myVar = 1 .to 4 .step 1.4\n  .db 1 << myVar ; ERROR: Right operand of the shift left operator must be integral\n.next\nNonetheless, you can solve this issue by applying the int() function:\n.for myVar = 1 .to 4 .step 1.4\n  .db 1 << int(myVar) ; Now, it's OK.\n.next\nNote: You can still use the $cnt value in for loops. Just like with other loops, it indicates the count of cycles starting from one and incremented by one in each iteration.","maximum-loop-count#Maximum Loop Count":"It's pretty easy to create an infinite (or at least a very long) loop. For example, these loops are infinite ones:\n.repeat\n.until false\n.while true\n.wend \nThe assembler checks the loop counter during compilation. Whenever it exceeds #FFFF (65535), it raises an error.","the-ifelifelseendif-statement#The IF..ELIF..ELSE..ENDIF Statement":"You can use the .if statement to create branches with conditions. For example, this code emits inc b or inc c statement depending on whether the value of branch is even or odd:\n.if branch % 2 == 0\n  inc b\n.else\n  inc c\n.endif\nYou do not have to specify an .else branch, so this statement is entirely valid:\n.if branch % 2 == 0\n  inc b\n.endif\nYou can nest if statements like this to manage four different code branches according to the value of branch:\n.if branch == 1\n  inc b\n.else\n  .if branch == 2\n    inc c\n  .else \n    .if branch == 3\n      inc d\n    .else\n      inc e\n    .endif\n  .endif\n.endif\nNonetheless, you can use the .elif statement to create the code snippet above more clearly:\n.if branch == 1\n  inc b\n.elif branch == 2\n  inc c\n.elif branch == 3\n  inc d\n.else\n  inc e\n.endif","if-and-scopes#IF and Scopes":"Unlike the loop statements, .if does not provide its local scope. Whenever you create a symbol, a label, or a variable, those get into the current scope. This code defines a label with the same name in each branch. Because the compiler evaluates the .if branches from top to down, it either compiles one of the .elif branches —\nthe first with a matching condition — or the else branch. Thus, this code does not define MyLabel twice:\nbranch = 4 ; Try to set up a different value\n; Do something (omitted from code)\n    ld hl,MyLabel\n.if branch == 1\n  inc b\n  MyLabel ld a,20\n.elif branch > 2\n  MyLabel ld a,30\n  inc c\n.elif branch < 6\n  inc d\n  MyLabel ld a,40\n.else\n  MyLabel ld a,50\n  inc e\n.endif\nGenerally, you can decorate any statement with labels. The .elif and .else statements are exceptions. If you do so, the compiler raises an error:\n.if branch == 1\n  inc b\n  MyLabel ld a,20\n.elif branch > 2\n  MyLabel ld a,30\n  inc c\nOther .elif branch < 6 ; ERROR: ELIF section cannot have a label\n  inc d\n  MyLabel ld a,40\nAnother .else          ; ERROR: ELSE section cannot have a label\n  MyLabel ld a,50\n  inc e\n.endif","if-nesting#IF Nesting":"When you nest .if statements, ensure each has a corresponding .endif. Whenever the compiler finds an .endif, it associates it with the closest .if statement before .endif. Use indentation to make the structure more straightforward, as the following code snippet shows:\nrow = 2\ncol = 2\n; Change row and col (omitted from code)\n.if row == 0\n  .if col == 0\n    .db #00\n  .elif col == 1\n    .db #01\n  .else\n    .db #02\n  .endif\n.elif row == 1\n  .if col == 0\n    .db #03\n  .elif col == 1\n    .db #04\n  .else\n    .db #05\n  .endif\n.elif row == 2\n  .if col == 0\n    .db #06\n  .elif col == 1\n    .db #07\n  .else\n    .db #08\n  .endif\n.else\n  .if col == 0\n    .db #09\n  .elif col == 1\n    .db #0A\n  .else\n    .db #0B\n  .endif\n.endif","the-ifusedifnused-statements#The IFUSED/IFNUSED Statements":"Klive offers a similar construct to IF..ELIF..ELSE..ENDIF, using the IFUSED or IFNUSED statement instead of IF. These new statements are specialized forms of IF. You can use these statements to emit code depending on whether a symbol (label, .EQU, .VAR, structure, or structure field) exists and has already been used by the code preceding the IFUSED/IFNUSED statement.Here are a few examples:\nMyProc:\n  ld hl,#5800\n  ld (hl),a\n  ret\n  ; some other code\n  .ifused MyProc\n    MyMsg: .defn \"MyProc is used\"\n  .else\n    MyMsg: .defn \"MyProc is not used\"\n  .endif\nMain:\n  ld hl,MyMsg\nHere, the .ifused statement will set the string the MyMsg label point to according to whether the MyProc label is used. As in this case, MyProc is defined but not invoked before the .ifused statement, HL will point to the \"MyProc is not used\" message.Should you call MyProc before .ifused, HL would point to the other message, \"MyProc is used\":\nMyProc:\n  ld hl,#5800\n  ld (hl),a\n  ret\n  ; some other code\n  call MyProc\n  ; some other code\n  .ifused MyProc\n    MyMsg: .defn \"MyProc is used\"\n  .else\n    MyMsg: .defn \"MyProc is not used\"\n  .endif\nMain:\n  ld hl,MyMsg\nThe .ifnused statement is the complement of .ifused. It is evaluated to a true condition value only if the symbol following .ifnused is not defined or, if defined, is not used.","ifusedifnused-syntax#IFUSED/IFNUSED Syntax":"You must specify a symbol after the .ifused  or .ifnused keywords. These symbols must follow the syntax of identifiers. They can be compound names used for modules and structures. So, all of these symbol names are correct:\nMyLabel\nMyStruct\nMyStruct.FieldX\nMyModule.Main\n::NestedModule.Start.MyProc\nNote: You can use these aliases for .ifused: .IFUSED, ifused, IFUSED. Similarly, .ifnused accept alternative tokens: .IFNUSED, ifnused, and IFNUSED.","ifusedifnused-semantics#IFUSED/IFNUSED Semantics":"The Klive Assembler accepts any .ifused and .ifnused statements until they are syntactically correct. When the assembler tests their condition, it works this way:\nIf the specified symbol does not exist, .ifused evaluates to false, while .ifnused evaluates to true.\nIf the particular symbol exists and is used in the code section preceding the .ifused or .ifnused statement, .ifused evaluates to true, and .ifnused to false.\nIf the particular symbol exists and it is not used in the code section preceding the .ifused or .ifnused statement, .ifused evaluates to false, .ifnused to true.\nThese statements do not support the look-ahead in the code. This behavior could lead to paradoxical situations, like in this example:\nMyFlag = true\nMyValue: .equ #1234\n  ; some other code that does not use MyValue\n  .ifused MyValue\n    MyFlag = false;\n  .endif\n  ; some other code that does not change MyFlag\n  .if MyFlag\n    ld a,MyValue\n  .endif\nShould .ifused work with look-ahead, this code would make the compiler scratch its virtual head. Because MyFlag is set to true, the .if statement at the bottom of the code would emit an ld a,MyValue instruction. The compiler would say that .ifused MyValue should be considered true. However, in this case, the body .ifused would set MyFlag to true, and that would prevent the bottom .if from emitting ld a,MyValue, and then MyValue would not be used at all.","block-statements-without-a-closing-statement#Block Statements without a Closing Statement":"The compiler automatically recognizes if a block does not have a closing statement and provides an error message accordingly.","orphan-closing-statements#Orphan Closing Statements":"When the compiler finds a closing statement (such as .endw, .endl, .until, .endif, etc.) it will issue an error.","the-break-statement#The BREAK statement":"You can exit the loop — independently of the loop's exit condition — with the .break statement:\n; LOOP sample\n.loop 5\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.endl\n; REPEAT sample\n.repeat\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.until $cnt == 5\n; WHILE sample\n.while $cnt < 5\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.endw\n; FOR-loop sample\n.for value = 1 to 5\n  .if value == 4\n    .break\n  .endif\n  .db value\n.next\nBecause all these loops are exited at the beginning of the 4th iteration, they produce this output:\n.db #01\n.db #02\n.db #03\nNote: You cannot use the .break statement outside a loop construct. If you do so, the compiler raises an error.","the-continue-statement#The CONTINUE Statement":"You can interrupt the current iteration of the loop and carry on the next iteration with the .continue statement:\n; LOOP sample\n.loop 5\n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.endl\n; REPEAT sample\n.repeat\n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.until $cnt == 5\n; WHILE sample\n.while $cnt <= 5 \n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.endw\n; FOR-loop sample\n.for value = 1 to 5\n  .if value == 4\n    .continue\n  .endif\n  .db value\n.next\nBecause all these loops skip the 4th iteration, they produce this output:\n.db #01\n.db #02\n.db #03\n; #04 is skipped\n.db #05\nNote: You cannot use the .continue statement outside of a loop construct. If you do so, the Assembler raises an error."}},"/z80-assembly/structs":{"title":"Structures","data":{"":"Klive allows you to use structure definitions and placements in your Z80 programs. If you know the struct construct from C, C++, or C#, the concept in Z80 is only partly similar.","understanding-structures#Understanding Structures":"In Klive Assembler, a structure definition is a placeholder that defines a byte pattern like this:\nObject2D: .struct\n    .defw 0\n    .defw 0\n    .defb 1\n    .defb 1\n  .ends\nThis definition says that Object2D is a structure of six bytes (two 16-bit words and two 8-bit bytes) with the following bytes emitted: #00, #00, #00, #00, #01, #01. Whenever you place a structure declaration in a program, just like in this sample, the assembler will emit the bytes you specified in the .struct definition:\n  Object2D() ; emits #00, #00, #00, #00, #01, #01\nAs you can see, six subsequent bytes do not tell enough about the semantics of Object2D. When we created this structure, the original concept was to use two 16-bit numbers to specify the X and Y coordinates of the object, plus two 8-bit numbers to describe its horizontal and vertical velocity. With field definitions (see X, Y, DX, and DY), the meaning of Object2D is more straightforward than it was before:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nOf course, we would like to initialize objects with different states. With field initializers, we can define structures with initial states that are different from the .struct definition:\nApple: Object2D()\n  X -> .defw 100\n  Y -> .defw 100\nPear: Object2D()\n  DX -> .defb -1\n  DY -> .defb -1\n  ; Some other code\n  ; ...\n  ld hl,Apple\n  ld de,Pear\nIn this sample, the Apple label (that the code later loads into HL) points to an Object2D declaration that holds 100 in its X and Y values. Another label, Pear, points to a different instance of Object2D (later, the code loads that address into DE). Pear has a converse velocity compared to Apple.The Assembler allows you to initialize structures with any pragma that emits bytes to the assembly output. For example, the following code snippet sets a new Object2D structure in a particular way:\nBanana: Object2D()\n  -> .defb 10, 1\n  -> .defb 12, 2\n  DX -> .defb 2, 2\nThe first .defb pragma (right after the first ->) emits two bytes, 10 and 1, respectively, and it sets the X field to 266 (10 + 1256). The second .defb sets Y to 524 (12 * 2256). The initialization of DX (DX -> .defb 2, 2) emits two bytes and sets both DX and DY to 2.","structure-definition#Structure Definition":"You can define structure between the .struct and .ends  statements. Each structure must have a unique name to declare with a label. The compiler accepts all of these definitions:\n; Version #1\nMyStruct .struct\n  ; ...\n  .ends\n; Version #2\nMyStruct: .struct\n  ; ...\n  .ends\n; Version #3\nMyStruct\n  .struct\n  ; ...\n  .ends\n; Version#4\nMyStruct:\n  .struct\n  ; ...\n  .ends\nNonetheless, it raises an error if you do not name the structure:\n.struct ; ERROR: .struct must have a name\n; ...\n.ends\nNote: The assembler accepts the following alternative keywords for .struct: .STRUCT, struct, or STRUCT. Similarly, .ends has these aliases, too: .ENDS, ends, and ENDS. Though you can define an empty structure, there is no practical reason to do so.\nIn the body of the structure, you can use only one of these byte-emitter pragmas: .defb, .defw, .defm, .defn, .defc, .defs, .fillb, .fillw, .defg,  or .defgx. If you try to use any other construct, the compiler raises an error message.As you saw earlier, you can specify field labels within the structure body. The assembler is flexible: you can omit field labels or even use multiple labels for a single field:\nObject2D_A: .struct\n  Coords:\n    X: .defw 0\n    Y: .defw 0\n  Velocity:\n    .defb 1\n    .defb 1\n  .ends\nHere, Object2D_A has two field name for the first .defw field, Coords, and X, respectively. The last .defb does not have its field name, unlike the one before, Velocity.","labels-and-field-names#Labels and Field Names":"The label assigned to the .struct definition has a dual role. When used in a structure initialization (for example, as Object2D is utilized in the Object2D() initializer), it identifies the structure. Nonetheless, you can use the label name in Z80 instructions, too. In this case, the label's value is the size of the structure. For example, these instructions are equivalent, as the size of the Object2D structure is six bytes:\nld a,Object2D ; Size of Object2D\n; ...\nld a,6 ; \nYou can allocate a memory block for 100 uninitialized instances of Object2D with this pragma:\nMy100Objects:\n  .defs 100 * Object2D\nNote: You cannot assign a label to the .ends statement. If you do, the compiler throws an error.\nLabels assigned to the body of the .struct definition are used as field names. You can use them only with the structure name:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nApple: Object2D()\n  ; ...\n  ld hl,Apple + Object2D.DX\n  ld a,(hl)\nField label values contain the offset of the particular field from the beginning of the structure. Thus, the last two instructions in the code above load the content of the Apple structure's DX field into A.According to these definitions, here are the field label values of Object2D:\nObject2D.X: 0\nObject2D.Y: 2\nObject2D.DX: 4\nObject2D.DY: 5","structure-initialization#Structure initialization":"The .struct definition does not emit any code; it just tells the compiler the layout and initial contents of a structure. To allocate space for a particular structure, you need to initialize it with the name of the structure plus a pair of opening and closing parentheses, just like these samples show:\n; Initalize an Object2D\nMyObject: Object2D()\n; Initialize another one\nOtherObject: Object2D()\nWhen you add a label to the structure initialization, that label's value points to the beginning of the structure in the memory.\nstart: .org #8000\nDistanceEntry:\n  .struct\n    Address: .defw $\n    SeqNo: .defb Index\n  .ends\nData: .org #9000\nIndex = 1;\nEntry1:\tDistanceEntry()\nIndex = 2;\nEntry2:\tDistanceEntry()\nIndex = 3;\nEntry3:\tDistanceEntry()\nThe compiler emits the initialization code for Entry1, Entry2, and Entry3 as if you wrote this:\nData .org #9000\nEntry1:\n  .defw #9000\n  .defb 1\nEntry2:\n  .defw #9003\n  .defb 2\nEntry3:\n  .defw #9006\n  .defb 03","field-initializers#Field Initializers":"Field initializers can be used to change the default structure initializer. A field initializer has this syntax:[identifier] -> byte-emitter-pragmaFor a moment, let's forget that identifier is optional. When you use it, it must be one of the structure's field names. The byte-emitter-pragma is one of the Klive pragmas you can use to define a structure body, namely these:  .defb, .defw, .defm, .defn, .defc, .defs, .fillb, .fillw, .defg,  or .defgx.\nNote: You can use the label syntax for field names; thus, you can add an optional colon after the identifier.\nYou can apply field initializer statements right after the structure initialization. Any other Z80 instruction, pragma, statement, or directive signs the end of the structure initialization. This code snippet shows two examples of setting up Object2D structures. The first is correct; however, the second one raises an error:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nObj1: Object2D()\n  DX -> .defb 2\n  DY -> .defb 2\n  ld a,b\n  ; ... Some other code\nObj2: Object2D()\n  X -> .defw 100\n  Y -> .defw 100\n  ld hl,#4000    ; Field initialization stops here\n  DX -> .defb 4  ; ERROR\nThe compiler does not care how you initialize fields. For example, even if you have created the X field of Object2D with a .defw pragma, you can set its value with .defb, like in this example:\nObj3: Object2D()\n  X -> .defb 100, 0\nYou can even initialize two fields with a simple initializer statement. For example, DX and DY are one byte each. You can initialize both of these fields in a single step, as these code snippet shows:\nObj4: Object2D()\n  DX -> .defb 2,2\nObj5: Object2D()\n  DX -> .defw #0202\nThe order of fields is unimportant; you can initialize them in any order:\nObj6: Object2D()\n  DX -> .defb 1\n  X -> .defw 100\n  DY -> .defb 1\n  Y -> .defw 200","fluent-structure-initialization#Fluent Structure Initialization":"The assembler allows flexible initialization, where you do not use field names. The compiler emits bytes as the byte emitter pragmas would do if you were not within a structure initialization. Let's assume you initialize an Object2D this way:\nObj7: Object2D()\n  -> .defb 1, 0\n  DX -> defw #0303\nWithout the field initializers, the structure would contain these six bytes:#00, #00, #00, #00, #01, #01However, the field initializers overwrote the default bytes with the ones displayed in boldface:#01, #00, #00, #00, #03, #03You can choose your preferred way to initialize a structure using a field or unnamed initializers. The compiler does not care how you assemble the set of bytes within the structure. However, it does not allow you to overflow the structure boundaries. This sample shows you two initializations of Object2D. The first is correct, as it emits exactly six bytes. However, the second raises an error since the initialization tries to put eight bytes into the structure:\nObj8: Object2D()\n  -> .defm \"012345\"\nObj9: Object2D()    ; ERROR: The code tries to initialize the structure with 8 bytes\n  X -> .defw 100\n  -> .defm \"012345\""}},"/z80-assembly/z80-assembler":{"title":"The Klive Z80 Assembler","data":{"":"The original goal of the Klive Assembler was to have a simple tool that allows you to compile Z80 assembly code and inject it into the ZX Spectrum virtual machine. As the community has started using it, I've been receiving feature requests to add some helpful capabilities to the Assembler.","main-features#Main Features":"Here is a list of essential features the Klive Assembler supports:\nFull Z80 instruction set, including the initially undocumented Z80 registers and instructions\n(such as the 8-bit halves of ix and iy, namely ixl, ixh, iyl, iyh).\nZX Spectrum Next extended Z80 instruction set\nAlternate syntax versions. All directives, pragmas, and statements have multiple versions; you can use your preferred notation. For example, you can use .loop, loop, .LOOP or LOOP to declare a loop. All of the .defb, DEFB, .db, DB (and a few other) tokens can be used for defining byte data.\nZ80 Preprocessor. With preprocessor directives, you can execute conditional compilation and include other source files, inject symbols for debug time, and run time compilations separately. In Klive\nyou can use powerful macros, too. Nonetheless, they are not preprocessor constructs (see below).\nFast compilation. Of course, it depends on the code, but the compiler can emit code for about ten thousand source code lines per second (MacBook Pro).\nRich expressions. The compiler can handle most arithmetic and logic operators in C, C++, C#, Java, and JavaScript. You can use integer, float, and string expressions. The language supports more than 40 functions that you can use in the expressions (e.g., Amp * sin($cnt * Pi() / 16))\nRich literal formats. Decimal, float, hexadecimal, binary, and string literals are available.\nYou can use multiple variants for hexadecimal numbers ($12ae, #12AE, 0x12AE, 12AEh), and binary numbers\n(0b00111100, %00111100, %0011_1100). In strings, you can use ZX Spectrum-specific escape codes, for example, \\i for INK, \\P for the pound sign, and many others.\nAssembler control flow statements. You can use loops (loop, repeat..until, while..wend, for..next) and conditional statements (if) to create an assembler control flow. These constructs\ncan be nested and provide local scope for labels, symbols, and variables.\nPowerful dynamic macros. You can create macros with arguments. In the macro bodies, the current values of arguments can replace entire instructions, operands, or parts of expressions. Moreover, through arguments, you can inject multiline instructions and statements into macro declarations.\nModules. You can use modules to serve both as logical containers to separate partitions of the code and namespaces to create scopes for labels and symbols.","how-the-assembler-works#How The Assembler Works":"The assembler compiles the code in these phases:\nIt takes the source code and runs a preprocessor that parses the entire code and applies the directives in the code. You can easily recognize directives starting with #, such as #ifdef, #endif, #define, #include, and others. During the preprocessing phase, the assembler detects the syntax errors and loads and processes the included files. The result is a digested syntax tree that does not contain directives anymore, only instructions, pragmas, and statements.\nThe assembler collects macro definitions and stores their syntax tree to later use them when macros are invoked with their actual parameters.\nThe assembler goes through the digested syntax tree and emits code. During this operation, it must evaluate expressions to resolve symbols and identifiers to their actual values. Because the assembler progresses from the first line to the last, it may happen that it cannot get the value of an identifier, which is defined somewhere later in the code. When the assembler detects such a situation, it notes it and creates a fixup entry.\nThe assembler goes through all fixup entries and resolves symbols not defined in the previous phase. Of course, it might find unknown symbols. If this happens, the assembler reports an error.\nNote: Several pragmas and statements intend to evaluate an expression in phase 3. If they find an unresolved symbol during that phase, they do not create a fixup entry but immediately report an error."}},"/z80-assembly/z80-instructions":{"title":"Accepted Z80 Instructions","data":{"":"The Klive Assembler implements every officially documented Z80 instruction as well as the non-official ones. During the implementation, the ClrHome.org was used as a reference.Z80 instructions may start with a label. Labels are identifiers that can be terminated by an optional colon (:). The compiler accepts both labels in these samples:\nStart: ld b,#f0\nWait   djnz Wait","z80-mnemonics#Z80 Mnemonics":"The compiler accepts these mnemonics:ADC, ADD, AND, BIT, CALL, CCF, CP, CPD,\nCPDR, CPI, CPIR, CPL, DAA, DEC, DI, DJNZ,\nEI, EX, EXX, HALT, IM, IN, INC, IND,\nINDR, INI, INIR, JP, JR, LD, LDD, LDDR, LDDRX*, LDDX*,\nLDI, LDIR, LDIRSCALE*, LDIRX*, LDIX*, LDPIRX*, MIRROR*, MUL*, NEG,\nNEXTREG*, NOP, OR, OTDR, OTIR, OUT, OUTINB*,\nOUTD, OUTI, PIXELAD*, PIXELDN*, POP, PUSH, RES, RET, RETI, RETN,\nRL, RLA, RLC, RLCA, RLD, RR, RRA, RRC,\nRRCA, RRD, RST, SBC, SCF, SET, SETAE*, SLA, SLL\nSRA, SRL, SUB, SWAPNIB*, TEST*, XOR.\nNote: The instructions marked with * can be used only with the ZX Spectrum Next model.","z80-registers#Z80 Registers":"The compiler uses the standard 8-bit and 16-bit register names, as specified in the official\nZilog Z80 documentation:\n8-bit registers: A, B, C, D, E, H, L, I, R\n16-bit registers: AF, BC, DE, HL, SP, IX, IY\nFor the 8-bit halves of the IX and IY index registers, the compiler uses these names: XL, XH, YL, YH. Alternatively, the compiler accepts these names, too: IXL, IXH, IYL, IYH. As a kind of exception to general naming conventions, these mixed-case names are also accepted: IXl, IXh, IYl, IYh.","jp-syntax#JP Syntax":"Z80 assemblers use two different syntax constructs for the indirect JP statements:\n; Notation #1\njp hl\njp ix\njp iy\n; Notation #2\njp (hl)\njp (ix)\njp (iy)\nThe Klive Assembler accepts both notations.","alu-operations-syntax#ALU operations syntax":"Three standard ALU operations between A and other operands (ADD, ADC, and SBC) sign A\nas their first operand:\nadd a,b\nadc a,(hl)\nsbc a,e\nHowever, the five other standard ALU operations between A and other operands (SUB, AND, XOR,\nOR, and CP) omit A from their notation:\nsub e\nand (hl)\nxor e\nor c\ncp b\nThe Klive compiler accepts the second group of ALU operations using the explicit A operand, too:\nsub a,e\nand a,(hl)\nxor a,e\nor a,c\ncp a,b"}},"/":{"title":"Introduction to Klive IDE","data":{"":"Klive IDE is a retro computer emulator and Integrated Development Environment running on Mac and Windows.Klive offers not only the emulators but also debugging views, a multi-pane code editor, interactive commands, and other tools to create your Z80 Assembly and ZX BASIC (Boriel's Basic) programs.Klive IDE supports dual monitor mode to place the Emulator and IDE on different monitors while working with code.","supported-emulators#Supported Emulators":"Klive IDE intends to support retro computers with the Z80 family of CPUs. Klive supports these emulators:\nZX Spectrum 48K\nZX Spectrum 128K\nZX Spectrum +2E/+3E (in progress)\nZX 80/81 (in the future)\nCambridge Z88 (in the future)\nZX Spectrum Next (in the future)","emulator-features#Emulator Features":"The emulator can run the selected machine with or without debugging. These modes can be changed without restarting the running machine:\nStarting, pausing, continuing to run\nStart or continue in debug mode\nSetting up breakpoints, step-in, step-over, step-out modes\nTo examine the state of the emulator, Klive offers several views:\nFull CPU view\nFull ULA view\nMemory view with live refresh\nDisassembly view with execution point tracking\nMonitoring system variable values\nDisplaying (and exporting) the current BASIC listing\nYou can quickly load and play programs (games) from files:\nLoading tape files (.tap and .tzx)\nFast load\nLoading from disk files (.dsk) with ZX Spectrum +3E\nWriting and formatting disk (.dsk) files (in progress)\nOther emulator features:\nVisual keyboard (ZX Spectrum 48K and ZX Spectrum 128K styles)\nMultiplying CPU clock speed (1-24 multiplier)\nSetting up the sound level, muting and unmuting sound\nPlanned features (in the future):\nUsing custom machine ROMs\nMemory read/write breakpoints\nI/O read/write breakpoints\nBreakpoints with hit count conditions","ide-features#IDE Features":"The IDE allows you to open project folders that keep the files belonging to a particular (development) project together. You can use Z80 Assembly language (with the built-in Klive Z80 Assembler) and ZX BASIC (Boriel's Basic) as your programming language.\nSyntax highlighting\nSource code debugging (works with the Klive Z80 Assembler)\nExporting the compiled code to tape files (.tap and `.tzx) with BASIC loaders\nKlive's unique feature is the one-click start and debugging: With a click of one button, your code is compiled and injected into the selected emulator and immediately starts up. You can start your code with debugging (or pause it and continue with debugging).Commands: The IDE has an interactive command panel to issue CLI commands executed within the IDE.Planned features (in the future):\nWatch Panel: display runtime information about memory variables (expressions)\nConditional breakpoints\nIntegration with other assemblers, including compilation and optional source code debugging (if the particular compiler supports debug symbol information)."}}}