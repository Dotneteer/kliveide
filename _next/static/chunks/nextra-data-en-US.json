{"/commands-reference":{"title":"Commands Reference","data":{"bp-ea#bp-ea":"This command erases all breakpoints already set.\nbp-ea\nAvailable aliases: eab","bp-list#bp-list":"This command lists the breakpoints already set.\nbp-list\nAvailable aliases: bpl","bp-del#bp-del":"This command removes a breakpoint.\nbp-del <address-spec>\nAvailable aliases: bdThe address-spec parameter can be\na 16-bit address (using the number for the address), for example, $120a or 32768;\nan address with a partition (the partition and the address separated with a colon), for example, r1:$32ac (meaning $32ac, provided ROM 1 is paged in);\nor a source code line specification, for example, [code/code.kz80.asm]","bp-en#bp-en":"This command turns a breakpoint already set on or off.\nbp-en <address-spec> [-d]\nAvailable aliases: bdThe address-spec parameter can be\na 16-bit address (using the number for the address), for example, $120a or 32768;\nan address with a partition (the partition and the address separated with a colon), for example, r1:$32ac (meaning $32ac, provided ROM 1 is paged in);\nor a source code line specification, for example, [code/code.kz80.asm]\nThe -d option disables the breakpoint.","bp-set#bp-set":"This command sets a breakpoint.\nbp-set <address-spec>\nAvailable aliases: bpThe address-spec parameter can be\na 16-bit address (using the number for the address), for example, $120a or 32768;\nan address with a partition (the partition and the address separated with a colon), for example, r1:$32ac (meaning $32ac, provided ROM 1 is paged in);\nor a source code line specification, for example, [code/code.kz80.asm]","close#close":"Use this command to close the folder currently opened in the IDE.\nclose","clh#clh":"Use this command to clear the interactive command prompt history.\nclh","cls#cls":"Use this command to clear the interactive command output.\ncls","compile#compile":"This command compiles the code, provided a Klive project is loaded, and a build root file is selected.\ncompile\nAvailable aliases: co","crd#crd":"This command creates an empty disk file (DSK format) you can use with ZX Spectrum +3 models (and compatible).\ncrd <disk-type> <disk-name> [<disk-folder>] [-p]\nThese are the arguments of the command:\ndisk-type: One of these supported formats:\nss: Single-sided CPC\nds: Double-sided CPC\nsse: Single-sided Extended CPC\ndse: Double-sided Extended CPC\ndisk-name: The name of the disk file (.dsk extension as added automatically)\ndisk-folder: An optional folder in which the new disk file is created. The folder must exist.\n-p: Creates the disk file within the currently opened project folder (under disks).","debug#debug":"This command compiles the code. If the compilation is successful, it injects the code into the current virtual machine and starts it in debug mode. This command requires that a Klive project be loaded.\ndebug\nAvailable aliases: rd\nNote: The command will start (or restart) the virtual machine.","dis#dis":"This command disassembles the specified memory section and displays the disassembly result in a new document pane.\ndis <start> <end> [-d] [-c] [-lc]\nIt requires a start and an end (inclusive) address. Use the -d option if you want the disassembly to display addresses, numbers, and instructions with decimal numbers. The -c option turns on the concise mode (disassembled bytes are omitted from the output). By default, labels do not end with colons; however, you can turn on this mode with the -lc option.\nNote: This command does not support bank operations (yet). It can disassemble only the currently paged 64K memory.","em-debug#em-debug":"This command starts the current machine in debug mode.\nem-debug\nAvailable aliases: :d","em-out#em-out":"This command executes all instructions until it exits the current subroutine and pauses at the instruction following the subroutine call. It expects the machine to be paused when this command is issued.\nem-out\nAvailable aliases: :o\nNote: If the function returns unconventionally (for example, popping the return address and jumping to it, etc.), this command may not stop the machine.","em-pause#em-pause":"This command pauses (suspends) the current machine.\nem-pause\nAvailable aliases: :p","em-restart#em-restart":"This command restarts (stops, and then starts) the current machine.\nem-restart\nAvailable aliases: :r","em-start#em-start":"This command starts the current machine.\nem-start\nAvailable aliases: :s","em-sti#em-sti":"This command executes the next Z80 instruction from the current PC (Program Counter) and pauses the machine again. It expects the machine to be paused when this command is issued.\nem-sti\nAvailable aliases: :","em-sto#em-sto":"This command executes the next Z80 instruction from the current PC (Program Counter). If that instruction is a function call or a block instruction, it executes the entire subroutine or block operation before pausing again. It expects the machine to be paused when this command is issued.\nem-sto\nAvailable aliases: .\nNote: If the function call does not return to the instruction following the current instruction at the PC address, the machine won't pause again (unless it reaches a breakpoint).","em-stop#em-stop":"This command stops the current machine.\nem-stop\nAvailable aliases: :h","expc#expc":"This command compiles the code and exports it according to the specified options.\nexpc filename [-n name] [-f format] [-as] [-p] [-c] [-b border]\n  [-sb] [-addr address] [-scr screenfile]\nThese are the input arguments and options:\nfilename: The name of the exported file\n`-n: The name of the program in the exported file. This name will be displayed during the LOAD operation.\n-f: The file format to use:\nhex: Intel HEX format\ntzx: TZX file format\ntap: TAP file format\n-as: Autostart the exported code after loading it\n-p: Add a PAUSE statement into the loader (before starting the loaded code)\n-c: Add a clear statement to keep the end of the BASIC code before the start address of the exported code\n-b: Specifies the border color to set when the loader program starts\n-sb: The compiled code may contain multiple segments. If this option is used, the exporter merges all code segments into one (filling up the padding code with zeros). Otherwise, each code segment goes into a separate CODE file.\n-addr: Specifies the start address of the exported code. The exported extracts this information from the compilation result if not specified. However, you can change the inferred address with this option.\n-scr: You can specify a screen file (TAP or TZX format) to load after the autoloader.\nNote #1: If the compilation fails, no code will be exported.\nNote #2: If you compile code for a ZX Spectrum 128 (or upper) model with multiple bank support, the exporter creates a loader that loads the banks in the compilation (and puts them into the appropriate memory bank) before starting the app.","hide-disassembly#hide-disassembly":"Use this command to hide the machine code disassembly view.\nhide-disassembly\nAvailable aliases: hdis","hide-memory#hide-memory":"Use this command to hide the memory contents view.\nhide-memory\nAvailable aliases: hmem","inject#inject":"This command compiles the code, and if the compilation is successful, it injects the code into the current virtual machine. This command requires that a Klive project be loaded and the virtual machine be paused.\ninject\nAvailable aliases: inj","nav#nav":"This command navigates to the specified project file (to an optional position). If the file is not open yet, the IDE opens it.\nnav projeFile [line] [column]\nThe filename argument is a project file name. When you specify the name, use the full name (including the file extension) relative to the project's root folder. For example, if your file is in the code folder and named program.zxb, use the code/program.zxb parameter.You can specify an optional line and column argument to jump to the specified location within the file.","newp#newp":"This project creates a new Klive project and optionally opens it.\nnewp <machine-id> <project-name> [<template>] [-p <project-folder>] [-o]\nThe machine-id  argument specifies the ID of the machine and an optional model. When you specify the machine and model type, use a colon to separate the machine ID from the model ID. For example, use sp48 for the basic ZX Spectrum 48K model and sp48:ntsc to use the NTSC version of ZX Spectrum 48K. See the Machine Types article for these IDs.The project-name argument defines the project's name. Unless the optional project-folder parameter is specified, the new project is created in the KliveProjects folder within your user folder.Klive may support multiple project templates for a particular machine type (it provides a default template for each). If you want a specific template, specify its name in the template argument. See the Project Templates article for more information about available templates.By default, the IDE creates a new project but does not open it. However, if you add the -o option, the new project will be immediately opened.","num#num":"This command displays its argument number in decimal, hexadecimal, and binary formats.\nnum <number>\nThe input argument can be in decimal, hexadecimal, or binary format.","open#open":"Use this command to open a folder.\nopen [<folder-path>]\nAvailable aliases: opIf the folder-path argument is omitted, the IDE opens the show folder dialog to select a project folder. Otherwise, the IDE opens the project you specified. If the folder path is relative, the IDE loads the folder within your user directory's KliveProjects folder.","outp#outp":"You can select a particular output pane with this command.\noutp <paneId>\nThe paneId argument can be one of the available output panes (emu, build, or script).","projectexcluded-items#project:excluded-items":"This command lists the definitions of excluded project items. You can use the -global option to list the items that are excluded globally.\nproject:excluded-items [-global]\nAvailable aliases: project:list-excluded, proj:excluded-items, proj:list-excluded, p:lx","projectexclude-item#project:exclude-item":"This command adds or deletes excluded project items. You can use the -global option to list the items that are excluded globally. The -d option signs that the defined option should be deleted from the exclusion list. You can specify multiple items to add or delete.\nproject:exclude-item [--global] [-d] <item-path-1> ... <item-path-n>\nAvailable aliases: project:exclude, proj:exclude-item, proj:exclude, p:x","run#run":"This command compiles the code. If the compilation is successful, it injects the code into the current virtual machine and starts it. This command requires that a Klive project be loaded.\nrun\nAvailable aliases: r\nNote: The command will start (or restart) the virtual machine.","run-build-function#run-build-function":"This command starts the build command function (see the build.ksx file) named in the command argument.\nrun-build-function <function-name>\nAvailable aliases: rbfThe build.ksx file contains several commands, such as buildCode, injectCode, runCode, debugCode, and exportCode. Some projects may have additional custom commands.","script-cancel#script-cancel":"This command runs the script file specified in the argument.\nscript-cancel <script-file-path-or-script-id>\nAvailable aliases: scYou can provide a script file name or a script ID as an argument. When you start a script, the ID of the running script is displayed. You can also get a particular script's ID from the Script History panel.When you specify a file name, use the full name (including the .ksx file extension) relative to the project's root folder. For example, if your script is in the scripts folder and named myScript.ksx, use the scripts/myScript.ksx parameter.","script-output#script-output":"This command navigates to the output document of the specified script.\nscript-output <script-id>\nAvailable aliases: soYou must provide a script ID as an argument. When you start a script, the ID of the running script is displayed. You can also get a particular script's ID from the Script History panel.","script-run#script-run":"This command runs the script file specified in the argument.\nscript-run <script-file-path>\nAvailable aliases: srProvide the full file name (including the .ksx file extension) relative to the project's root folder. For example, if your script is in the scripts folder and named myScript.ksx, use the scripts/myScript.ksx parameter.","set#set":"You can use this comment to set or delete a particular Klive setting.\nset [-p] [-u] <key> [<value>] \nUse the -p option to set a project setting or -u for a user setting. <key> is the setting key, <value> is the new setting value. The specified key is removed if you omit <value>.\nNote: Project settings are saved in the currently open project file, while user settings are saved in the Klive/live.settings file under your user folder.\nIf you do not specify the context (with -p or -u), the IDE will save a project setting, provided a project is open; otherwise, it saves a user-level setting.","setl#setl":"This command lists the specified settings.\nsetl [-p] [-u] [<setting>] \nUse the -p option to list project settings or -u for user settings. By default, all settings in the specified bucket are listed. Additionally, you can specify a setting prefix in <setting>. In this case, only matching settings are listed.\nNote: Project settings are saved in the currently open project file, while user settings are saved in the Klive/live.settings file under your user folder.\nIf you do not specify the context (with -p or -u), the IDE will list project settings, provided a project is open; otherwise, it lists user-level settings.","setm#setm":"This command lists the specified settings.\nsetl [-pull] [-push] [-c] \nThis command moves settings from the user setting file to the current project file (-pull) or vice versa (push). The additional -c option copies the settings instead of moving them.\nNote: You can use either -pull or push. This command works only when a Klive project is open in the IDE.","show-disassembly#show-disassembly":"Use this command to display the machine code disassembly view.\nshow-disassembly\nAvailable aliases: shdis","show-memory#show-memory":"Use this command to display the memory contents view.\nshow-memory\nAvailable aliases: shmem","zxb-reset#zxb-reset":"Use this command to set ZXBASIC integration.\nzxb-reset <Full ZXBC executable path> [<python3 path>] [<start of machine code>]\nAvailable aliases: zxbrProvide the full executable path of the ZXBC compiler. Optionally, you can provide the path to the Python3 executable and the start of the machine code. See the ZXBASIC integration article for more information."}},"/getting-started/creating-project":{"title":"Creating a Klive Project","data":{"":"The IDE supports developing applications with a Klive project. With the File | Open folder command, you can open the contents of a particular folder and display it. The IDE considers folders with a well-formed klive.project file within them a Klive project.\nNote: In Klive v0.32.0, a new file, build.ksx, was introduced to allow build process customization. At the end of this article, you will find a section about updating your old Klive projects to leverage the new build system.","the-new-project-dialog#The New Project Dialog":"With the File | New project menu command, you can create a new Klive project:\nYou can select the machine type to use in the project (you can change it any time when the project is open).\nThe IDE offers you a few project templates depending on the machine type.\nYou can specify a root folder for your project directory. The new project will be a subfolder of the root. If you leave it empty, the new project goes into your user home's KliveProjects folder.\nThe project requires a name (MyFirstKliveProject in the figure above).\nWhen you click Create, the IDE creates the new project folder and opens it.","the-project-structure#The Project Structure":"A Klive project is a folder with a klive.project file in it. The file is a JSON file that describes the project's properties. The IDE creates the following structure for a new project:\nThe little home icon to the left of the root folder name (MyFirstKliveProject) indicates that the open folder is a Klive project. The last two files contain essential information related to the current project.\nklive.project is the file that stores project settings, including the machine type, IDE options, breakpoints, etc. Klive IDE does not allow editing it in its code editor.\nbuild.tsx is a script file that executes within the IDE. It contains functions representing build commands.\nBy changing the functions' body, you can customize the build (and create new build-related commands).When you open a folder that is not a Klive project (does not have a valid klive.project file), you cannot see the home icon:","the-build-root#The Build Root":"When you develop your code, you may work with multiple files â€” Klive needs to know the main file to compile it to machine code. The build root designates this main file. When you create a new project, Klive automatically assigns a file as the build root. In the Explorer, the \"combine\" icon to the right of the file name indicates this:\nYou can change the build root any time by right-clicking on a file and selecting the Promote to Build Root command.\nNote: The Promote to Build Root command is available only for particular file types Klive supports.","build-root-commands#Build Root commands":"When you select the build root in the Explorer, the content of the file opens in the code editor, and it displays four icons at the right side of the document tab bar:\nEach of these icons carries out a particular operation:\nIcon\tOperation\t\tThis command compiles the project using the build root file as the main file. This operation lets you check whether your code is free from compilation errors.\t\tThis command compiles the project. If the compilation is successful, it immediately injects the binary code into the memory of the paused machine. After the operation, you can resume the machine and execute the code (for example, with the RANDOMIZE USR(<address>) command).\t\tWith this command, you can start the compiled code.\t\tWith this command, you can start the compiled code in debug mode.\t\nWhen you start the code, Klive executes several steps to ensure a one-click user experience to run or debug the code:\nThe IDE compiles the code. If the compilation fails, no program is started.\nThe IDE restarts the current machine on successful compilation and runs while its OS reaches the main execution cycle. At this point, the IDE may emulate keystrokes to lead the OS to a point where code execution is safe.\nKlive pauses the machine and injects the code into the memory.\nKlive sets the Program Counter (PC) register to the entry point of the injected code and resumes the machine.\nThe injected code runs.","the-project-file#The Project File":"The klive.project file encapsulates information about the current project, including the machine type, UI settings, breakpoint, project state, and many others. While you work with the project, the IDE may update this file.The project file uses JSON format. When you click it in the Explorer, you can look at its content within the code editor. However, the IDE considers this file read-only; thus, it does not allow you to edit it directly. The little shield icon to the right of the filename indicates this read-only state.\nNote: Though you cannot edit this file with the IDE, you can modify it outside. Such modifications may lead to the loss of the project file if the IDE cannot parse klive.project while opening the project folder. If you ever decide to modify klive.project manually, make sure that particular project is not open in the IDE.","updating-old-projects#Updating Old Projects":"If you created your Klive project before v0.32.0, you might have a project without a build.ksx file. After v0.4.0, these projects will not compile, inject, or run your code, as it needs the build.ksx file. Follow these steps to fix the issue:\nOpen your project in Klive.\nWith the New file context menu, add a new file to your project root folder. (It must be the same level as the klive.project file.)\nType the following code into the build.ksx file:\nexport function buildCode() {\n  $command(\"klive.compile\")\n}\nexport function injectCode() {\n  $command(\"klive.inject\")\n}\nexport function runCode() {\n  $command(\"klive.run\")\n}\nexport function debugCode() {\n  $command(\"klive.debug\")\n}\nexport function exportCode() {\n  $command(\"display-dialog export\")\n}\nClose the project.\nOpen the project again; Klive recognizes the build.ksx file and prepares the build functions accordingly.\nNow, you should be able to compile, inject, and run your code."}},"/getting-started/first-run":{"title":"Running Klive","data":{"":"The first time you start Klive, it displays the Emulator window. You can recognize it from the dark grey box representing a turned-off machine.Klive stores your last selected machine type and a few other settings when you close the app and reloads them automatically the next time you start Klive again.Klive has two separate windows; however, the first time you start it, the app shows only the Emulator window. Select the View | Show IDE menu command and Klive displays the IDE window:When you close the Emulator window, it automatically closes the IDE window, too. However, closing the IDE window keeps the Emulator window open. You can quit the Klive application by closing the Emulator window or selecting File | Exit on Windows or Klive | Quit klive-emu on Mac.\nNote: Klive saves the window positions when exiting the app. If you use multiple monitors, the windows will be restored according to their last display the next time you start Klive.","controlling-the-emulator#Controlling the Emulator":"You can start the emulated machine (ZX Spectrum 48K, by default) in several ways:\nPressing the F5 key.\nUsing the Machine | Start menu command\nClicking the Play toolbar button (the leftmost green button of the Emulator's toolbar)\nNote: You can also start the machine with the em-start (or :s) interactive command within the IDE.\nYou can control the running machine with other commands:\nPause: You can suspend running the machine with the Shift+F5 key, the Pause icon in the toolbar, or the Machine | Pause menu. Later, you can restore running the machine.\nStop: When turning the emulated machine off, use the F4 key, the Stop icon in the toolbar, or the Machine | Stop menu command. Though you can view the state of the stopped machine, you cannot continue running it.\nRestart: You can stop and immediately start the machine again with the Shift+F4 key. The same action is available with the Restart toolbar icon and the Machine | Restart menu.","debug-mode#Debug Mode":"The emulator supports running in debug mode. In this mode, the running machine will stop at designated breakpoints, allowing you to examine the current state.You can turn the machine on in debug mode with the Ctrl+F5 key, using the Machine | Start with Debugging menu, or selecting the \"Start with Debugging\" option from the toolbar's drop-down and pressing the play button.When you suspend (pause) the machine, you can continue running it in debug mode with Ctrl+F5. Also, while the machine is paused, you can move it into debug mode with any of these debugger commands:\nStep Into. This command executes the next Z80 instruction and pauses the machine again. Use the F10 key, the Machine | Step Into command, or the Step Into toolbar key.\nStep Over. This command executes the next Z80 instruction and pauses the machine again. Suppose the instruction is a subroutine call, an RST call, or a block operation (e.g., LDIR). In that case, the entire instruction is executed, and the machine pauses again at the next instruction following the call or the block operation. Use the F11 key, the Machine | Step Over command, or the Step Over toolbar key.\nStep Out. This command executes all Z80 instructions to the next return instruction and suspends running again at the return point. Use the Shift+F11 key, the Machine | Step Over command, or the Step Over toolbar key.\nNote: The Step Out command may not work in every context. There are Z80 programs that do not use the RET statement (or its conditional equivalents) but manipulate the stack and use indirect jump statements. The Step Out command cannot work with such constructs.","changing-the-view#Changing the View":"In the View menu, you find several commands that allow changing  the view of the current window (Emulator or IDE):\nActual Size: Sets the view size to Normal (100%) according to the operating system on which you run Klive.\nZoom In: Enlarges the screen (including all text and graphics).\nZoom Out: Makes text and graphics smaller.\nToggle Full Screen: Turns on and off full-screen mode.\nNote: While the Toggle Full Screen command handles the Emulator and IDE windows independently, other commands affect both."}},"/getting-started/installation":{"title":"Installing Klive","data":{"":"Visit the project release page to get the install kits for Klive. You find the latest release at the top of the page. When you expand the Assets tab, it will list five files, including the three installation kits:\nKliveIdeSetup-{version}-{arch}.AppImage: The Linux AppImage format to install Klive IDE on Linux without requiring an admin privilege to run\nKliveIdeSetup-{version}-{arch}.exe: Self-extracting executable to install Klive IDE on Windows x64\nKliveIdeSetup-{version}-{arch}.pkg: The standard PKG format to install Klive IDE on MacOS\n{version} is a placeholder for the version number of a particular release in the filename.\n{arch} is a placeholder for the architecture of the target platform. It can be x64 or arm64.\nNote: Windows currently supports only the x64 architecture.\nDownload the file according to the operating system and architecture to use, and follow the sections of this article.","macos-installation#MacOS Installation":"Open the downloaded .pkg file. As the file comes from an untrusted source, the OS cannot install it directly. Click the OK button to close the message.\nNow, open the System Settings panel and navigate the Privacy & Security tab. As you scroll down, you can see the message with the blocked filename and the Open Anyway button. Click the button to sign that you intend to run the install kit.\nOpen the .pkg file again and select the Open button in the security dialog on the screen.\nNote: The OS may ask for your password to confirm the installation.\nClick Open to allow the installer to run. Follow the screenshots (use Continue) to complete the installation.\nNote: The installer will create a Klive IDE folder in the Applications folder and copy the required files into it. It will also create a shortcut in the Launchpad. When you complete the installation, MacOS may ask you for access to your Downloads folder to recycle the install set optionally.\nAfter the successful installation, you can find Klive IDE in your Applications folder.","windows-installation#Windows Installation":"The setup file is a self-extracting executable. Open it, and it will automatically extract itself and copy the executable files into the Programs (within your user home'sAppData/Local/Programs/klive-ide) directory.The setup kit will start Klive IDE after completion. Later, you can start Klive IDE again:Use the search in the Windows taskbar and type \"Klive\". The newly installed app shows up in the search results:\nClick on Klive IDE to start it.\nNote: When Klive IDE is selected in the search result list, the right pane shows the Pin to taskbar command. Use this to add the IDE to the taskbar; later, you can run it with a single click on the Klive IDE icon.","linux-installation#Linux Installation":"The Linux install kit is an .AppImage file. You may need to download and install FUSE on your machine to use it. For example, on Ubuntu (where FUSE is not installed by default), you can install it:\nsudo apt-get install fuse libfuse2\nCopy the .AppImage file into the folder from which you intend to use it. Make it executable with this command line:\nchmod +x KliveIdeSetup-{version}-{arch}.AppImage\nAlternatively, you can right-click on the file in the file manager and select the Properties command. In the Permissions tab, check the Allow executing file as program checkbox:\nNow, you can run Klive IDE by double-clicking the setup kit's icon or using the Run command from its context menu."}},"/getting-started/keyboard":{"title":"Using the Keyboard","data":{"":"You can use the computer's physical keyboard or a virtual keyboard to emulate keystrokes. To let the Emulator process the computer's keyboard, the Emulator should have the focus. When you change the current window to the Emulator with your machine's keys or click it with the mouse, it is ready to receive keystrokes.Of course, you should start the machine and wait while it reaches its main execution cycles and starts watching for keys.","using-the-virtual-keyboard#Using the Virtual Keyboard":"If you do not find it easy to use the computer's physical keyboard, you can use the virtual keyboard. You can display (or hide) it with one of these actions:\nClick the View | Show the Virtual Keyboard menu command while in the Emulator window\nClick the Keyboard icon in the Emulator's toolbar\nWhen the keyboard is to show, Klive displays it according to the selected machine's type. These figures show the ZX Spectrum 48K keyboard and the ZX Spectrum 128L/+2E/+3E keyboard.\nNote: Klive has custom keyboards for the Cambridge Z88 and the ZX Spectrum Next computers, too.\nTo press a key, move the mouse over the particular virtual key and click it. If you keep the mouse button down, it's just like keeping the button pressed. Releasing the mouse button behaves as you released the real key.When you move the button slowly over a particular key, it will highlight the part of the button with the symbol shift-related and extended mode-related keys. When you click the mouse, it will automatically \"press\" the symbol shift or extended mode keys.You can use both the left and right mouse buttons. However, when using the right mouse button with normal buttons, the key behaves as if you pressed the CAPS SHIFT button simultaneously.This table shows a few examples:\nExample\tDescription\t\tThe click will display INPUT (i) when you use the left mouse button or INPUT (I) with the right mouse button, depending on the current ZX Spectrum cursor mode.\t\tThe click will result in AT regardless of which mouse button you click.\t\tThe click will show CODE regardless of which mouse button you click..\t\tThe click will display IN regardless of which mouse button you click.\t\tThe click will display a glyph with its top-left corner set if you click the left mouse button and the inverse of that glyph when you use the right mouse button.","resizing-the-virtual-keyboard#Resizing the Virtual Keyboard":"When you move the mouse to the top border of the virtual keyboard, a sizing splitter bar appears:\nHold down the mouse key while over the splitter, and move it. As you move, Klive changes the keyboard size and resizes the emulator display accordingly:\nWhen you reach the desired size, release the mouse button.","known-issues-with-the-virtual-keyboard#Known Issues with the Virtual Keyboard":"Klive uses some cheats with the glyphs over the numeric buttons. It emulates that you press the GRAPHICS button to turn on the graphics mode, then emulates the keypress, after that releases the key, and then emulates GRAPHICS again. While keeping the key pressed (the mouse button is held down) works for other keys, this behavior is ignored for glyphs.If you click a glyph button several times repeatedly, the ZX Spectrum OS may not process the emulation of GRAPHICS quickly enough, and thus, the editor does not get out of the graphics mode.\nNote: Sorry for that; it is a kind of issue that is hard to manage. I do not intend to find a fix for it. Please be patient and type a bit slower when you're about to use glyphs."}},"/getting-started/save-programs":{"title":"Saving Files","data":{"":"When you issue a SAVE operation that targets the tape (with ZX Spectrum +3E, you can save the code to disks), Klive saves the code into a .tzx file.\nIf a Klive project is open in the IDE, the file goes into the SavedFiles folder within the open project folder. The Explorer refreshes its view accordingly.\nOtherwise, Klive saves these files into your home directory's Klive/SavedFiles folder.\nNote: As of now, you cannot change this default location. However, in the future, Klive will have a setting to define another folder for saved files according to your preference.\nYou can move the saved files to any other location. Using the Machine | Set Tape File command, you can mount that file to load later."}},"/getting-started/tapes":{"title":"Loading from Tape","data":{"":"Klive can emulate playing back tape files with .tap and .tzx extensions. Before utilizing them with the LOAD Basic command, select them with the Machine | Select Tape File function. This command opens a file selection dialog where you can select a .tap or .tzx file. You can select files with other extensions. In that case, the Emulator tries to read them as tape files, trying to parse them.On successful read, you can issue a LOAD Basic command (or use the Tape Loader from the startup menu of ZX Spectrum 128/+2E/+3E). The running LOAD command will playback the selected file.\nNote: You can change the tape file any time, even when the machine is stopped, paused, or running. The effect of such a change is similar to ejecting a tape from a physical tape player and inserting a new one.","normal-and-fast-load#Normal and Fast Load":"Loading ZX Spectrum programs and tapes may take a long time, especially for large files. Besides the normal loading mode, Klive supports fast load, which reads the program instantly, in a fraction of a second.You can turn on or off fast load with the Machine | Fast Load command or by clicking the Fast Load icon (rocket) in the toolbar.You can change the Fast Load mode even while loading a game. However, the change will take effect only when you start loading a program next time.\nNote: By default, fast load is turned on.","revinding-the-tape#Revinding the Tape":"When the loading completes or gets interrupted, the tape position stays as if you stopped the physical tape player. When you issue the LOAD command again, the load operation starts searching the following file header from the position where it has been stopped.You can rewind the tape to its beginning just as you can do it with a physical tape cassette. Click the Rewind icon in the toolbar (the one to the right of the rocket icon) or execute the Machine | Rewind Tape command.\nNote: Klive allows you to examine the contents of a particular tape file. You can learn about it in the IDE documentation.","how-fast-load-works#How Fast Load Works":"The Fast Load mode applies a powerful technique: ROM hooking. While the emulator runs, it observes when the OS reaches a particular entry point of the load subroutine (by examining the value of the PC register) in the ZX Spectrum ROM, including all ZX Spectrum models.When the execution reaches the load routine, the Fast Load mechanism suspends the machine and injects the data from the tape file directly into the memory. While doing this, the algorithm sets the Z80 registers (including the flags) in the same way as the algorithm in the ROM.When the data is loaded, the mechanism sets the current value of the PC register to the exit point of the load routine as if the CPU has executed that and exits the fast mode.If there is some error during the load, the fast load mechanism sets PC to the beginning of the method that reports tape error."}},"/howto/ide-startup":{"title":"IDE Startup Options","data":{"":"Klive displays two separate windows, the Klive Retro-Computer Emulator window, and Klive IDE. This arrangement allows you to use Klive in a multi-monitor environment.When you start Klive the first time after installation, only the emulator window appears. You can display the IDE window with the View | Show IDE menu command. When you close Klive, it saves the arrangements of these windows and restores them when you open the program next time.Also, by default, Klive IDE loads the last project you opened when it starts (provided you used a project in the last session). To turn off this feature, toggle the IDE | IDE Settings | Open the last project at startup option.When you load a project, Klive IDE automatically opens its build root file. You can turn off this feature by toggling the IDE | IDE Settings | Open the build root of the project option."}},"/howto/file-extensions":{"title":"Changing default file extensions","data":{"":"Klive ships with file extensions associated with particular build systems (languages). You can change the default file extensions and use your own in your projects. In this document, you can learn how to do that.The current version of Klive supports these languages; each has an identifier that you will need when changing file extensions:Klive Z80 Assembler: kz80-asmThis language uses the Z80 syntax of Klive's built-in Z80 Assembler. This compiler is associated with the files with the .kz80.asm extension. The built-in assembler generates debugging information, so source code debugging is available.ZX BASIC (Boriel Basic): zxbasYou can install ZX BASIC on your machine and integrate it with Klive. The ZX BASIC compiler is associated with the .zxbas extension. Klive does not support ZX BASIC source code debugging.ZXB Z80 Assembler: zxbasmWhen you install ZX BASIC on your machine, it comes with its assembler. This compiler is associated with the .zxb.asm extension. Klive does not support ZXB Assembler source code debugging.If you want to change the default file extensions to a particular language, you can use the set interactive command to carry out this change.Let's assume you want to change the .z80.asm file extension used by the Klive Z80 Assembler to accept files with .asm and .kasm. You can carry out this change with these steps:\nIssue the following command in the interactive command prompt:\nset languages.kz80-asm \".asm|.kasm\"\nChange the file extension of the previous source code file (with the Rename context menu) to .asm or .kasm, according to your preference.\nClose the project and open it again.\nSet the renamed file as the build root (if not the build root).\nNow, you can use the compile, inject, and run commands.\nNote: In the current Klive release, you must close and reopen the project to let the file association settings work. In the future, Klive will not require this extra step.\nYou should use the set command with these parameters:\nset languages.<language-identifier> \"<file-extension-1>|<file-extension-2>|...|<file-extension-n>\"\nUse the language identifiers described above and the file extensions you want to associate with them. The file extensions must be separated by the | character. Do not forget to start the file extension with a dot.When you open the klive.project file, you can see the effect of the set command:\n{\n  \"settings\": {\n    \"languages\": {\n      \"kz80-asm\": \".asm|.kasm\"\n    }\n  }\n}"}},"/howto/instant-screen":{"title":"Using the Instant Screen","data":{"":"All ZX Spectrum models render the screen simultaneously with the CPU. The screen rendering follows the virtual electron beam (modern LCD and LED displays do not have a physical electron beam). Writing a value to the screen memory or changing some settings will be rendered only when the hardware processes the pixels behind that screen memory value.When you debug your app and modify the screen memory, that modification is not immediately reflected on the emulator screen. When the debugging is paused, screen rendering is paused, too.The Instant Screen feature of Klive allows you to check how the screen looks when the screen rendering does not stop with debugging.You can turn this feature on or off with the highlighted toolbar button:\nWhen the Instant Screen is on, the screen rendering is not paused when the debugging is paused. This way, you can see the screen as it would look if the screen rendering was not paused.\nNote: The Instant Screen is only active when the machine is paused.\nWhile the machine is paused, you can turn on or off the Instant Screen. The turned-off state shows what the real-time screen would look like."}},"/machine-types":{"title":"Machine Types","data":{"":"This document summarizes the machines and models available in Klive IDE.","zx-spectrum-48k#ZX Spectrum 48K":"Machine ID: sp48Available models:\npal: The original ZX Spectrum 48K model with PAL video output.\nntsc: The original ZX Spectrum 48K model with NTSC video output.\npal-16k: The original ZX Spectrum 48K model with PAL video output and 16K RAM.","zx-spectrum-128k#ZX Spectrum 128K":"Machine ID: sp128Available models: Only the original ZX Spectrum 128K model is available.","zx-spectrum-2e3e#ZX Spectrum +2E/+3E":"Machine ID: spp3eAvailable models:\nnofdd: ZX Spectrum +2E (without floppy disk drive).\nfdd1: ZX Spectrum +3E (with a single floppy disk drive).\nfdd2: ZX Spectrum +3E (with two floppy disk drives).","zx-spectrum-next#ZX Spectrum Next":"Machine ID: zxnextAvailable models: Only the original ZX Spectrum Next (KS2) model is available; it is still in development.","cambridge-z88#Cambridge Z88":"Machine ID: z88Available models:\nOZ50: Cambridge Z88 (OZ v5.0 r1f99aaae)\nOZ47: Cambridge Z88 (OZ v4.7)\nOZ40: Cambridge Z88 (OZ v4.0 UK)\nOZ40FI: Cambridge Z88 (OZ v4.01 SE/FI)\nOZ30: Cambridge Z88 (OZ v3.0 UK)\nOZ323IT: Cambridge Z88 (OZ v3.23 IT)\nOZ326FR: Cambridge Z88 (OZ v3.26 FR)\nOZ319ES: Cambridge Z88 (OZ v3.19 ES)\nOZ321DK: Cambridge Z88 (OZ v3.21 DK)\nOZ318DE: Cambridge Z88 (OZ v3.18 DE)"}},"/project-templates":{"title":"Project Templates","data":{"":"TBD"}},"/scripting/overview":{"title":"Overview","data":{"":"Klive IDE has a scripting system with a JavaScript-like syntax. When you create files with the .ksx extension, the IDE considers them script files and allows you to run them.\nNote: The scripting system is new in the IDE and will evolve with every release. Though I strive to keep compatibility with older versions, you may find some breaking changes.\nGet acquainted with the scripting system! Follow these steps to create and run your first script:\nOpen an existing Klive project, or create a new one.\nWith the New file context menu, add a new script file, myScript.ksx, to the project's root.\nAfter you add it, Klive displays the empty file in the code editor:\nType this code into the editor:\nOutput.writeLine(\"Hello from Klive IDE!\");\nThe script window's header has two icons, as the following figure shows. Click the first one (Run this script file) to start the script.\nIt starts the script and displays its output in a new document, the script output window:","running-the-script#Running the Script":"The scripting system uses a compiler to convert the script into an internal format, and then the scripting engine runs the code. The code runs asynchronously, so you can cancel the run even if you create an infinite loop.A script can run in one of these locations:\nThe IDE process. Scripts running here access the IDE infrastructure through built-in objects; they can execute complex tasks (such as building the project) that require accessing the project system.\nThe Emulator process. These scripts can control the emulator and automate it through objects. For example, you can execute the next Z80 instruction, pause, and examine the Z80 register values to search for a particular condition. According to this condition, your script can decide how to go on.\nBy default, the script runs in the IDE process. You can change the host to the emulator by adding the \"emu\" string literal at the top of the script. For example, the following code will run in the emulator:\n\"emu\";\nOutput.writeLine(\"Hello from Klive IDE!\");\nNote: Though the script runs in the emulator, it forwards its output to the IDE. You can display and examine the script output in the IDE window.","script-output#Script Output":"The scripting engine has an output pane in the Tool panel. This pane displays messages related to running scripts, such as starting and completing them. If compiling a script results in an error, the error is displayed here, too:\nEach script has a pane displaying its output. When you start a script, the IDE immediately shows its output pane and refreshes it according to the script's output. If you run a script multiple times, each run has its separate output pane.Let's assume you run this script:\nfor (let i = 0; i < 1000; i++) {\n  Output.writeLine(\"Message item #\" + i);\n  delay(100);\n}\nThe script output refreshes the pane as the for-loop generates new output items. In the header, it displays the number of output lines and the status of the script (Running):\nYou can click the icon buttons in the header to execute a particular task. These icons from the left to right provide these functions:\nStop. You can cancel a running script. The script's state changes to \"Stopped\".\nOpen Script File. Clicking this button opens the script file in the code editor.\nClear script output. You can immediately clear the script's output (even if it is still running).\nCopy to clipboard. The current script output (plain text) is copied to the clipboard; you can paste it into other apps.\nTurn on/off autoscrolling. As the script output appends, the pane scrolls automatically to the bottom. You can use this button to turn this behavior on or off.","scripting-history#Scripting History":"The IDE sidebar contains a Scripting tab where you can expand the Scripting History panel to list the scripts run since the IDE started:\nEach item represents a run. The first icon indicates the host (the tool icon represents scripts running in the IDE, and the display icon refers to the emulator-hosted scripts). The second icon tells you the status of a particular script.The script file's name is followed by its running time; the IDE refreshes this information automatically.When you click an item, the IDE opens the related script output."}},"/scripting/syntax":{"title":"Scripting Syntax","data":{"":"The Klive scripting language is a subset of JavaScript. It uses similar expressions and statements, and its evaluation and execution semantics match those of JavaScript.","comments#Comments":"Klive allows you two kinds of comments:\nBlock comments. Any text wrapped between /* and */ is a block comment. Note you cannot nest block comments to each other, and block comments within a string literal are not considered a comment but part of the string.\nEnd-of-line comments. Any text following the // token till the end of the current line is considered a comment.\nExamples:\nconst nums = [ 12, 31, 23, 117 /* , 123 */];\nconst sqrNums = nums.map(n => n * n); // Create the squares of numbers","expressions#Expressions":"Klive scripting expressions follow the syntax of JavaScript expressions. Thus, if you know JavaScript, you can immediately write expressions. The operators and other syntax elements are very close to other \"curly-brace\" programming languages, such as C, C++, Java, and C# (and many others), so you'll get the hang of it in seconds.The JavaScript syntax nature of binding expressions is crucial not just because of the notations. With Klive, you can use all objects available in the global namespace of JavaScript, including the Math object, the fundamental types like Number, String, Date, and many others.You can use these elements in Klive expressions:\nIdentifiers\nLiterals\nNumbers\nStrings\nBoolean values (false and true)\nnull and undefined\nArray literals\nObject literals\nOperators","identifiers#Identifiers":"Klive scripting identifiers may start with one of these characters: $, _,  or any English alphabet letters (from a to z and A to Z). The continuation characters can be of the same set as the start character, and you can also use decimal digits (from 0 to 9). Other characters (such as Unicode letters, symbols, or emojis) are not allowed in identifiers.\nNote: Be aware that Klive uses slightly different identifier syntax than JavaScript.\nHere are a few examples of valid identifiers:\nsaveButton\n$item\n$saveCommand\n_a123","literals#Literals":"You can use the same numbers (integers and floating-point numbers) as in JavaScript, and also the NaN value\n(not-a-number) and Infinity (the result coming from a divide by zero).Array and object literals also allow you the same syntax as in JavaScript. Here are a few samples:\n[1, 2, 3] // An array of three numbers\n[\"Hello\", \"World\", 42, true] // An array of four values\n{a: 1, b: 2, c: 3} // An object with three properties\n{\n  hey: 123,\n  ho: false,\n  hi: 123.e-2,\n  what: NaN,\n  is: [\"this\", \"object-like\"],\n  thing: {\n      that: null,\n      seems: \"completely\",\n      stupid: \"?\"\n  }\n} // A compound object literal\nStrings allow the same characters as JavaScript, including inline Unicode and the following escape characters:\n\\b: Backspace\n\\f: Form Feed\n\\n: New Line\n\\r: Carriage Return\n\\t: Horizontal Tabulator\n\\v: Vertical Tabulator\n\\S: Non-breaking Space\n\\\\: Backslash\n\\': Single quote\n\\\": Double quote\n\\xhh: Hexadecimal character (here, hh represents two hexadecimal digits).\n\\uhhhh: Unicode code point between U+0000 and U+FFFF (here hhhh represents four hexadecimal digits).\n\\u{hHHHHH}: Unicode code point between U+0000 and U+10FFFF (here hHHHHH represents one to six hexadecimal\ndigits).","operators#Operators":"You can use most of the JavaScript operators in Klive scripts. Here, you can read the list of them; the operators are grouped according to their precedence, starting with the highest one:Precedence group #1\nGrouping: ( â€¦ ), for example (6 * 7)\nPrecedence group #2\nMember access:  â€¦ . â€¦, for example a.b\nComputed member access: â€¦ [â€¦], for example a[b]\nFunction call: â€¦ (â€¦), for example addItem(a, b, c)\nOptional chaining: â€¦ ?. â€¦, for example: prop?.value\nPrecedence group #3\nPostfix increment: â€¦ ++, for example: counter++\nPostfix decrement: â€¦ --, for example: counter--\nPrecedence group #4\nLogical NOT: ! â€¦, for example !value\nBitwise NOT: ~ â€¦, for example ~bits\nUnary plus: + â€¦, for example +b\nUnary negation: - â€¦, for example -b\nPrefix increment: ++ â€¦, for example: ++counter\nPrefix decrement: -- â€¦, for example: --counter\nType query: typeof â€¦, for example typeof myValue\nProperty delete: delete â€¦, for example delete a.prop\nPrecedence group #5\nExponentiation: â€¦ ** â€¦, for example, 2 ** 3. (This operator has a right-to-left associativity.)\nPrecedence group #6\nMultiplication: â€¦ * â€¦, for example a * 12\nDivision: â€¦ / â€¦, for example a / b,\nRemainder: â€¦ % â€¦ for example value % 2\nPrecedence group #7\nAddition: â€¦ + â€¦, for example, a + b\nSubtraction: â€¦ - â€¦, for example: present - absent\nPrecedence group #8\nBitwise left shift: â€¦ << â€¦, for example value << 3\nBitwise right shift: â€¦ >> â€¦, for example other >> 2\nBitwise unsigned shift: â€¦ >>> â€¦, for example value >>> b\nPrecedence group #9\nLess than: â€¦ < â€¦, for example a < b\nLess than or equal: â€¦ <= â€¦, for example a <= b\nGreater than: â€¦ > â€¦, for example a > b\nGreater than or equal: â€¦ >= â€¦, for example a >= b\nInclusion test: â€¦ in â€¦, for example a in [1, 2, 3]\nPrecedence group #10\nEquality: â€¦ == â€¦, for example \"2\" == 2\nInequality: â€¦ != â€¦, for example \"2\" != a\nStrict equality: â€¦ === â€¦, for example \"2\" === 2\nInequality: â€¦ !== â€¦, for example \"2\" !== a\nPrecedence group #11\nBitwise AND: â€¦ & â€¦, for example apple & pear\nPrecedence group #12\nBitwise XOR: â€¦ ^ â€¦, for example sprite ^ mask\nPrecedence group #13\nBitwise OR: â€¦ | â€¦, for example walnut | peanut\nPrecedence group #14\nLogical AND: â€¦ && â€¦, for example x && y\nPrecedence group #15\nLogical OR: â€¦ || â€¦, for example me || you\nNullish coalescing operator: â€¦ ?? â€¦, for example value ?? \"\"\nPrecedence group #16\nAssignment: â€¦ = â€¦, for example, i = 2\nAddition assignment: â€¦ += â€¦, for example, i += 1\nSubtraction assignment: â€¦ -= â€¦, for example, i -= 1\nExponentiation assignment: â€¦ **= â€¦, for example, i **= 3\nMultiplication assignment: â€¦ *= â€¦, for example, i *= 2\nDivision assignment: â€¦ /= â€¦, for example, i /= 4\nRemainder assignment: â€¦ *= â€¦, for example, i %= 16\nBitwise left shift assignment: â€¦ <<= â€¦, for example, i <<= 1\nBitwise right shift assignment: â€¦ >>= â€¦, for example, i >>= 4\nBitwise unsigned right shift assignment: â€¦ >>>= â€¦, for example, i >>>= 8\nConditional (ternary) operator: â€¦ ? â€¦ : â€¦, for example a % 2 ? \"off\" : \"on\"\nArrow function: â€¦ => â€¦, for example, (a, b) => a * b\nSpread: ... â€¦, for example, ... [1, 2, 3]\nPrecedence group #17\nComma/Sequence: â€¦ , â€¦, for example: a, b, c, other\nNote that you cannot use these JavaScript operators with binding expressions: new, void, await, instanceof, assigment operators (none\nof them), yield, and yield*.","arrow-functions#Arrow Functions":"Klive allows you to define arrow functions. Though you can define arrow functions in attribute or property values. Arrow functions have the same syntax as in JavaScript. Here are a few examples:\n() => Math.sqrt(Math.PI);\nThis arrow function has no arguments. It retrieves the square root of PI.\n(a, b) => Math.sqrt(a ** 2 + b ** 2);\nThis arrow function calculates the hypotenuse of a right-angled triangle from its leg dimensions. It has two arguments, a and b, the leg dimensions.\n(n) => {\n  let sum = 0;\n  for (let i = 1; i < n; i++) sum += i;\n  return sum;\n}\nThis arrow function uses statements to calculate the sum of numbers from one to the given n. As it has a body (and not just a single expression), it uses the return statement to retrieve the result.Arrow function arguments support the destructure pattern. You can learn more about them here.Here is an example:\n({x, y}) => x ** 2 + y ** 2;\nAssuming you assigned the arrow function to the myCalc variable, this is how you can invoke it from an event handler:\nconst coords = { x: 12, y: -23 };\n// ...\nmyCalc(coords);","statements#Statements":"Klive scripting provides several statements to express programming logic. Most of these statements have the same semantics as their counterpart in JavaScript.\nNote: The statements can be optionally closed with a semicolon. There are a few contexts where the closing semicolons are required to avoid ambiguity. It is a suggested practice to conclude statements with a semicolon always.","variable-declarations#Variable declarations":"You can use the let and const statements to declare variables and optionally set their initial values. While an initial value is optional for the let statement, it is required for const. You can change the values of variables declared with let. However, the value of const variables can be set only once, at their initialization. The engine raises an error if you try to modify the value of a variable.Here are a few examples:\nlet x; // No initial value\nlet y = 0, z; // Multiple declarations\nlet sum = 0; // Initialize sum to zero\nconst factor = 1.5; // Factor cannot be changed later\nNote: Klive scripting does not support the var keyword; it allows only let and const.","destructuring#Destructuring":"You can use destructure operators with variable expressions. Klive supports a similar syntax to JavaScript; however, it does not support extracting rest values and providing default values.Examples:\nconst {a, b} = someObject;\n// const a = someObject.a, b = someObject.b\nconst {a, b, other: { c, d }} = someObject;\n// const a = someObject.a, b = someObject.b, c = someObject.other.c, d = someObject.other.d\nconst {a, b:myB} = someObject;\n// const a = someObject.a, myB = someObject.b\nlet {a, b, other: { c:myC }} = someObject;\n// let a = someObject.a, b = someObject.b, myC = someObject.other.c\nconst [a, b] = someArray;\n// const a = someArray[0], b = someArray[1}\nconst [a, b,, c] = someArray;\n// const a = someArray[0], b = someArray[1}, c = someArray[3]\nlet [a,,, {b:myB, c}] = someArray;\n// let a = someArray[0], myB = someArray[3].b, c = someArray[3].c","function-declarations#Function Declarations":"You can define functions in Klive scripting. The syntax is similar to JavaScript. You can define functions with or without parameters, and you can use the return statement to return a value from the function.Here are a few examples:\nfunction add(a, b) {\n  return a + b;\n}\nfunction greet(name) {\n  return \"Hello, \" + name + \"!\";\n}\nNote: Klive does support declaring functions within functions.","empty-statement#Empty Statement":"An empty statement is used to provide no statement, although the JavaScript syntax would expect one. The script indicates it with a semicolon (;).\nHint: It is a good idea to comment on the intentional use of the empty statement, as it is not apparent to distinguish from a usual semicolon.\nExample:\n// This for loop has no iteration body\nfor (let i = 0; i < 10; i++); // The closing \";\" indicates the empty statement","block-statement#Block Statement":"You can group multiple statements into a single block statement, wrapping them between { and }. For example, you can put multiple individual statements into the body of a for-loop:\nlet sum = 0;\nfor (let i = 0; i < 10; i++) {\n  sum += i;\n  console.log(\"Current sum is\", sum);\n}\nBlock statements have their separate identifier scope. Variables declared within them will hide external variables with the same name. For example, in the following sample, the log output will show 42 in the first line and 1234 in the second, as the declaration of myNumber in the block statement hides myNumber declared outside of the block statement:\nlet myNumber = 1234;\n{\n  let myNumber = 42;\n  console.log(myNumber); \n}\nconsole.log(myNumber);\nNote: You do not need to put a closing semicolon after a block statement.","expression-statement#Expression Statement":"When you write an expression in the context of other statements, Klive represents that expression as an expression statement. For example, here, the highlighted line are expression statements:\nlet sum = 0;\nfor (let i = 0; i < 10; i++) {\n  sum += i;\n  console.log(\"Current sum is\", sum);\n  123 + 456;\n}\nNote: Though there is no use in evaluating the value of 123 + 456 expression statement, the engine does that (in every iteration) and omits the result.","the-ifelse-statement#The if...else Statement":"The if...else statement executes a statement if a specified condition is truthy. If the condition is falsy, another statement in the optional else clause will be executed.\nNote: A truthy value is a value that is considered true when encountered in a Boolean context: All values are truthy unless they are defined as falsy. That is, all values are truthy except false, 0, -0, \"\", null, undefined, and NaN.\nHere are a few examples:\n// Example #1\nif (a > 3) doThis();\n// Example #2\nif (a > 3) doThis(); else doThat();\n// Example #3\nif (a > 3) {\n  doThisFirst();\n  andThen()\n}\nelse doThat();\nNote: Example #2 shows that you need a closing semicolon before else, as the consequent (\"then\") branch of the if...else statement is a single (non-block) statement.","the-while-statement#The while Statement":"The while statement creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.Here are a few examples:\n// Example #1\nlet sum = 0;\nlet counter = 1;\nwhile (counter <= 10) sum += counter++; \n// Example #2\nlet sum = 0;\nlet counter = 1;\nwhile (counter <= 10) {\n  sum += counter;\n  counter++;\n}","the-dowhile-statement#The do...while Statement":"The do...while statement creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.\n// Example #1\nlet sum = 0;\nlet counter = 1;\ndo sum += counter++; while (counter <= 10)  \n// Example #2\nlet sum = 0;\nlet counter = 1;\ndo {\n  sum += counter;\n  counter++;\n} while (counter <= 10)","the-for-statement#The for Statement":"The for statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement) to be executed in the loop.\nInitialization. An expression or variable declaration that is evaluated once before the loop begins. This expression may optionally declare new variables with the let keyword; these variables are local to the loop.\nCondition. An expression to be evaluated before each loop iteration. If this expression evaluates to true, the loop's body is executed. Otherwise, execution exits the loop and goes to the first statement after the loop construct. This conditional test is optional. If omitted, the condition always evaluates to true.\nUpdate. An optional expression to be evaluated at the end of each iteration before the next evaluation of the condition.\nExamples:\n// Example #1\nlet sum = 0;\nfor (let i = 0; i < 10; i++) {\n  sum +=i;  \n}\n// Example #2\nlet sum = 0;\nlet i;\nfor (i = 0; i < 10; i++) {\n  sum += i;  \n}\nYou can declare multiple variables in the loop initialization and add multiple update expressions (as a sequence expression):\nlet sum = 0;\nfor (let i = 0, j = 3; i < 10; i++, j += 3) {\n  sum += i + j;  \n}","the-forin-statement#The for...in Statement":"The for...in statement iterates over all enumerable string properties of an object including inherited enumerable properties.\nVariable. This variable receives a string property name on each iteration. It may be either a declaration with const, or let, or a variable name. Variables declared with const or let are local to the for...in loop's scope.\nObject. An object whose enumerable properties are iterated over.\nExamples:\nconst obj = { a: 12, b: 34, c: \"Hello\" }\nfor (const key in obj) {\n  console.log(obj[key]);\n}\nThis code snippet will display this output:\n12\n34\nHello","the-forof-statement#The for...of Statement":"The for...of statement executes a loop that operates on a sequence of values sourced from an iterable object (such as Array, String, Map, Set, and others.\nVariable. This variable receives a value from the sequence on each iteration. It may be either a declaration with const, or let, or a variable name. Variables declared with const or let are local to the for...in loop's scope.\nObject. An iterable object. The source of the sequence of values on which the loop operates.\nExamples:\nconst values = [1, 2, 3, 5, 8, 13, 21]\nfor (const value of values) {\n  console.log(value);  \n}","the-break-statement#The break Statement":"The break statement terminates the current loop or switch statement and transfers program control to the statement following the terminated statement.Examples:\n// Sum up numbers from 1 to 10\nlet sum = 0;\nlet counter = 1;\nwhile (true) {\n  if (counter > 10) break;\n  sum += counter++;\n}\n// Dispatch options\nswitch (option) {\n  case 0:\n    doThis();\n    break;\n  case 1:\n    doThat();\n    break;\n  case 2:\n    doSpecial();\n    break;\n  default:\n    doExceptional();  \n    break;  \n}","the-continue-statement#The continue Statement":"The continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.In contrast to the break statement, continue does not terminate the execution of the loop entirely, but instead:\nIn a while or do...while loop, it jumps back to the condition.\nIn a for loop, it jumps to the update expression.\nIn a for...in, or for...of loop, it jumps to the next iteration.\nExample:\n  \nlet sum = 0;\nfor (let i = 1; i <= 100; i++) {\n  if (i % 3 === 2) continue;\n  sum += i;\n  console.log(\"Current sum\", sum);\n}","the-return-statement#The return Statement":"The return statement ends function execution and specifies a value to be returned to the function caller. If the value is omitted, undefined is returned.Examples:\n(n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) sum += i;\n  return sum;\n}\n(n) => {\n  if (n % 3 === 2) return;\n  console.log(\"Remainder of \" + n + \" is not equal to 2\");\n}","the-switch-statement#The switch Statement":"The switch statement evaluates an expression, matching the expression's value against a series of case clauses, and executes statements after the first case clause with a matching value until a break statement is encountered. The default clause of a switch statement will be executed if no case matches the expression's value.If the control flow of the executing case clause does not reach a break statement concluding the particular case, the execution continues with the subsequent case clause until there remains any.Examples:\n// Dispatch options\nswitch (option) {\n  case 0:\n    doThis();\n    break;\n  case 1:\n    doThat();\n    break;\n  case 2:\n    doSpecial();\n    break;\n  default:\n    doExceptional();  \n    break;  \n}\n// Case 0 flows to case 1\nswitch (option) {\n  case 0:\n    doThis();\n  case 1:\n    doThat();\n    break;\n  case 2:\n    doSpecial();\n    break;\n}\n// Multiple cases with the same execution\nswitch (option) {\n  case 0:\n  case 3:\n  case 6:\n    doThis();\n    break;\n  case 1:\n  case 2:\n  case 5:\n    doThat();\n    break;\n  default:\n    doExceptional();  \n    break;  \n}","the-throw-statement#The throw Statement":"The throw statement throws a user-defined error value. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the code will terminate.The throw keyword can be followed by any kind of expression.Examples:\n(values) => {\n  if (!values.every(v => typeof v === \"number\")) {\n    throw \"Can only add numbers\";\n  }\n  return values.reduce((a, b) => a + b);\n}\nconst handler = (err, data) => {\n  if (err) {\n    throw err;\n  }\n  console.log(data);\n}","the-trycatch-statement#The try...catch Statement":"The try...catch statement comprises a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code in the finally block will always be executed before the control flow exits the entire construct.The catch block can have an optional identifier to hold the caught error for the associated catch block. If the catch block does not use the exception's value, you can omit the identifier.Examples:Unconditional error\ntry {\n  throw \"myError\";\n} catch (e) {\n  // Log the error\n  console.log(e);\n}\nLog:\nmyError\nTesting the error condition\ntry {\n  readData(); // may throw three types of exceptions\n} catch (e) {\n  if (e === \"DataReadError\") {\n    // Statements to handle data read errors\n  } else if (typeof e === \"number\") {\n    // Statements to handle a particular numeric error code\n  } else if (e.errorType) {\n    // Statements to handle some other error\n  } else {\n    // Statements to handle any unspecified exceptions\n    console.log(e);\n  }\n}\nNested try blocks\ntry {\n  try {\n    throw \"Something strange\";\n  } catch (e) {\n    console.error(\"inner\", e);\n    throw e;\n  } finally {\n    console.log(\"finally\");\n  }\n} catch (e) {\n  console.error(\"outer\", e);\n}\nLog:\ninner Something strange\nfinally\nouter Something strange\nReturning from finally\n(() => {\n  try {\n    try {\n      throw \"weird\";\n    } catch (e) {\n      console.error(\"inner\", e);\n      throw e;\n    } finally {\n      console.log(\"finally\");\n      return;\n    }\n  } catch (e) {\n    console.error(\"outer\", e);\n  }\n})();\nLog:\ninner weird\nfinally"}},"/working-with-ide/basic":{"title":"The BASIC Listing","data":{"":"One of Klive IDE's unique features is that it can list the BASIC program from within the running machine's memory. You can access this view with theÂ IDE | Show BASIC ListingÂ menu command:\nThe toolbar of the view contains these controls from left to right:\nRefresh button. You can refresh the BASIC list view.\nCopy to Clipboard. This button copies the current BASIC list to the clipboard.\nAuto Refresh. With this switch turned on (on by default), the IDE automatically reads and displays the current BASIC listing from the computer (even during program loading).\nShow non-printable. When this switch is turned on (off by default), the non-printable characters are displayed with their two-digit hexadecimal code with a $ prefix and shaded background.\nUse ZX Spectrum font: This switch allows you to use the ZX Spectrum font instead of Klive's default monospace font.\nIf the BASIC listing is not available (or it is corrupted), this view may display one of these messages:\nMachine OS has not been initialized yet: This message appears while the machine's operating system is booting. It disappears when the machine reaches its main execution cycle.\nBASIC program area is empty: There is no BASIC program to list.\nBASIC code corrupted or partially loaded: When the BASIC program area is corrupted (some unexpected data is found) or the program is being loaded, the view displays this message at the location of the error."}},"/working-with-ide/breakpoints":{"title":"The Breakpoints View","data":{"":"With this view, you can overview and manage the breakpoints used for debugging. You can find this view in the Debug activity tag with theÂ BreakPoints header:\nThis view displays all breakpoints you created with interactive commands or in the source code. Each line represents a particular breakpoint with this information:\nA filled circle representing the status of a breakpoint:\ncyan: a breakpoint created with an interactive command\nred: a breakpoint created in the source code\ngray: a disabled breakpoint\nAn icon representing the breakpoint type\nThe breakpoint's address or source code location\nOther information (such as the disassembly at the location)","manipulating-breakpoints#Manipulating Breakpoints":"When you hover the mouse over the first two icons, they display additional information:\nClicking the left mouse button removes the breakpoint. With the right mouse button, you can toggle between the disabled or enabled state of the breakpoint. When a breakpoint is disabled, the debugger does not stop when reaching it.","resolved-source-code-breakpoints#Resolved Source Code Breakpoints":"Source code breakpoints are resolved to a CPU address after compilation, and this address is displayed with the breakpoint. The following figure shows that the last two source code breakpoints display their resolved CPU address after the compilation.","breakpoint-types#Breakpoint Types":"The second icon of the breakpoint item displays its type. There are five types of breakpoints (depending on the operation triggering the machine to pause), as the following figure shows:\nThese are the available breakpoint types (from top to bottom in the figure):\nI/O read. This breakpoint is triggered when a particular I/O port has been read. The displayed address is the 16-bit I/O port address.\nI/O write. This breakpoint is triggered when a particular I/O port has been written. The displayed address is the 16-bit I/O port address.\nExecution. This breakpoint is triggered when the PC register reaches the specified address.\nMemory read. This breakpoint is triggered when a particular 16-bit memory address (including instruction fetches) has been read.\nMemory write. This breakpoint is triggered when a particular 16-bit memory address has been written."}},"/working-with-ide/build-system":{"title":"The Build System","data":{"":"Klive IDE has a scripting system with a JavaScript-like syntax. When you create files with the .ksx extension, the IDE considers them script files and allows you to run them.TBD"}},"/working-with-ide/commands":{"title":"Interactive Commands","data":{"":"Klive provides an interactive command panel for executing commands such as defining breakpoints, starting, pausing, and stopping the machine, compiling and exporting code, and many others.\nThe commands panel is displayed in the Tools window, which you can open with the View | Show Tools Panel command.The bottom area of the panel allows you to type a particular command. After pressing Enter, the IDE executes the command. You can type the \"?\" command (click Enter) to display the list of available commands. You can also type some search characters after \"?\" to display only matching commands. For example, the \"? bp-\" prompt will display information about breakpoint-related commands (each of them starts with \"bp-\").You can find more information about the available commands in the Commands Reference  section."}},"/working-with-ide/cpu":{"title":"The CPU View","data":{"":"You can find this view in the Debug activity tag with the Z80 CPU header:\nWhen you hover the mouse over the information items, they display a tooltip with numbers in multiple radixes (whenever that has a meaning).You can read this information in this panel:\nZ80 registers: All the standard Z80 registers (moving the mouse over the values will display LSB and MSB separately). The WZ is an internal Z80 register, often called MEMPTR.\nLMR: Last value read from memory\nLMW: Last value written to memory\nIRV: Last value read from an I/O port\nIWV: Last value written to an I/O port\nIM: Current interrupt mode\nSNZ: Is the CPU in snoozed mode (Cambridge Z88 uses this CPU mode)\nIFF1:  Interrupt flip-flop #1\nIFF2:  Interrupt flip-flop #2\nINT: Is the INT signal active?\nHLT: Is the CPU halted?\nCLK: The current clock count since the last machine start\nTSP: T-states elapsed since the last pause. You can use this value to check the number of T-states used between two pauses."}},"/working-with-ide/disassembly":{"title":"The Disassembly View","data":{"":"You can view the Z80 disassembly of the memory with the IDE | Show Z80 Disassembly menu command:\nBy default, when you display the Z80 disassembly, it uses the current value of the PC (Program Counter) register and disassembles up to 1024 bytes of code.Turn off the Follow PC option to disassemble the entire memory (or a selected bank). With this option turned off, models supporting memory paging display a second row of options:","display-options#Display Options":"The Z80 Disassembly View provides a few options to display and navigate the memory contents:\nDecimal: Turns on or off the decimal display (off, by default). When turned off, memory addresses, opcodes, and instructions are displayed with decimal numbers; otherwise, they are hexadecimal.\nRam: This option (on, by default) allows you to disassemble the RAM's contents.\nScreen: This option (off, by default) lets you disassemble the screen memory's ($4000-$5AFF) contents.\nBank: This option (on, by default) allows you to turn the display of bank labels on or off in front of memory addresses. This option is available only for models that support memory paging.\nGo To: Type an address into this box and press Enter to jump to the particular address. If the particular address is not at a disassembled instruction's boundary, it will settle at the next instruction. In decimal mode, you can type decimal addresses; otherwise, use hexadecimal addresses.\nA little icon (up or down arrow) is before the Go To address box. Unless the machine is paused, this icon is disabled. When the machine is in a paused state, clicking the button jumps to the disassembly at the address pointed by the PC. The direction of the arrow indicates where the PC position can be found relative to the current view.","banked-disassembly-views#Banked Disassembly Views":"When your model supports memory paging, a new switch, 64K View, is displayed in the second header row. It is turned on by default, and the current 64K memory (according to the current memory page settings) is displayed. When you turn this option off, you can choose the bank to display (ROM pages or RAM banks, depending on the machine type) from the Select bank dropdown. The Z80 Disassembly View will display only the disassembled contents of that segment, even if that segment is not paged in.The Offset dropdown lets you select a disassembly offset from one of the 8K page boundaries. This selection may help set a disassembly base address to emulate the page's location.","machine-specific-memory-partitions#Machine-Specific Memory Partitions":"","zx-spectrum-48k#ZX Spectrum 48K":"This model supports only the 64K view.","zx-spectrum-128k#ZX Spectrum 128K":"The ROM 0 and ROM 1 segments allow you to access the two ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 or BANK 7 segments.","zx-spectrum-2e-3e#ZX Spectrum +2E, +3E":"The ROM 0... ROM 3 segments allow you to access the four ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 ... BANK 7 segments.","cambridge-z88#Cambridge Z88":"You can access one of the available 256 banks (16K each) by selecting the bank's index from the dropdown.","zx-spectrum-next#ZX Spectrum Next":"The dropdown provides these options to access memory segments:\nIDs from 00 to DF (000 to 224 in decimal view) to select an 8K RAM bank. The view does not support displaying them as 16K banks.\nM0, M1 ... MF: The 16 DivMMC RAM banks (8K each)\nNROM0 ... NROM3: The ROM pages of the ZX Next OS (16K each)\nALTR0, ALTR1: The alternate ROM pages (16K each)\nDivMR: The DivMMC ROM (8K)"}},"/working-with-ide/editing-code":{"title":"Editing code","data":{"":"TBD"}},"/working-with-ide/ide-settings":{"title":"IDE Settings","data":{"":"TBD"}},"/working-with-ide/memory":{"title":"Displaying the Memory Contents","data":{"":"Note: The current Memory View does not allow editing the memory contents.\nYou can view the contents of the memory with the IDE | Show Machine Memory menu command that displays the contents of the full 64K memory addressable by Z80:\nWhile ZX Spectrum 48K does not support paging, other models do. When you use them, you can choose to show only the contents of a particular bank:\nSome models (such as ZX Spectrum Next or Cambridge Z88) offer you many banks to choose from:","display-options#Display Options":"The Memory View provides a few options to display and navigate the memory contents:\nDecimal: Turns on or off the decimal display (off, by default). When turned off, memory addresses and content are displayed with decimal numbers; otherwise, they are hexadecimal.\n2 Columns: Depending on this option, you can display one or two columns in a single row (two columns by default).\nChars: This toggles the display of the character view for a particular memory section (on, by default).\nBank: This option (on, by default) allows you to turn the display of bank labels on or off in front of memory addresses. This option is available only for models that support memory paging.\nGo To: Type an address into this box and press Enter to jump to the particular address. Though memory sections are aligned to 8-byte boundaries when jumping to a new address, the designated address's content flashes for about 3 seconds to let you identify the jump target. In decimal mode, you can type decimal addresses; otherwise, use hexadecimal addresses.","banked-memory-views#Banked Memory Views":"A new switch, 64K View, is displayed in the second header row when your model supports memory paging. It is turned on by default, and the current 64K memory (according to the current memory page settings) is displayed. When you turn this option off, you can choose the bank to display (ROM pages or RAM banks, depending on the machine type) from the Select bank dropdown. The Memory View will display only the contents of that memory even if that segment is not paged in.","machine-specific-memory-partitions#Machine-Specific Memory Partitions":"","zx-spectrum-48k#ZX Spectrum 48K":"This model supports only the 64K view.","zx-spectrum-128k#ZX Spectrum 128K":"The ROM 0 and ROM 1 segments allow you to access the two ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 or BANK 7 segments.","zx-spectrum-2e-3e#ZX Spectrum +2E, +3E":"The ROM 0... ROM 3 segments allow you to access the four ROM pages (16K each). The RAM banks (16K each) can be selected with one of the BANK 0 ... BANK 7 segments.","cambridge-z88#Cambridge Z88":"You can access one of the available 256 banks (16K each) by selecting the bank's index from the dropdown.","zx-spectrum-next#ZX Spectrum Next":"The dropdown provides these options to access memory segments:\nIDs from 00 to DF (000 to 224 in decimal view) to select an 8K RAM bank. The view does not support displaying them as 16K banks.\nM0, M1 ... MF: The 16 DivMMC RAM banks (8K each)\nNROM0 ... NROM3: The ROM pages of the ZX Next OS (16K each)\nALTR0, ALTR1: The alternate ROM pages (16K each)\nDivMR: The DivMMC ROM (8K)"}},"/working-with-ide/project-explorer":{"title":"The Project Explorer","data":{"":"TBD"}},"/working-with-ide/run-debug":{"title":"Running and Debugging code","data":{"":"Klive displays a toolbar at the top of the screen in the Emulator window and another in the IDE window. They have the same functionality: they control the emulated machine. The toolbar contains some emulator and IDE-specific functions; however, the machine control commands use the same components.This screen shows these controls in the emulator:\nMove the mouse over a particular control; it displays a tooltip to let you know its function.The leftmost button starts the machine in the selected mode (running with or without debugging). The dropdown next to the start button lets you select this mode:\nNote: The IDE displays Run Project (F5) and Debug Project (Ctrl+F5) options.\nStarting the machine has a different meaning for the Emulator and IDE windows.\nIn the emulator, you start the machine and let it run.\nWith its toolbar control in the IDE, you can start the machine only when a project is loaded. This start not only starts the emulated machine but also injects the compiled code into it and jumps to its entry point (all invokes it, depending on compilation options).\nKlive provides views (memory, disassembly, BASIC listing, and many more) that allow you to examine the machine's state.When the machine is running, you can use any of the windows to control it (pause, stop, or restart)\nPause: Klive pauses the machine at the current execution point. Soon, you will learn what you can do with the machine in this mode.\nStop: This stops the machine (like turning off the hardware). Though the machine is stopped, you can still examine its memory contents and state when turning it off.\nRestart: This function stops the machine and then starts it again. When you restart the machine in the IDE with a project loaded, it restarts your code and not just the machine.\nIn the paused state of a machine, you can use these actions:\nContinue. Go on running the machine.\nStop. (As described above)\nRestart. (As described above)\nStep into. Execute the subsequent CPU instruction and pause the machine again.\nStep over. Execute the subsequent CPU instruction entirely. If it is a CALL or RST instruction, a block operation (like LDIR), the IDE pauses again at the instruction following the current execution point.\nStep out. If you are within a subroutine, this function stops when the subroutine returns to its caller. Please note that this function only works if subroutine calls are completed by some of the RET instructions, not stack manipulation and jump statements.\nWhile the machine is paused, you can change between the run/debug execution modes with the dropdown."}},"/working-with-ide/system-vars":{"title":"The System Variables View","data":{"":"Note: The current System Variables view does not allow editing the variables' contents.\nYou can display the current system variable values in the Machine info activity tag with theÂ System Variables header:\nWhen you hover the mouse over a particular system variable label, you can read the explanation of that variable:\nWhen a system variable contains multiple flags, you can point to a particular flag to display its explanation:"}},"/working-with-ide/ula":{"title":"The ULA View","data":{"":"Most of the ZX Spectrum family of computers contains a ULA (Uncommitted Logic Array) chip, which renders the computer screen and I/O.You can find this view in the Debug activity tag with theÂ ULA & I/OÂ header:","ula-information#ULA Information":"When you hover the mouse over the information item values, they display a tooltip naming the particular information on the display.You can read this information in this panel:\nFCL: Frame clock. This value shows the current screen rendering tact, which depends on the ZX Spectrum model. For example, the ZX Spectrum 48K (PAL) uses 69.888 tacts to render the entire screen, including the borders, blank area, and sync tacts.\nFRM: The number of frames rendered since the machine started.\nRAS: The raster line being rendered\nPOS: The current rendering position within the raster line.\nPIX: The current pixel rendering operation:\nNone: A blank (non-visible) area is being rendered.\nBorder: The ULA sets the border color to display the current pixel.\nBorderFetchPixel: The ULA sets the border color to display the current pixel. It prepares to display the first pixel in the row by pre-fetching the corresponding byte from the display memory.\nBorderFetchAttr: The ULA sets the border color to display the current pixel. It has already fetched the byte of eight pixels to display, and it prepares to display the first pixel in the row by pre-fetching the corresponding attribute byte from the display memory.\nDisplayB1: The ULA displays the subsequent two pixels of Byte1 sequentially during a single Z80 clock cycle.\nDisplayB2: The ULA displays the subsequent two pixels of Byte2 sequentially during a single Z80 clock cycle.\nDisplayB1FetchB2: The ULA displays the subsequent two pixels of Byte1 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding byte from the display memory.\nDisplayB1FetchA2: The ULA displays the subsequent two pixels of Byte1 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding attribute from the display memory.\n** DisplayB2FetchB1 **: The ULA displays the subsequent two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding byte from the display memory.\nDisplayB2FetchA1: The ULA displays the subsequent two pixels of Byte2 sequentially during a single Z80 clock cycle. It prepares to display the pixels of the next byte in the row by pre-fetching the corresponding attribute from the display memory.\nBOR: The current border color.\nFLO: The current floating bus value. This value is returned if the ZX Spectrum model reads an unhandled port at the current clock item.\nCON: The accumulated number of T-states spent because of memory access contention between the ULA and the CPU since the machine started.\nLCO: The accumulated number of T-states spent because of memory access contention between the ULA and the CPU since the machine was last paused.\nEAR: The EAR I/O bit (flag).\nMIC: The MIC I/O bit (flag).","keyboard-state#Keyboard State":"You can view the keyboard state, which is listed by the flags in the KL0, ..., KL7 lines. Each flag represents a key's state. The active value (filled circle) is for the pressed-down state. The tooltip shows the associated key's name when you hover the mouse over a particular flag. For example, the following figure demonstrates that the rightmost flag in KL0 (the first key line) represents the Caps Shift key.\nBy clicking a particular key flag, you can toggle its state from pressed to released (and back). This feature is handy during debugging. After clicking the Enter key (the rightmost key in line 6), its state indicates that you have just toggled it.\nThe individual key lines represent these keyboard keys:\nKL0: V, C, X, Z, and Caps Shift.\nKL1: G, F, D, S, and A.\nKL2: T, R, E, W, and Q.\nKL3: 5, 4, 3, 2, and 1.\nKL4: 6, 7, 8, 9, and 0.\nKL5: Y, U, I, O, and P.\nKL6: H, J, K, L, and Enter.\nKL7: B, N, M, Symbol Shift, and Space."}},"/working-with-ide/zxb":{"title":"ZXBASIC Integration","data":{"":"Klive IDE supports ZXBASIC out-of-the-box. After setting up ZXBASIC integration, you can use Klive IDE to edit and run ZXBASIC programs.\nNote: The current version of ZXBASIC does not provide debug information, so source code debugging is not available with the IDE yet.\nAs Klive IDE does not know where to find the ZXBASIC compiler on your machine, you must set it up before using it.","setting-up-zxbasic#Setting up ZXBASIC":"You need to download and install ZXBASIC. Note the installation folder; you will need it to set up the integration with Klive.The IDE provides a command, zxb-reset (or shorter, zxbr), to connect Klive with ZXBASIC. You can issue this command from the Command window:\nThe command expects one to three parameters:\nThe path to the ZXBASIC compiler (required)\nThe path to access the Python interpreter (optional; you may need it on Mac and Linux)\nThe machine code origin address (optional, $8000, if omitted)\nNote #1: The ZXBASIC compiler is a Python script, so you need to have Python installed on your machine. On Windows, the IDE can find the Python interpreter automatically. On Mac and Linux, you must provide the path to the Python interpreter.\nNote #2: You can learn more about how settings are stored.","windows-integration#Windows Integration":"Windows 10 and 11 usually install Python with the OS. If not, you can install Python from here. ZXBASIC requires Python 3.10 or higher. The installer adds its folder to the PATH environment variable, so you can use zxb-reset with a single command parameter:\nzxb-reset <full path to zxbc.exe>\nWhen you define the path, you should provide the reference for the zxbc.exe file within the folder. For example, if you installed ZXBASIC into the C:\\Users\\joe\\zxbasic folder, use this command:\nzxb-reset C:\\Users\\joe\\zxbasic\\zxbc.exe\nWhen you have a space anywhere in the path, wrap the path into double quotes:\nzxb-reset \"C:\\My folder with spaces\\zxbasic\\zxbc.exe\"","macos-integration#MacOS Integration":"On MacOS, use the zxb-reset command with a full path to the zxbc.py file, like in this example:\nzxb-reset /Users/joe/zxbasic/zxbc.py\nMost of the time, you must also specify the Python interpreter path:\nzxb-reset /Users/joe/zxbasic/zxbc.py /opt/homebrew/bin\nNote: You can find the path of the Python installation with the which python3 command. Do not forget that the last segment is the python3 executable; you should omit it from the path specification.","linux-integration#Linux Integration":"I have not tried to integrate Klive IDE with ZXBASIC on Linux. If you did and have a helpful description of the integration steps, please create a PR to extend the installation notes in this article.","using-zxbasic#Using ZXBASIC":"Klive IDE considers files with .zxbas extension to be ZXBASIC source files. When you open such a file in the code editor (select a file in Explorer), the IDE applies the syntax highlighting of ZXBASIC.When you create a new project, by default, the code/code.kz80.asm file is the build root. However, when you right-click the code/program.zxbas file and use the Promote build root command, this file becomes the new build root. From now on, you can use the commands in the document tab toolbar when the program.zxbas file is open.\nYou can use the toolbar buttons to compile, inject, start, or debug the code as described in this article .When you run the ZXBASIC code in the default Klive project template, you can see the result in the Emulator window:"}},"/z80-assembly/expressions":{"title":"Expressions","data":{"":"The Klive Assembler has a rich syntax for evaluating expressions. You can use the same syntax with the #if directives, the Z80 instructions, and the compiler statements.You can use operands and operators just like in most programming languages. Nevertheless, the Klive implementation has its particular way of evaluating expressions:\nExpressions can be one of these types:\nBooleans (true or false)\nintegers (64-bit)\nfloating point numbers (64-bit precision)\nstrings (with 8-bit characters)\nThe assembler applies implicit conversion whenever it's possible.\nFloating point numbers are truncated to integer values.\nThe true Boolean literal is represented with the integer value 1; false with 0.\nWhen the assembler needs a Boolean value, 0 is considered false, and any other values as true.\nThere is no implicit conversion between strings and any numeric values.\nWhen the compiler needs a 16-bit value (for example, ld hl,NNNN), it uses the rightmost 16 bits of an expression's value.\nWhen a Z80 operation (for example, ld a,NN) needs an 8-bit value, it utilizes the rightmost 8 bits.\nBesides the parentheses â€” ( and ) â€” you can use square brackets\nâ€” [ and ] â€” to group operations and change operator precedence.\n; This is valid\nld hl,(Offset+#20)*2+BaseAddr\n; Just like this\nld hl,[Offset+#20]*2+BaseAddr","instant-and-late-expression-evaluation#Instant and Late Expression Evaluation":"Depending on the context in which an expression is used, the compiler evaluates it instantly or decides to postpone the evaluation. For example, when you use the .org pragma, the compiler applies immediate evaluation. Let's assume this is your code:\nStart: .org #8000 + Later\n; code body (omitted)\nLater: .db #ff\nThe value of Later depends on the address in .org, and the .org address depends on Later, so this declaration could not be adequately resolved; it's like a deadlock. The .org pragma would raise an error to avoid such situations, as at the moment of its evaluation, the Later symbol's value is unknown.For most Z80 instructions, the compiler uses late evaluation:\nStart: .org #6000\n    ld hl,(MyVar)\n    ; code body omitted\n    ret\nMyVar: .defs 2\nWhen the compiler reaches the ld hl,(MyVar) instruction, it does not know the value of MyVar. Nonetheless, it does not stop with an error but generates the machine code for ld hl,(0), namely #21, #00, and #00;\ntakes a note (it is called a fixup) when MyVal gets a value, the two #00 bytes generated at address #6001\nshould be updated accordingly.","operands#Operands":"You can use the following operands in expressions:\nBoolean, Decimal and hexadecimal literals\nCharacter literals\nIdentifiers\nThe current assembly address\nNote: String literals cannot be used as operands.","operators#Operators":"You can use about a dozen operators, including unary, binary, and ternary. In this section, you will learn about them. They will be introduced in descending order of their precedence.","conditional-operator#Conditional Operator":"The assembler supports using only one ternary operator, the conditional operator:conditional-expression ? true-value : false-valueThis operation results in -1:2 > 3 ? 2 : -1When the conditional-expression evaluates to true, the operation results\nin true-value; otherwise in false-value.\nNote: Conditional expressions are evaluated from right to left, unlike binary operators, which use left-to-right evaluation.","binary-bitwise-operators#Binary Bitwise Operators":"Operator token\tPrecedence\tDescription\t`\t`\t1\tBitwise OR\t^\t2\tBitwise XOR\t&\t3\tBitwise AND â€” string concatenation with new line\t\nNote: The & operator can be applied to two strings. If you do so, the compiler concatenates the two strings and puts a \\r\\n (new line) character pair between them.","relational-operators#Relational Operators":"Operator token\tPrecedence\tDescription\t==\t4\tEquality\t!=\t4\tNon-equality\t<\t5\tLess than\t<=\t5\tLess than or equal\t>\t5\tGreater than\t>=\t5\tGreater than or equal","shift-operators#Shift Operators":"The bits of the left operand are shifted by the number of bits given by the right operand.\nOperator token\tPrecedence\tDescription\t<<\t6\tShift left\t>>\t6\tShift right","basic-arithmetic-operators#Basic Arithmetic Operators":"Operator token\tPrecedence\tDescription\t+\t7\tAddition â€” string concatenation\t-\t7\tSubtraction\t*\t8\tMultiplication\t/\t8\tDivision\t%\t8\tModulo calculation\t\nOperator token\tPrecedence\tDescription\t<?\t9\tMinimum of the left and right operand\t>?\t9\tMaximum of the left and right operand","unary-operators#Unary operators":"Operator token\tPrecedence\tDescription\t+\t10\tUnary plus\t-\t10\tUnary minus\t~\t10\tUnary bitwise NOT\t!\t10\tUnary logical NOT\t\nDo not forget, you can change the default precedence with ( and ), or with [ and ].","functions#Functions":"The Z80 assembler provides a number of functions that can have zero, one, or more arguments.\nSeveral functions (for example as rnd()) have overloads with different signatures. Each\nfunction has a name and a parameter list wrapped into parentheses, the parameters are separated\nby a comma. Of course, parameters can be expressions, and they may invoke other functions, too.\nHere are a few samples:\nlength(\"Hello\" + \" world\")\nmax(value1, value2)\nsin(pi()/2)\nsqrt(pear + 3.0)\nThe Klive support these function signatures:\nSignature\tValue\tDescription\tabs(integer)\tinteger\tThe absolute value of an integer number.\tabs(float)\tfloat\tThe absolute value of a float number.\tacos(float)\tfloat\tThe angle whose cosine is the specified number.\tasin(float)\tfloat\tThe angle whose sine is the specified number.\tatan(float)\tfloat\tThe angle whose tangent is the specified number.\tatan2(float, float)\tfloat\tThe angle whose tangent is the quotient of two specified numbers.\tattr(integer, integer, boolean, boolean)\tinteger\tRetrieves the color attribute byte value defined by ink (first argument, 0 to 7), paper (second argument, 0 to 7), bright (third argument, 0 - non-zero), and flash (fourth argument, 0 - non-zero). The bright and flash values are optional.\tattraddr(integer, integer)\tinteger\tReturns the memory address of the byte specified screen attribute in the given line (first argument, from top to bottom, 0-192) and column (second argument, from left to right, 0-255).\tbright(boolean)\tinteger\tRetrieves the bright flag defined by the attribute (0 - non-zero). It can be ORed to create a color attribute value.\tceiling(float)\tfloat\tThe smallest integral value greater than or equal to the specified number.\tcos(float)\tfloat\tThe cosine of the specified angle.\tcosh(float)\tfloat\tThe hyperbolic cosine of the specified angle.\texp(float)\tfloat\te raised to the specified power.\tfill(string, integer)\tstring\tCreates a new string by concatenating the specified one with the given times.\tflash(boolean)\tinteger\tRetrieves the flash flag defined by the argument (0 - non-zero). It can be ORed to create a color attribute value.\tfloor(float)\tfloat\tThe largest integer less than or equal to the specified number.\tfrac(float)\tfloat\tThe fractional part of the specified number.\thigh(integer)\tinteger\tThe leftmost 8 bits (MSB) of a 16-bit integer number.\tink(integer)\tinteger\tRetrieves the three ink bits defined by the color argument (0 to 7). It can be ORed to create a color attribute value.\tint(float)\tinteger\tThe integer part of the specified number.\tlcase(string)\tstring\tThe lowercase version of the input string.\tleft(string, integer)\tstring\tTakes the leftmost characters of the string with the length specified.\tlen(string)\tinteger\tThe length of the specified string.\tlength(string)\tinteger\tThe length of the specified string.\tlog(float)\tfloat\tThe natural (base e) logarithm of a specified number.\tlog(float, float)\tfloat\tThe logarithm of a specified number in a specified base.\tlog10(float)\tfloat\tThe base 10 logarithm of a specified number.\tlow(integer)\tinteger\tThe rightmost 8 bits (LSB) of an integer number.\tlowercase(string)\tstring\tThe lowercase version of the input string.\tmax(integer, integer)\tinteger\tThe larger of two integer numbers.\tmax(float, float)\tfloat\tThe larger of two float numbers.\tmin(integer, integer)\tinteger\tThe smaller of two integer numbers.\tmin(float, float)\tfloat\tThe smaller of two float numbers.\tnat()\tfloat\tRepresents the natural logarithmic base, specified by the constant, e.\tpaper(integer)\tinteger\tretrieves the three paper bits defined by the argument (0 to 7). It can be ORed to create a color attribute value.\tpi()\tfloat\tRepresents the ratio of the circumference of a circle to its diameter, specified by the constant, Ï€.\tpow(float, float)\tfloat\tThe specified number raised to the specified power.\tright(string, integer)\tstring\tTakes the rightmost characters of the string with the length specified.\tround(float)\tfloat\tRounds a float value to the nearest integral value.\tround(float, int)\tfloat\tRounds a float value to a specified number of fractional digits.\trnd()\tinteger\tReturns a random 32-bit number.\trnd(integer, integer)\tinteger\tReturns a random 32-bit integer between the first and second number.\tscraddr(integer, integer)\tinteger\tRetrieves the memory address of the screen pixel byte in the specified line (first argument, from top to bottom, 0-192) and in the specified column (second argument, from left to right, 0-255).\tsign(integer)\tinteger\tReturns an integer that indicates the sign of an integer number.\tsign(float)\tinteger\tReturns an integer that indicates the sign of a float number.\tsin(float)\tfloat\tThe sine of the specified angle.\tsinh(float)\tfloat\tThe hyperbolic sine of the specified angle.\tsqrt(float)\tfloat\tThe square root of a specified number.\tstr(bool)\tstring\tConvert the input value to a string.\tstr(integer)\tstring\tConvert the input value to a string.\tstr(float)\tstring\tConvert the input value to a string.\tsubstr(string, integer, integer)\tstring\tTakes a substring of the specified string from the given position (zero-based) and length.\ttan(float)\tfloat\tThe tangent of the specified angle.\ttanh(float)\tfloat\tThe hyperbolic tangent of the specified angle.\ttruncate(float)\tinteger\tCalculates the integral part of a specified number.\tucase(string)\tstring\tThe uppercase version of the input string.\tuppercase(string)\tstring\tThe uppercase version of the input string.\tword(integer)\tinteger\tThe rightmost 16 bits of an integer number.\t\nFunctions have the same precedence as the unary operators (such as the unary + and -).","parse-time-functions#Parse Time Functions":"The compiler provides a construct, parse time functions. These functions can receive a Z80 assembly language token and transform them into other language constructs. As the name suggests, these functions run in the parsing phase before the compiler emits code.","the-lreg-and-hreg-parse-time-functions#The lreg() and hreg() Parse Time Functions":"These functions accept a 16-bit register pair token (BC, DE, HL, IX, or IY) and retrieve the lower\nor higher 8-bit register half of their input. Here is a sample code snippet:\nld a,lreg(bc)\nld c,hreg(hl)\nld a,lreg(ix)\nld l,hreg(de)\nThe compiler sees as if you wrote this:\nld a,c\nld c,h\nld a,ixl\nld l,d","the-textof-parse-time-function#The textof() Parse Time Function":"You can use textof(), which accepts these kinds of tokens: mnemonic, register, register indirection, C port, or condition. This function translates these tokens into uppercase string constants that represent them.\nHere is a sample:\n.dm textof(ldir)\n.dm textof(bc)\n.dm textof((de))\n.dm textof((c))\n.dm textof(nz)\nThe compiler sees as if you wrote this code:\n.dm \"LDIR\"\n.dm \"BC\"\n.dm \"(DE)\"\n.dm \"(C)\"\n.dm \"NZ\""}},"/z80-assembly/language-structure":{"title":"Klive Z80 Assembly Language Structure","data":{"":"Each line of the source code is a declaration unit and is parsed in its context. Such a source code line can be one of these constructs:\nA Z80 instruction, which can be directly compiled to binary code (such as ld bc,#12AC)\nA directive that is used by the compiler's preprocessor (e.g. #include, #if, etc.)\nA pragma that emits binary output or instructs the compiler about code emission (.org, .defb, etc.)\nA compiler statement (or shortly, a statement) that implements control flow operations for the compiler (e.g., .loop, .repeat...until, .if...elif...else...endif)\nA comment that helps the understanding of the code.","syntax-basics#Syntax Basics":"The assembler language uses a unique way of case sensitivity. You can write reserved words (such as assembly instructions, pragmas, or directives) with lowercase or uppercase letters, but you cannot mix these cases. For example, these instructions use the proper syntax:\nLD c,A\nJP #12ac\nldir\ndjnz MyLabel\nHowever, in these samples, character cases are mixed, and the compiler will refuse them:\nLd c,A\nJp #12ac\nldIR\ndjNZ MyLabel\nIn symbolic names (labels, identifiers, etc.), you can mix lowercase and uppercase letters. Nonetheless, the compiler applies case-insensitive comparison when matching symbolic names. So, these statement pairs are equivalent to each other:\njp MainEx\njp MAINEX\ndjnz mylabel\ndjnz MyLabel\nld hl,ErrNo\nld hl,errNo","comments#Comments":"The language supports two types of comments: end-of-line and block comments.En-of-line comments start with a semicolon (;) or double forward slash (//). The compiler takes the rest of the line into account as the body of the comment. This sample illustrates this concept:\n; This line is a comment-only line\nWait:   ld b,8     ; Set the counter\nWait1:  djnz Wait1 // wait while the counter reaches zero\nBlock comments can be put anywhere within an instruction line between /* and */ tokens until they do not break other tokens. Nonetheless, block comments cannot span multiple lines; they must start and end within the same source code line. All of the block comments in this code snippet are correct:\nSetAttr:\n\tld b,32\nfill:\n  /* block */\n  /* b2 */ ld (hl),a\n  inc /* b3 */ hl\n  djnz /* b4 */ fill /* b5 */\n  ret\nHowever, this will result in a syntax error:\n/* \n  This block comment spans multiple lines,\n  and thus, it is invalid\n*/\nSetAttr:\n\tld b,32\nNote: If you need multi-line comments, you can add single-line comments after each other. The Z80 assembly does not have separate multi-line comment syntax.","literals#Literals":"The language syntax provides these types of literals:\nBoolean values. The following tokens represent Booleans: .false, false, .true, and true.\nDecimal numbers. You can use up to 5 digits (0..9) to declare a decimal number. For example: 16, 32768, 2354.\nFloating point numbers. You can use the same notation for floating point numbers as in C/C++/Java/C#. Here are a few samples:\n.25\n123.456\n12.45E34\n12.45e-12\n3e+4\nHexadecimal numbers. You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare a hexadecimal literal. The compiler looks for a #, 0x, or $ prefix or one of the h or H suffixes to recognize them as hexadecimal. If you use the h or H suffixes, the hexadecimal number should start with a decimal digit 0...9; otherwise, the assembler interprets it as an identifier (label). Here are a few samples:\n#12AC\n0x12ac\n$12Ac\n12ACh\n12acH\n0AC34H\nBinary numbers. Literals starting with one of the %, or 0b prefixes (or with the b or B suffix) are considered binary literals. You can follow the prefix with up to 16 0 or 1 digits. To make them more readable, you can separate adjacent digits with the underscore (_) or single quote (') character. These are all valid binary literals:\n%01011111\n0b01011111\n0b_0101_1111\n0101_1111b\n0b'0101'1111\nOctal numbers. You can use up to 6 digits (0..7) with an o, O (letter O), q, or Q suffix to declare an octal number. Examples: 16o, 327q, 2354Q.\nNote: You can use negative numbers with the minus sign in front of them. The sign is not part of the numeric literal; it is an operator.\nCharacters. You can put a character between single quotes (for example: 'Q').\nStrings. You can put a series of characters between double quotes (for example: \"Sinclair\").\nNote: You can use escape sequences to define non-visible or control characters, as you will learn soon.\nThe $, * or . tokens. These literals are equivalent; all represent the current assembly address.","identifiers#Identifiers":"You can use identifiers to refer to labels and other constants. Identifiers must start with a letter (a...z or A...Z) or with one of these characters: ` (backtick), _ (underscore), @, !, ?, or #. The subsequent ones can be digits and any start characters except backtick. Here are a few examples:\nMyCycle\nERR_NO\nCycle_4_Wait\n`MyTemp\n@ModLocal\nIsLastLine?\nNote: Some strings can be identifiers or hexadecimal literals with the H or h suffix, like AC0Fh, or FADH. The assembler considers such strings as identifiers. To sign a hexadecimal literal, use a 0 prefix: 0FADH is a hexadecimal literal, while FADH is an identifier.\nNote: Theoretically, you can use arbitrary long identifiers. I suggest you make them no longer than 32 characters so readers can read your code easily.","scoped-identifiers#Scoped Identifiers":"As you will later learn, the Klive Assembler supports modules like namespaces in other languages (Java, C#, C++, etc.) to encapsulate labels and symbols. To access symbols within modules, you can use scoped identifiers with this syntax:::? identifier (. identifier)*The optional :: token means the name should start in the outermost (global) scope. The module and identifier segments are separated with a dot. Examples:\n::FirstLevelModule.Routine1\nNestedModule.ClearScreen\nFirstLevelModule.NestedModule.ClearScreen","characters-and-strings#Characters and Strings":"You have already learned that you can utilize character and string literals (wrapped into single or double quotes, respectively), such as in these samples:\n\"This is a string. The next sample is a single character:\"\n'c'\nZX Spectrum has a character set with special control characters such as AT, INK, PAPER, etc. The Assembler allows you to define these with special escape sequences:\nEscape\tCode\tCharacter\t\\i\t0x10\tINK\t\\p\t0x11\tPAPER\t\\f\t0x12\tFLASH\t\\b\t0x13\tBRIGHT\t\\I\t0x14\tINVERSE\t\\o\t0x15\tOVER\t\\a\t0x16\tAT\t\\t\t0x17\tTAB\t\\P\t0x60\tpound sign\t\\C\t0x7F\tcopyright sign\t\\\\\t0x5C\tbackslash\t\\'\t0x27\tsingle quote\t\\\"\t0x22\tdouble quote\t\\0\t0x00\tbinary zero\t\nNote: Some of these sequences have different values than their corresponding pairs in other languages, such as C, C++, C#, or Java.\nTo declare a character by its binary code, you can use the \\xH or\n\\xHH sequences (H is a hexadecimal digit). For example, these\nescape sequence pairs are equivalent:\n\"\\i\"\n\"\\x10\"\n\"\\C by me\"\n\"\\x7f \\x62y me\"","labels-and-symbols#Labels and Symbols":"In Klive Z80 Assembly, you can define labels and symbols. Both constructs are syntactically the same, but there is some difference in their semantics. While we define labels to mark addresses (code points) in the program so that we can jump to those addresses and read or write their contents, symbols are not as specific; they just store values we intend to use.From now on, I will mention \"label\" for both constructs and do otherwise only when the context requires it.When you write a Klive Assembly instruction, you can start the line with a label:\nMyStart: ld hl,0\nHere, in this sample, MyStart is a label. The assembler allows you to omit the colon after the label name, so this line is valid:\nMyStart ld hl,0\nSome developers like to put a label in a separate line from the instruction to which it belongs. You can use the same hanging label style within Klive. In this case, the label should go before its instruction. Take a look at this code snippet:\nMyStart:\n  ld hl,0\nMyNext\n  ; Use B as a counter\n  ld b,32\nThis code is entirely correct. Note the ld b,32 instruction belongs to the MyNext label. As you see from the sample, the colon character is optional for hanging labels, too. You can have multiple line breaks between a label and its instruction, and the space can include comments.","label-and-symbol-declarations#Label and Symbol Declarations":"As you will learn later, you can define symbols with the .EQU or .VAR pragmas. While .EQU allows you to assign a constant value to a symbol, it cannot change its value after the declaration. .VAR lets you re-assign the initial value.Klive supports the idea of lexical scopes. When you create the program, it starts with a global (outermost) lexical scope. Particular language elements, such a statements create their nested lexical scope. Labels and symbols are always created within the current lexical scope. Nonetheless, when resolving them, the assembler starts with the innermost scope and goes through all outer scopes until it finds the label declaration.This mechanism means that you can declare labels within a nested scope so that those hide labels and symbols in outer scopes.Klive also supports modules, which allow you to use namespace-like constructs.","temporary-labels#Temporary Labels":"The assembler considers labels that start with a backtick (`) character as temporary labels. Their scope is the area between the last persistent label preceding the temporary one and the first persistent label following the temporary one.This code snippet demonstrates this concept:\nSetPixels:        ; Persistent label\n  ld hl, #4000\n  ld a,#AA\n  ld b,#20\n`loop:            ; Temporary label (scope #1)\n  ld (hl),a\n  inc hl\n  djnz `loop\nSetAttr:          ; Persistent label, scope #1 disposed here\n  ld hl,#5800\n  ld a,#32\n  ld b,#20\n`loop:            ; Temporary label (scope #2)\n  ld (hl),a\n  inc hl\n  djnz `loop\n  ret\n; scope #2 still lives here\n; ...\nAnother: ; Persistent label, scope #2 disposed here\n  ld a,b\nAs you see, the two occurrences of  `loop  belong to two separate temporary scopes. The first scope is the one between SetPixels and SetAttr, the second one between SetAttr and Another."}},"/z80-assembly/macros":{"title":"Macros","data":{"":"The Klive Assembler provides a powerful way to declare and apply macros in the code. While in most programming languages and assemblers, the macros are preprocessor constructs and use simple\ntext replacement, the Klive implementation is different.\nNote: Unlike in C, C++ (and some Z80 Assemblers), Klive macros emit only code (through instructions and pragmas); they cannot be used as user-defined functions. When you pass parameters to macros, any parameter expression is evaluated instantly, so you cannot use unknown symbols or variables, ones that will get their values only somewhere later in the code.","getting-started-with-macros#Getting Started with Macros":"The best way to show you what macros can do is actual code. Let's start with a simple parameterless macro:\nDelay: \n    .macro()    \n    DelayLoop:\n        djnz DelayLoop\n    .endm\nYou can easily use this macro in your code:\nld b,#24\nDelay()\n; ...and later\nld b,#44\nDelay()\nThe assembler will emit the code like this:\nld b,#24\nDelayLoop_1: djnz DelayLoop_1\n; ...and later\nld b,#44\nDelayLoop_2: djnz DelayLoop_2\nAs you expect, it takes care that the DelayLoop label remains local within the scope of the macro; otherwise, it would lead to a duplicated label name.This macro is named Delay, and it uses the value of the B register to create a djnz loop. You can easily apply this macro.Now, let's enhance this macro with an argument:\nDelay: \n    .macro(wait)    \n        ld b,{{wait}}\n    DelayLoop:\n        djnz DelayLoop\n    .endm\nAs the body of the macro suggests, {{wait}} is a placeholder for the wait argument. While other assemblers do not use a separate markup for a placeholder (they'd just use wait),  Klive applies this markup for\ntwo reasons: first, it is visually better and more eye-catching; second, it allows the compiler to provide better performance.You can use this macro passing an argument value for wait:\nDelay(#24)\nDelay(d)\nAs you expect, the compiler now emits this code:\nld b,#24\nDelayLoop_1: djnz DelayLoop_1\n; ...and later\nld b,d\nDelayLoop_2: djnz DelayLoop_2\nMacros allow you to pass anything that could be an operand in a Z80 instruction, so this is entirely valid:\nDelay((ix+23))\nAs you can imagine, this macro invocation results as if you wrote this:\nld b,(ix+23)\nDelayLoop: djnz DelayLoop\nKlive macros do not stop here. You can define macros that receive an entire Z80 instruction as an argument:\nRepeatLight: \n    .macro(count, body)    \n        ld b,{{count}}\n    DelayLoop:\n        {{body}}\n        djnz DelayLoop\n    .endm\nThis macro is to repeat the body in count several times. This is how you can invoke it:\nRepeatLight(4, \"add a,c\")\nThe second argument of the macro is a string that names the add a,c operation. The result of this macro is this set of instructions:\nld b,4\nDelayLoop_1: \n  add a,c\ndjnz DelayLoop_1\nInstead of a run time loop, you can apply a compile time loop within the macro:\nRepeatLight: \n    .macro(count, body)\n      .loop {{count}}\n          {{body}}\n      .endl\n    .endm\nThe RepeatLight(3, \"add a,c\") line invokes the macro, and the macro's body translates to this:\n.loop 3\n    add a,c\n.endl\nAs you already learned, the compiler handles this as if you wrote:\nadd a,c\nadd a,c\nadd a,c\nKlive allows you to pass a set of lines as a macro argument. You can invoke RepeatLight like this:\nRepeatLigth(3, \"add a,c\" & \"add a,10\")\nOr, you can make it with variables:\nFirstOp = \"add a,c\"\nSecondOp = \"add a,10\"\nRepeatLight(3, FirstOp & SecondOp)\nNote: The & operator between the two string values concatenates them with a next-line character set (#0A and #0D). If you apply the + operator, the above code would fail: the assembler accepts only a single instruction in a text line and would reject multiple instructions.\nIn macros, you can use several unique functions, such as lreg() and hreg(). These work during parse time and retrieve the lower and higher 8-bit register of a 16-bit register pair:\nLdHl: \n    .macro(reg16)\n        ld h,hreg({{reg16}})\n        ld l,lreg({{reg16}})\n    .endm\nHere, you can apply the LdHl macro like this:\nLdHl(de)\nLdHl(bc)\nThe compiler translates these macro invocations into these Z80 instructions:\nld h,d\nld l,e\nld h,b\nld l,c\nWhen you invoke a macro, you can pass fewer parameters than the macro declares. Within the macro body, you can use the def() function to check whether the specified parameter has been passed:\nPush:\n    .macro(r1, r2, r3, r4)\n      .if def({{r1}})\n        push {{r1}}\n      .endif\n      .if def({{r2}})\n        push {{r2}}\n      .endif\n      .if def({{r3}})\n        push {{r3}}\n      .endif\n      .if def({{r4}})\n        push {{r4}}\n      .endif\n    .endm\nThe Push macro in this code snippet allows you to create a push instruction for up to 4 register pairs. Look at these usages:\nPush(af)\n; ... and later\nPush(bc, de, ix)\nThis is what the compiler generates:\npush af\n; ... and later\npush bc\npush de\npush ix\nYou can opt not to pass a macro parameter for a specific argument. Look at this macro declaration:\nLdBcDeHl:\n    .macro(bcVal, deVal, hlVal)\n      .if def({{bcVal}})\n        ld bc,{{bcVal}}\n      .endif\n      .if def({{deVal}})\n        ld de,{{deVal}}\n      .endif\n      .if def({{hlVal}})\n        ld hl,{{hlVal}}\n      .endif\n    .endm\nYou can invoke this macro in these ways, leaving a parameter empty to sign that you do not intend to use it:\nLdBcDeHl(,#1000,#2000)\n; ... and later\nLdBcDeHl(#3000,,#4000)\nThe compiler understands your intention and generates this output:\nld de,#1000\nld hl,#2000\n; ... and later\nld bc,#3000\nld hl,#4000\nIt's time to go deep into the nitty-gritty details of creating and using macros in Klive.","macro-declaration#Macro Declaration":"Macros must have a name. Each macro is named according to the label preceding its declaration, either in the same line as the .macro token or before it as a hanging label. Macros can have zero, one, or more named arguments separated by a comma. The macro declaration is closed with the .endm token:\nMacroWithHangingLabel:\n    .macro(myParam, otherParam)\n    ; Macro body\n    .endm\nMyMacro: macro()\n    ; Macro body\n    .endm\nEven if a macro does not have arguments, its declaration must contain the parentheses.The macro body can contain Z80 instructions, pragmas, or statements. The only exceptions are the ENT and XENT pragmas.As you already experienced, the Assembler supports syntax variants for the macro-related keywords. The Assembler accepts these tokens: .macro, macro, .MACRO, MACRO, .endm, endm, .ENDM, ENDM, .mend, mend, .MEND, and MEND.Within the macro's body, you can refer to the arguments of the macros wrapping them into double curly braces:\nMul10:\n    .macro(reg8)\n    push af\n    ld a,{{reg8}}\n    add a,a\n    push bc\n    ld b,a\n    add a,a\n    add a,a\n    add a,b\n    pop bc\n    ld {{reg8}},a\n    .endm\nArguments are identifiers. Thus, the corresponding naming rules are applied to them. You cannot use a reserved word (for example, a mnemonic like ldir or a register name like hl) as a macro argument.","macro-parameters#Macro Parameters":"You can invoke a macro with as many parameters as many arguments its declaration has or even with fewer parameters. If the macro invocation has more parameters than arguments, the compiler raises an error.Let's assume you've created this macro declaration:\nMyMacro: .macro(arg1, arg2, arg2)\n; Macro body\n.endm\nAll of these usages are valid:\nMyMacro()\nMyMacro(a)\nMyMacro(a, b)\nMyMacro(a, b, c)\nNonetheless, this usage is invalid since it passes more than three parameters:\nMyMacro(a, b, c, d) ; ERROR: To many parameters\nSometimes, it is convenient to omit not the last parameters but one at the beginning or the middle of the parameter list. You can do that: an empty comma separator signs that the preceding parameter is empty. Using this\nnotation, all these invocations of MyMacro are valid:\nMyMacro(,b)\nMyMacro(a,,c)\nMyMacro(,,)\nWithin the macro declaration, you can use the def() function to check if a particular argument has a value.\nLdBcDeHl:\n    .macro(bcVal, deVal, hlVal)\n      .if def({{bcVal}})\n        ld bc,{{bcVal}}\n      .endif\n      .if def({{deVal}})\n        ld de,{{deVal}}\n      .endif\n      .if def({{hlVal}})\n        ld hl,{{hlVal}}\n      .endif\n    .endm\nThe def() function accepts only a macro argument reference (the argument's name wrapped in double curly braces). This function evaluates to true only when the macro argument is not empty.You can use the logical NOT operator (!) combined with def() to check if an argument is empty.\nMyMacro: .macro(arg)\n  .if !def({{arg}})\n    ; generate something for empty arg\n  .endif\n.endm","passing-parameters-to-macros#Passing Parameters to Macros":"You can pass anything as a macro parameter that is a valid operand of a Z80 instruction:\nNames of 8-bit registers and 16-bit register pairs (e.g. a, b, ixl, hl sp, af, etc.)\nNames of conditions (e.g. z, nz, pe, m, etc.)\nMemory address indirection (e.g. (#4000), (#4000+#20))\nRegister pair indirection (e.g. (bc), (de), (hl), etc.)\nIndexed indirection (e.g. (ix+#20), (iy-12), etc.)\nC-port ((c))\nExpression (e.g. (MyId << 1) + 23, #4000, 12*sin(pi()/4), \"ld \" + \"a,b\", etc.)\nYou should be careful when you use parentheses in expressions. Let's assume you declare this macro:\nSetHlValue:\n    .macro(value)\n        ld hl,{{value}}\n    .endm\nWhen you use it, the first invocation uses an expression, and the second has a memory address indirection:\nSetHlValue(#4000+#20)\nSetHlValue((#4000+#20))\nThe compiler translates them to these instructions:\nld hl,#4020\nld hl,(#4020)\nTo avoid such issues, you can use the square brackets to group parts of expressions. When you invoke the SetHlValue macro with this way, both usage with generate a ld hl,#4020 statement:\nSetHlValue(#4000+#20)\nSetHlValue([#4000+#20])\nNote: When you pass parameters to macros, any parameter expression is evaluated instantly, so you cannot use unknown symbols or variables (ones that will get their values only somewhere later in the code.)\nThe compiler replaces the macro argument references to their current values passed in parameters. Whenever you use an expression, its value is converted into a string and put into the place of the macro argument.","passing-instructions-in-a-macro-parameter#Passing Instructions in a Macro Parameter":"Within a macro declaration, you can use a macro argument reference instead of an entire Z80 instruction. Take a look at this macro:\nShortDi:\n    .macro(body)\n        di\n        {{body}}\n        ei\n    .endm\nHere, the body argument is expected to get something the compiler can understand as an entire instruction. When you invoke the macro, you need to pass a string expression so that the compiler can replace the {{body}} reference. Here is an example:\nShortDi(\"in a,(#fe)\")\nAs you expect, the compiler generates this output:\ndi\nin a,(#fe)\nei\nYou are not obliged to use Z80 instructions; the compiler accepts pragmas, too:\nShortDi(\".db #00\")\nWell, the output is not pretty useful; nonetheless, the compiler generates this:\ndi\n.db #00\nei","passing-multiple-lines-in-a-macro-parameter#Passing Multiple Lines in a Macro Parameter":"If you pass multiple lines in a macro parameter where the corresponding argument reference is used instead of an entire instruction line, the compiler will apply all those lines. In this case, the individual lines should be separated by new line characters (\\r\\n). The & operator, when applied for two strings, does this step for you, as it concatenates the two strings with \\r\\n between them. Let's assume you invoke the ShortDi macro with this code:\nShortDi(\"ld a,#7f\" & \"in a,(#fe)\")\nNow, the compiler will generate this output:\ndi\nld a,#7f\nin a,(#fe)\nei\nBecause you can pass expressions as macro parameters, you can invoke the macro in this way, too:\nFirstOp = \"ld a,#7f\"\nSecondOp = \"in a,(#fe)\"\nShortDi(FirstOp & SecondOp)\nYou can pass not only instructions and pragmas to macros but also statements:\nLoopOp = \".loop 3\" & \"nop\" & \".endl\"\nShortDi(LoopOp)\nThe compiler will emit this code:\ndi\nnop\nnop\nnop\nei","labels-symbols-and-variables-in-macros#Labels, Symbols, and Variables in Macros":"Macros have a local scope for all labels, symbols, and variables created within their body, including the label attached to the .endm statement. The macro's name is a label that also represents the start of the macro.Take a look at this macro definition:\nGetBoundaries:\n    .macro(instr)\n        {{instr}}\n        ld de,EndLabel\n        ld hl,GetBoundaries\nEndLabel:\n    .endm\nHere, the ld hl,GetBoundaries instruction fills HL with the start address of the macro, while the ld de,EndLabel instruction puts the address of the next instruction following the macro into DE.Let's assume you use the macro this way:\n.org #8000\nGetBoundaries(\"nop\")\nGetBoundaries(\"ld ix,#ABCD\")\nThe compiler will create this output:\n#8000 GetBoundaries_1 nop\n#8001                 ld de,#8007 ; EndLabel_1\n#8004                 ld hl,#8000 ; GetBoundaries_1\n#8007 EndLabel_1\n      GetBoundaries_2 ld ix,#ABCD\n#800B                 ld de,#8011 ; Endlabel_2\n#800E                 ld hl,#8007 ; GetBoundaries_2\n#8011 EndLabel_2\nSymbols and variables within the context work exactly as they do with loops. Remember: Symbols are constant values, while variables may change!","invoking-macros-from-macros#Invoking Macros from Macros":"Klive allows you to invoke a macro from another macro, too. Here is a short sample:\nDelay:\n    .macro(wait)\n        ld b,{{wait}}\n        WaitLoop: djnz WaitLoop\n    .endm\nBorderPulse:\n    .macro(col1, wait1, col2, wait2)\n        ld a,{{col1}}\n        out (#fe),a\n        Delay({{wait1}})\n        ld a,{{col2}}\n        out (#fe),a\n        Delay({{wait2}})\n    .endm\nHere, the BorderPulse macro uses Delay as a helper macro. The BorderPulse(2, 10, 3, 20) invocation produces this output:\nld a,2\nout (#fe),a\nld b,10\nWaitLoop_1: djnz WaitLoop_1\nld a,3\nout (#fe),a\nld b,20\nWaitLoop_2: djnz WaitLoop_2","macro-related-parse-time-functions#Macro-Related Parse-Time Functions":"The Klive Assembler allows several parse-time functions with macro arguments similar to the def() function to check whether a macro argument has been passed to the macro invocation.These functions check if the argument is an operand the name of the function suggests. Each of them returns true, provided the function recognizes the operand; otherwise, false.The Assembler supports these functions:\nName\tDescription\tisreg8std()\tThe operand is an 8-bit register, one of these: a, b, c, d, e, h, l, i, r, xh (ixh), xl (ixl), yh (iyh), or yl (iyl)\tisreg8std()\tThe operand is a standard 8-bit register, one of these: a, b, c, d, e, h, or l\tisreg8spec()\tThe operand is a special 8-bit register, i, or r\tisreg8idx()\tOne of these 8-bit index registers: xh (ixh), xl (ixl), yh (iyh), or yl (iyl)\tisreg16()\tAny of these 16-bit registers: af, bc, de, hl, sp, ix or iy\tisreg16std()\tAny of the standard 16-bit registers: bc, de, hl, or sp\tisreg16idx()\tAny of the ix or iy registers\tisregindirect()\tThe operand is one of these: (bc), (de), (hl), or (sp)\tisindexedaddr()\tThe operand is an indexed address like (ix), (iy), (ix+#12), (iy-#23), and so on\tiscport()\tThe operand is (c) (e.g., in the out (c),a instruction)\tiscondition()\tThe operand is one of these conditions: z, nz, c, nc, po, pe, p, or m\tisexpr()\tThe operand is an expression, for example: 1 + 2, #1000, myvalue + 23, etc.\tisreg<reg>()\tThe operand is the register as given in <reg>. You can use these names: a, af, b, c, bc, d, e, de, h, l, hl, i, r, xh, xl, ix, yh, yl, iy, and sp. For example, isrega() tests if the specified register is A.\t\nNote: When you pass 'c' as a macro argument, both the isreg8() and iscondition() parse-time functions accept it, as the 'c' token can be either an 8-bit register or a condition (carry flag is set).\nHere is a short sample:\nMyRegMacro: .macro(arg)\n    .if isreg8({{arg}})\n        ld a,{{arg}}\n    .else\n        .error \"Only 8-bit registers are allowed\"\n    .endif\n.endm\nMyRegMacro allows using only an 8-bit register as its argument. If you provide another type of parameter, the macro raises an error."}},"/z80-assembly/pragmas":{"title":"Pragmas","data":{"":"The compiler understands several pragmas that â€” thought they are not Z80 instructions â€” they influence the emitted code. Each pragma has two alternative syntax constructs, one with a dot prefix and another without.For example, you can write ORG or .ORG to use the ORG pragma.","the-org-pragma#The ORG pragma":"With the ORG pragma, you define where to place the compiled Z80 code when you run it.For example, the following line sets this location to the 0x6000 address:\n.org #6000\nIf you do not use ORG, the default address is 0x8000.You can apply multiple ORG pragmas in your source code. Each usage creates a new segment in the assembler output. Take a look at this code:\nld h,a\n.org #8100\nld d,a\n.org #8200\nld b,a\nThis code generates three output segments, each with one emitted byte representing the corresponding LD operation. The first segment will start at 0x8000 (default), the second at 0x8100, and the third at 0x8200.","the-xorg-pragma#The XORG pragma":"With the XORG pragma, you define the start address of a specific code section (the section started with the previous .ORG) to use when exporting to Intel HEX format.For example, the following line sets this location to the 0x0000 address; however, the code section starts at 0x6000.\n.org #6000\n.xorg #0\nIf you try to use multiple .XORG within a code section, the assembler raises an error:\n.org #6000\n.xorg #0\n    ld a,b\n    ; ...\n.xorg #1000 ; This line will cause an error message","the-ent-pragma#The ENT pragma":"The ENT pragma defines the entry code of the program when you start it. If you do not apply ENT in your code, the entry point will be the first address of the very first output code segment. Here's a sample:\n.org #6200\nld hl,#4000\n.ent $\njp #6100\n.org #6100\ncall MyCode\n...\nThe .ent $ pragma will sign the address of the jp #6100 instruction as the entry address of the code. Should you omit the ENT pragma from this code, the entry point would be0x6200, as that is the start of the very first output segment, even though there is another segment starting at 0x6100.","the-xent-pragma#The XENT pragma":"The IDE provides a command, Export Code, which allows you to create a LOAD block that automatically starts the code. When you run the code from the IDE, the address specified with the ENT pragma is used. However, the auto LOAD block uses the RANDOMIZE USR address pattern, and you may need to define a different entry address that can be closed with a RET statement. The XENT pragma sets this address.Here's a sample:\nstart: \n\t.org #8000\n\t.ent #8000\n\tcall SetBorder\n\tjp #12ac\nSetBorder:\n\t.xent $\n\tld a,4\n\tout (#fe),a\n\tret\nThe IDE will use #8000 â€” according to the .ent #8000 pragma â€” when starting the code from the IDE. Nonetheless, the exported code will offer #8006 â€” according to the .xent $ pragma â€” as the startup code address.","the-disp-pragma#The DISP pragma":"The DISP pragma allows you to define a displacement for the code. The value affects the $ token representing the current assembly address. Your code is placed according to the ORG of the particular output segment, but the assembly address is always displaced with the value according to DISP. Take a look at this sample:\n.org #6000\n.disp #1000\nld hl,$\nThe ld hl,$ instruction will be placed to the 0x6000 address, but it will be equivalent\nwith the ld hl,#7000 statement due to the .disp #1000 displacement.\nOf course, you can use negative displacement, too.","the-bank-pragma#The BANK pragma":"The ZX Spectrum 128K/2A/+2A/+3/+3E models handle 16K memory pages (banks) that can be paged into particular memory slots. (You can find more information about this here.)The BANK pragma lets you declare that you want to put the Z80 Assembly code in a specific memory bank. When you export the compiled output, the Export code command of the IDE creates a loader that reads the code and places it on the specified memory page.The BANK pragma accepts two parameters. The first is the bank number (so it must be between 0 and 7). The second one is an optional offset value (between 0 and 16383), which indicates the start offset within the bank. If you omit this, the default value is zero. By default, the Klive Assembler assumes that the start address of the code in the bank is $C000. Nonetheless, you can specify any other value.\nNote: You need to apply the .model Spectrum128 pragma at the top of your code so that you can use .bank.","using-bank-without-an-offset#Using BANK without an offset":"Let's assume you have this code:\n.model Spectrum128\n; ...\n.bank 3\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nThe compiler emits this code (and later, the loader takes care that it goes to bank #3):\n0000: call #C004  ; yellow\n0003: ret\n0004: ld a,#06    ; this is yellow (#C004)\n0006: out (#FE),a\nThe offset values at the beginning of the lines show the byte offset within the 16K memory bank.","using-bank-with-an-offset#Using BANK with an offset":"Let's modify the previous code by adding an offset value:\n.model Spectrum128\n; ...\n.bank 3, #100\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nNow, the compiler emits similar code, but its start address is #C100 (#100 away from the default #C000):\n0100: call #C104  ; yellow\n0103: ret\n0104: ld a,#06    ; this is yellow (#C104)\n0106: out (#FE),a\nThough we're wasting the first 256 bytes of the page, the Export command does not output those bytes. The loader knows that it should load the code from address #C100.","using-bank-with-org#Using BANK with ORG":"Though the default address to compile the code is #C000, you can change it. For example, Bank #2 is paged into the #8000-#BFFF\nmemory range (slot 2), so it seems natural to use the #8000 address like this:\n.model Spectrum128\n; ...\n.bank 2\n.org #8000\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nAs you expect, this is the output:\n0000: call #8004  ; yellow\n0003: ret\n0004: ld a,#06    ; this is yellow (#8004)\n0006: out (#FE),a","using-bank-with-offset-and-org#Using BANK with offset and ORG":"You can combine the offset of the bank with ORG:\n.bank 2, #100\n.org #8000\n  call yellow\n  ret\nyellow:\n  ld a,6\n  out (#fe),a\n  ret\nThe output is probably different from the one you expect:\n0100: call #8004  ; yellow\n0103: ret\n0104: ld a,#06    ; this is yellow (#8004)\n0106: out (#FE),a\nAs you can see, the code stream is the same as in the previous case; however, here, the code starts at offset #100.","using-multiple-bank-directives#Using multiple BANK directives":"As you may need multiple memory banks in your program, you can use multiple BANK pragmas, like in this example:\n.bank 1\n; Here is the code for bank #1\n; ...\n.bank 3\n; Here is the code for bank #3\n; ...","restrictions-with-bank#Restrictions with BANK":"BANK cannot have a label.\nBANK cannot be used with the ZX Spectrum 48 model type.\nThe BANK value must be between 0 and 7\nThe offset must be between 0 and 16383\nYou can use the BANK pragma for a particular bank page only once, so, for example, the following code raises\nan error message:\n.bank 1\n; ...\n.bank 3\n; ...\n.bank 1 ; This line raises the error\n; ...\nNote: This is a temporary restriction. In the future, it may be removed.","the-equ-pragma#The EQU pragma":"The EQU pragma allows you to assign a value to an identifier. The label before EQU is the name of the identifier (or symbol), and the expression used in EQU is the variable's value. Here is a short example:\n      .org #6200\n      ld hl,Sym1\nSym1: .equ #4000\n      ld bc,Sym2\nSym2: .equ $+4\nThis sample is equivalent to this one:\n.org #6200\nld hl,#4000 ; Sym1 <-- #4000\nld bc,#620a ; Sym2 <-- #620a as an ld bc,NNNN operation and\n                       an ld hl,NNNN each takes 3 bytes","the-var-pragma#The VAR pragma":"The VAR pragma works similarly to EQU. However, while EQU does not allow the use of the same symbol with multiple value assignments, VAR assigns a new value to the symbol every time it is used.\nNote: The VAR pragma accepts extra syntax alternatives: =, :=","the-injectopt-pragma#The INJECTOPT pragma":"The INJECTOPT pragma expects an identifier-like option tag after the starting pragma keyword. This keyword identifies an option for injecting the code into an emulated machine. The Klive Assembler supports two options:","cursork#cursork":"When you run the ZX Spectrum virtual machine from the IDE, it injects the machine code into the memory and sets up the system as if you started the code from BASIC with the RUN command. By default, it sets the cursor to \"L\" mode.\nHowever, in several cases, you'd like to keep the cursor in \"K\" mode, for example, when you intend to start the code with the\nRANDOMIZE USER addr command (here, addr is the entry address). In this case, you can add the INJECTOP pragma to the code:\n.injectopt cursork","subroutine#subroutine":"This option instructs the IDE to call your code (terminated with RET) and not to jump directly to its start address.\nNote: You can use any other options; the compiler will not raise an exception; it ignores the unknown options.","the-defb-pragma#The DEFB pragma":"The DEFB pragma emits 8-bit expressions (bytes) from the current assembly position. Here is a sample:\n.org #6000\n.defb #01, #02, $, #04\nThe DEFB pragma will emit these four bytes starting at 0x6000: 0x01, 0x02, 0x03, 0x04.\nThe $ expression will emit 0x03, because, at the emission point, the current assembly address is 0x6003. The DEFB program considers only the rightmost 8 bits of any expression: this is how $ results in 0x03.\nDEFB has extra syntax variants: db, .db, DB, and .DB are accepted, too.","the-defw-pragma#The DEFW pragma":"The DEFW pragma is similar to DEFB, but it emits 16-bit values with LSB, MSB order.\n.defw #1234, #abcd\nThis simple code above will emit these four bytes: 0x34, 0x12, 0xcd, 0xab.\nDEFW has extra syntax variants: dw, .dw, DW, and .DW are accepted, too.","the-defm-pragma#The DEFM pragma":"The DEFM pragma emits the byte-array representation of a string. Each character in the string is replaced with the corresponding byte. Take a look at this code:\n.defm \"\\C by me\"\nHere, the DEFM pragma emits 7 bytes for the seven characters (the first escape sequence represents the copyright sign): 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0x65.\nDEFM has extra syntax variants: dm, .dm, DM, and .DM are accepted, too.","the-defn-pragma#The DEFN pragma":"The DEFN pragma works just like the DEFM pragma, but it emits an additional 0x00 byte to terminate the string. Look at this code:\n.defn \"\\C by me\"\nHere, the DEFN pragma emits 8 bytes for the seven characters (the first escape sequence represents the copyright sign) plus the terminating zero: 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0x65, 0x00.\nNote: DEFN has extra syntax variants: dn, .dn, DN, and .DN are also accepted.","the-defc-pragma#The DEFC pragma":"The DEFC pragma works just like the DEFM pragma, but it sets Bit 7 of the last emitted character. Look at this code:\n.defc \"\\C by me\"\nHere, the DEFC pragma emits 7 bytes for the seven characters (the first escape sequence represents the copyright sign) with Bit 7 of the last character (0x65) set (so it becomes 0xE5): 0x7f, 0x20, 0x62, 0x69, 0x20, 0x6d, 0xE5.\nNote: DEFC has extra syntax variants: dc, .dc, DC, and .DC are also accepted.","the-defh-pragma#The DEFH pragma":"The DEFH pragma uses a string with an even number of hexadecimal digits to emit a byte-array representation of the input. Each character pair in the string is replaced with the corresponding byte. Take a look at this code:\n.defh \"12E4afD2\"\nHere, the DEFH pragma emits 4 bytes: 0x12, 0xe4, 0xaf, 0xd2.\nNote: DEFH has extra aliases: dh, .dh, DH, and .DH.","the-defs-pragma#The DEFS pragma":"You can emit zero (0x00) bytes with this pragma. It accepts a single argument, the number of zeros to emit. This code sends 16 zeros to the generated output:\n.defs 16\nNote: DEFS has extra syntax variants: ds, .ds, DS, and .DS are also accepted.","the-fillb-pragma#The FILLB pragma":"With FILLB, you can emit a particular count of a specific byte. The first argument of the pragma sets the count, and the second specifies the byte to emit. This code emits 24 bytes of #A5 values:\n.fillb 24,#a5","the-fillw-pragma#The FILLW pragma":"With FILLW, you can emit a particular count of a 16-bit word. The first argument of the pragma sets the count, and the second specifies the word to emit. This code emits 8 words (16 bytes) of #12A5 values:\n.fillw 8,#12a5\nOf course, the bytes of a word are emitted in LSB/MSB order.","the-skip-pragma#The SKIP pragma":"The SKIP pragma, as its name suggests, skips the number of bytes from the current address to that specified in the first argument. It fills up the skipped bytes with 0xFF by default, but the fill value can be set with the second argument:\n.skip $+#05      ; fills next 5 bytes with 0xFF\n.skip $+#04, #3a ; fills next 4 bytes with 0x3A","the-extern-pragma#The EXTERN pragma":"The EXTERN pragma is kept for future extension. The current compiler accepts it but does not act when observing this pragma.","the-model-pragma#The MODEL pragma":"This pragma is used when you run or debug your Z80 code within the emulator. With Spectrum 128K, Spectrum +3, and Spectrum Next models, you can run the Z80 code in different contexts. The MODEL pragma lets you specify which model to run the code. You can use the SPECTRUM48, SPECTRUM128, SPECTRUMP3, or NEXT identifiers to choose the model (identifiers are case-insensitive):\n.model Spectrum48\n.model Spectrum128\n.model SpectrumP3\n.model Next\nFor example, when you create code for Spectrum 128K, and add the .model Spectrum48 pragma to the code, the Run command will start the virtual machine, turn the machine into Spectrum 48K mode, and ignite the code just after that.\nNote: With the #ifmod and #ifnmod directives, you can check the model type. For example, the following Z80 code results in a green background on Spectrum 48K and cyan on Spectrum 128K:\n    .model Spectrum48\n#ifmod Spectrum128\n    BorderColor: .equ 5\n    RetAddr: .equ #2604\n#else\n    BorderColor: .equ 4\n    RetAddr: .equ #12a2\n#endif\nStart:\n    .org #8000\n    ld a,BorderColor\n    out (#fe),a\n    jp RetAddr","the-align-pragma#The ALIGN pragma":"This pragma allows you to align the current assembly counter to the specified byte boundary. You can use this pragma with an optional expression. Look at these samples:\n.org #8000\n    nop\n.align 4\n    nop\n.align\nThe first pragma aligns the assembly counter to #8004, the next 4-byte boundary. With no value specified, .align uses #100, and thus the second .align in the sample sets the current assembly counter to the next page boundary, #8100.","the-trace-and-tracehex-pragmas#The TRACE and TRACEHEX pragmas":"These pragmas send trace information to the assembler output. In the Visual Studio IDE, these messages are displayed in the Z80 Build Output pane. List one or more expressions separated by a comma after the .trace token. TRACEHEX works like TRACE, but it displays integer numbers and strings in hexadecimal format.Let's assume you add these lines to the source code:\n.trace \"Hello, this is: \", 42\n.tracehex \"Hello, this is: \", 42\nWhen you compile the source, the lines above display these messages:\nTRACE: Hello, this is: 42\nTRACE: 48656C6C6F2C20746869732069733A20002A","the-rndseed-pragma#The RNDSEED pragma":"With the rnd() function, you can generate random numbers. The RNDSEED pragma sets the seed value to use for random number generation. If you use this pragma with an integer expression,\nthe seed is set to the value of that expression. If you do not provide the expression, the compiler uses the system clock to set up the seed.\n.rndseed ; sets the seed according to the system clock\n.rndseed 123 ; sets the seed to 123","the-defgx-pragma#The DEFGX pragma":"This pragma helps you define bitmaps in the code. This pragma excepts a string expression and utilizes that string as a pattern to generate bytes for the bitmap.\nNote: DEFGX has extra syntax variants: dgx, .dgx, DGX, and .DGX are accepted, too.\nIf the very first character of the string pattern is <, the pattern is left aligned and starts with the second character. Should the first character be >, the pattern is right aligned and starts with the second character. By default (if no < or > is used) the pattern is left-aligned.Spaces within the pattern are ignored and considered helpers. Other characters are converted into bits one by one.Before the conversion, the pragma checks if the pattern constitutes multiples of 8 bits. If not, it uses zeros as prefixes (right-aligned) or zeros as suffixes (left-aligned), so the pattern would be adjusted to contain entire bytes.The . (dot), - (dash), and _ (underscore) sign 0, and any other characters stand for 1. Every 8 bits in the pattern emit a byte.Here are a few samples:\n.dgx \"....OOOO\"         ; #0F\n.dgx \">....OOOO\"        ; #0F\n.dgx \"<----OOOO\"        ; #0F\n.dgx \"___OOOO\"          ; #1E\n.dgx \"....OOOO ..OO\"    ; #0F, #30\n.dgx \">....OO OO..OOOO\" ; #03, #CF","the-defg-pragma#The DEFG pragma":"This pragma helps you define bitmaps in the code. This pragma excepts a string pattern (note: not a string expression!)\nand utilizes that string as a pattern to generate bytes for the bitmap.\nNote: DEFG has extra syntax variants: dg, .dg, DG, and .DG are also accepted.\nSpaces within the pattern are ignored and considered helpers. Other characters are converted into bits one by one. The pixels in a byte are planted with the LSB as the most significant bit, and multiple bytes are planted LSB byte first.The . (dot), - (dash), and _ (underscore) sign 0, and any other characters stand for 1. Every 8 bits in the pattern emit a byte.Here are a few samples:\n.dg ....OOOO        ; #0F\n.dg ___OOOO         ; #1E\n.dg ....OOOO ..OO\"  ; #0F, #30\n.dg ....OO OO..OOOO ; #0F, #3C\nNote: Unlike in the pattern used with DEFGX, here, the leading > and < characters are taken as bit 1. They do not specify bit alignment.","the-error-pragma#The ERROR Pragma":"You can raise custom error messages with this pragma. ERROR accepts an expression and displays an error message with code Z0500 using your provided text. Here is a sample:\n.error \"The value must be greater than\" + str(minvalue)","the-includebin-pragma#The INCLUDEBIN Pragma":"You can include a binary file into the source code to emit all bytes as if you used the .defb pragma. You can include the entire file or a single segment of it. The pragma has a mandatory argument, the name of the binary file to include, and two optional ones, the start offset of the segment and its length, respectively. Let's see a few examples:\n.includebin \"./myfile.bin\"\n.includebin \"./myfile.bin\" 2\n.includebin \"./myfile.bin\" 2, 3\nThis snippet loads the myfile.bin file from the same directory that contains the source\nwith the .includebin directive.Let's assume that myfile.bin contains these bytes:\n#00, #01, #02, #03, #04, #05, #06, #07 \nThe three lines of code above are the same as if we had written these code lines:\n.defb #00, #01, #02, #03, #04, #05, #06, #07 ; .includebin \"./myfile.bin\"\n.defb #02, #03, #04, #05, #06, #07           ; .includebin \"./myfile.bin\" 2\n.defb #02, #03, #04                          ; .includebin \"./myfile.bin\" 2, 3\nNote: The compiler does not allow negative file offset or length. It else raises an error if you define a segment that does not fit into the binary file. You can use an alternative syntax for .includebin. The compiler accepts these tokens and their uppercase versions, too: includebin, .include_bin, and include_bin.","the-comparebin-pragma#The COMPAREBIN pragma":"When re-engineering a Z80 program from an exported disassembly, it is good to know that you do not break the original code. The .comparebin pragma helps you to check that you still compile what you expect. It loads a binary file and compares that file with the output of the current code segment.The pragma has a mandatory argument, the name of the binary file to include, and two optional ones, the start offset of the segment and its length, respectively. Let's see a few examples:\n.comparebin \"./myfile.bin\"\n.comparebin \"./myfile.bin\" 2\n.comparebin \"./myfile.bin\" 2, 3\nNote: The compiler does not allow negative file offset or length. It also raises an error if you define a segment that does not fit into the binary file. You can use alternative syntax for .comparebin. The compiler accepts these tokens, too: comparebin, .COMPAREBIN, and COMPAREBIN.\nWhen you compile the code, every .org pragma opens a new segment that starts from the point defined by .org.You can put it into the code in as many places as you want. As the compiler parses the code, it records the positions of .comparebin pragmas, the current output segment, and its length at the point where .comparebin is used. When the code compilation is ready, and there are no errors, the compiler executes a check. This check compares the emitted bytes with the recorded length to the bytes in the binary file.\nIf the length of the segment is greater than the size of the file, the compiler raises an error.\nThe comparison checks only the as many bytes as are in the output segment; if more are in the binary file, the remaining data is ignored.\nIf the compared data do not match, the assembler raises an error with the first unmatching position.\nLet's assume we have the origin.bin file that contains these six bytes:\n#00, #01, #02, #03, #04, #05\nTake a look at this code:\n  .org #8000\n  .defb #00, #01, #02\n  .comparebin \"origin.bin\"\n  .org #8100\n  .defb #03, #04, #05\n  .comparebin \"origin.bin\"\n  .comparebin \"origin.bin\", 3\nThis code contains two segments (it has two .org pragmas) and three .comparebin.\nThough origin.bin has six bytes, the first comparison succeeds, utilizing only the three bytes emitted in the first segment.\nThe second comparison fails, as the file starts with #00, #01, #02, while the segment emits #03, #04, and #05.\nThe third comparison succeeds, as it starts the examination from the 4th byte (offset 3) of the binary file.","the-onsuccess-pragma#The ONSUCCESS pragma":"This pragma declares an interactive Klive command that is executed when the code is successfully compiled. The argument of the pragma is a string literal that defines the command text (with its parameters) to execute.You can put this pragma anywhere in the source code and use multiple pragmas. The compiler collects them and executes the commands in their declaration order.Here is a sample:\n.onsuccess \"expc mycode.tap\""}},"/z80-assembly/statements":{"title":"Assembler Statements","data":{"":"Statements are Klive Assembler-specific control flow constructs. â€” thanks again for the inspiration by Simon Brattel â€” that instruct the compiler about loop-like and conditional compilation.\nNote: While directives help you to organize your code and include code files optionally according to the compilation context, statements provide you with more valuable tools to shorten the way you can declare Z80 assembly code.\nEach statement can be written with a leading dot or without it, and the compiler accepts both lowercase and uppercase versions. For example, all of these versions are valid: .if, if, .IF, and IF.","the-loop-block#The LOOP Block":"With the LOOP block, you can organize a cycle to emit code. Here is a sample that tells the gist:\n.loop 6\n  add hl,hl \n.endl\nThis construct is a shorter way to multiply HL with 64. It is equivalent to the following code:\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\n  add hl,hl\nThe .loop statement accepts an expression. The compiler repeats the instructions within the\nloop's body according to the value of the expression. The .endl statement marks the end of the loop.\nNote: You can use many flavors for the .endl block closing statement. .endl, endl, .lend, lend are all accepted â€” with uppercase letters, too.\nLook at this code:\ncounter .equ 2\n; do something (code omitted)\n.loop counter + 1\n  .db #80, #00\n.endl\nThis code is as if you wrote this:\n  .db #80, #00\n  .db #80, #00\n  .db #80, #00","the-loop-scope#The LOOP Scope":"The .loop statement declares a scope for all labels, symbols, and variables in the loop's body. Every iteration has its separate local scope. When the assembler resolves symbols, it starts from the loop's scope and tries to resolve the symbol's value. If the lookup fails, it steps out to\nthe outer scope, and goes on with the resolution.Check this code:\nvalue .equ 2\n; do something (code omitted)\n.loop 2\n    value .equ 5\n    ld a,value\n.endl\nThe compiler takes it into account as if you wrote this:\n    ld a,5\n    ld a,5\nThe value symbol declared within the loop overrides value in the outer scope, and thus, 5 is used instead of 2.Nonetheless, when you utilize a different construct, it seems a bit strange at first:\nvalue .equ 2\n; do something (code omitted)\n.loop 2\n    ld a,value\n    value .equ 5\n    ld b,value\n.endl\nThe strange thing is that the compiler creates this:\n    ld a,2\n    ld b,5\n    ld a,2\n    ld b,5\nWhen the assembler resolves value in the ld a,value instruction, if finds value in the outer scope only, as it is not declared yet within the loop's scope. In the ld b,value instruction value gets resolved from the inner scope and takes 5.","variables-and-scopes#Variables and Scopes":"Unlike symbols that work as constant values, variables (declared with the .var pragma or its syntactical equivalents, the = or := tokens) can change their values.Take a look at this code:\ncounter = 4\n.loop 3\n    innercounter = 4\n    ld a,counter + innercounter\n    counter = counter + 1\n.endl\nHere, the counter variable is defined in the global scope (out of the loop's scope), while innercounter in the local scope of the loop. When evaluating the counter = counter + 1 statement, the compiler finds counter in the outer scope, so it uses that variable to increment its value. This code emits machine code for this source:\nld a,#08\nld a,#09\nld a,#0A\nNow, add a single line to the loop's code:\ncounter = 4\n.loop 3\n    innercounter = 4\n    ld a,counter + innercounter\n    counter = counter + 1\n.endl\nld b,innercounter\nThe compiler will not compile this code, as it cannot find the value for innercounter in the ld b,innercount instruction. Because innercounter is defined in the local scope of the loop, this scope is immediately disposed as the loop is completed. When the compiler processes the ld b,innercounter instruction, the local scope is not\navailable.","labels-and-scopes#Labels and Scopes":"Labels behave like symbols, and they work similarly. When you create a label within a loop, that label is created in\nthe local scope of the loop. The following code helps you understand which labels are part of the global scope and which are created in the loop's scope:\n.org #8000\nMyLoop: .loop 2\n    ld bc,MyLoop\nInner: \n    ld de,MyEnd\n    ld hl,Inner\n    ld ix,Outer\nMyEnd: .endl\nOuter: nop\nThe label of the .loop statement is part of the outer (global) scope, just like the label that follows the\n.endl statement. However, all labels declared within the loop's body, including the label of the .endl statement, belong to the local scope of the loop.Thus, the compiler translates the code above into this one:\n         (#8000): ld bc,#8000 (MyLoop)\nInner_1  (#8003): ld de,#800D (MyEnd_1)\n         (#8006): ld hl,#8003 (Inner_1)\n         (#8009): ld ix,#801A (Outer)\nMyEnd_1  (#800D): ld bc,#8000 (MyLoop)\nInner_2  (#8010): ld de,#801A (MyEnd_2)\n         (#8013): ld hl,#8010 (Inner_2)\n         (#8016): ld ix,#801A (Outer)\nMyEnd_2\nOuter    (#801A): nop\nHere, Inner_1, Inner_2, MyEnd_1, and MyEnd_2 represent the labels created in the local scope of the loop. The _1 and _2 suffixes indicate that each loop iteration has a separate local scope. As you can see, the last iteration of MyLabel points to the first outer address (Outer label).","nesting-loops#Nesting LOOPs":"Of course, you can nest loops, such as in this code:\n.loop 3\n  nop\n  .loop 2\n    ld a,b\n  .endl\n  inc b\n.endl\nThis code snippet translates to this:\nnop\nld a,b\nld a,b\ninc b\nnop\nld a,b\nld a,b\ninc b\nnop\nld a,b\nld a,b\ninc b\nWhen you nest loops, each loop has its separate scope.","the-cnt-value#The $CNT value":"It is handy to use the $cnt value that represents the current loop counter. It starts from 1 and increments to the maximum number of loops. This sample demonstrates how you can use it:\n.loop 2\n  outerCount = $cnt\n  .loop 3\n     .db #10 * outerCount + $cnt\n  .endl\n.endl\nThis code translates to this:\n.db #11\n.db #12\n.db #13\n.db #21\n.db #22\n.db #23\nYou can observe that each loop has its separate $cnt value.\nNote: The $cnt value has several syntax versions that the compiler accepts: $CNT, .cnt, and .CNT.","the-procendp-block#The PROC..ENDP Block":"In the previous section, you could understand how labels and scopes work for the .loop statement. You can utilize this scoping mechanism with the help of the .proc...endp statement. This sample code demonstrates the concepts (just as you learned earlier):\n.org #8000\nMyLabel:\n  ld de,Outer\n  ld hl,Mylabel\n  call MyProc\n  halt\nMyProc: \n  .proc\n    ld bc,MyProc\n  MyLabel: \n    ld de,MyEnd\n    ld hl,MyLabel\n    ld ix,Outer\n    ret\nMyEnd:\n    .endp\nOuter: nop\nThe first MyLabel label belongs to the global scope, while the second (within MyProc) to the local scope of the procedure wrapped between .proc and endp. MyProc belongs to the global scope, too, however, MyEnd is part of the MyProc scope, so it is visible only from\nwithin the procedure.The assembler emits this code:\nMyLabel  (#8000): ld de,#8018 (Outer)\n         (#8003): ld hl,#8000 (MyLabel)\n         (#8006): call #800A (MyProc)\n         (#8009): halt\nMyProc   (#800A): ld bc,#800A (MyProc)\nMyLabel_ (#800D): ld de,#8018 (MyEnd)\n         (#8010): ld hl,#800D (MyLabel_)\n         (#8013): ld ix,#8018 (Outer)\n         (#8017): ret\nMyEnd\nOuter    (#8018): nop\nYou can nest PROC blocks just as LOOP blocks. Each PROC block has its private scope. When the compiler sees a PROC block, it works as if you wrote .loop 1.\nNote: PROC is different than a loop. You cannot use the $cnt value. Similarly, the break and continue instructions are unavailable within a PROC block.\nNote: The assembler accepts these aliases for PROC and ENDP: .proc, proc, .PROC, PROC, .endp, .ENDP, endp, ENDP, .pend, .PEND, pend, and PEND.","the-repeatuntil-block#The REPEAT..UNTIL Block":"While the .loop statement works with an expression that specifies the loop counter, the .repeat...until block uses an exit condition to create more flexible loops. Here is a sample:\ncounter = 0\n.repeat \n    .db counter\n    counter = counter + 3\n.until counter % 7 == 0\nThe counter % 7 == 0 condition specifies when to exit the loop. Because the exit condition is examined only at the end of the loop, the .repeat blocks execute at least once.The sample above translates to this:\n.db 0\n.db 3\n.db 6\n.db 9\n.db 12\n.db 15\n.db 18\nThe .repeat block uses the same approach to handle its local scope, symbols, labels, and variables as the .loop block. The block also provides the $cnt loop counter that starts from 1 and increments in every loop cycle.This sample demonstrates the .repeat block in action:\n.org #8000\ncounter = 0\n.repeat \n    .db low(EndLabel), high(Endlabel), $cnt\n    counter = counter + 3\nEndLabel: .until counter % 7 == 0\nThe compiler translates the code to this:\n.db #03, #80, #01\n.db #06, #80, #02\n.db #09, #80, #03\n.db #0C, #80, #04\n.db #0F, #80, #05\n.db #12, #80, #06\n.db #15, #80, #07","the-whileendw-block#The WHILE..ENDW Block":"With .while loop, you can create another kind of block, which uses an entry condition. For example, the following code snippet generates instructions to create the sum of numbers from 1 to 9:\ncounter = 1\n    ld a,0\n.while counter < 10\n    add a,counter\n    counter = counter + 1\n.endw\nThe .while...endw block uses an entry condition declared in the .while statement. Provided this condition is true, the compiler enters into the body of the loop and compiles all instructions and statements\nuntil it reaches the .endw statement. The body of the loop may never be reached.The compiler translates the code snippet above to the following:\nld a,0\nadd a,1\nadd a,2\nadd a,3\nadd a,4\nadd a,5\nadd a,6\nadd a,7\nadd a,8\nadd a,9\nLike the .loop and the .repeat blocks, .while uses the same approach to handle its local scope, symbols, labels, and variables. This block also provides the $cnt loop counter that starts from 1 and increments in every loop cycle.This code demonstrates the .while block with labels and using the $cnt value:\ncounter = 0\n.while counter < 21 \n    .db low(EndLabel), high(Endlabel), $cnt\n    counter = counter + 3\nEndLabel: .endw\nThe compiler translates the code to this:\n.db #03, #80, #01\n.db #06, #80, #02\n.db #09, #80, #03\n.db #0C, #80, #04\n.db #0F, #80, #05\n.db #12, #80, #06\n.db #15, #80, #07\nNote: You can use many flavors for the .endw block closing statement. .endw, endw, .wend, and wend are all accepted â€” with uppercase letters, too.","the-fornext-loop#The FOR..NEXT Loop":"You can use the traditional .for...next loop to create a loop:\n.for myVar = 2 .to 5\n  .db 1 << int(myVar)\n.next\nThis loop uses the myVar variable as its iteration variable, which iterates from 1 to 4. As you expect, the compiler translates the for-loop into this:\n.db #04\n.db #08\n.db #10\n.db #20\nYou can specify a .step close to change the loop increment value:\n.for myVar = 1 .to 7 .step 2\n  .db 1 << int(myVar)\n.next\nNow, the code translates to this:\n.db #02\n.db #08\n.db #20\n.db #80\nYou can create a loop with decrementing iteration variable value:\n.for myVar = 7 .to 1 .step -2\n  .db 1 << int(myVar)\n.next\nAs you expect, now you get this translation:\n.db #80\n.db #20\n.db #08\n.db #02\nNote: As with the other statements, you can use the .for, .to, and .step keywords without the . prefix, so for, to, and step are also valid.\nThe for-loop can do the same stunts as the other loops; it handles labels, symbols, and variables similarly. There's only one exception: the loop iteration variable. If this variable is found in an outer scope, instead of using that value, the compiler raises an error. You can use the for-loop only with a freshly created variable.So, both cases in this code raise an error:\nmyVar = 0\n.for myVar = 1 .to 4 ; ERROR: Variable myVar is already declared\n  ; ...\n.next\n.for _i = 1 .to 3\n  .for _i = 3 .to 8 ; ; ERROR: Variable _i is already declared\n    ; ...\n  .next\n.next\nNote: As i is a reserved token (it represents the I register), you cannot use i as a variable name. Nonetheless, _i is a valid variable name.\nThe for-loop works with both integer and float variables. If the initial value, the last value (the one after .to), or the increment value (the one after .step) is a float value, the for-loop uses float operations; otherwise, it uses integer operations.This code snippet demonstrates the difference:\n.for myVar = 1 .to 4 .step 1\n  .db 1 << myVar\n.next\n.for myVar = 1 .to 4 .step 1.4\n  .db 1 << myVar ; ERROR: Right operand of the shift left operator must be integral\n.next\nNonetheless, you can solve this issue by applying the int() function:\n.for myVar = 1 .to 4 .step 1.4\n  .db 1 << int(myVar) ; Now, it's OK.\n.next\nNote: You can still use the $cnt value in for loops. Just like with other loops, it indicates the count of cycles starting from one and incremented by one in each iteration.","maximum-loop-count#Maximum Loop Count":"It's pretty easy to create an infinite (or at least a very long) loop. For example, these loops are infinite ones:\n.repeat\n.until false\n.while true\n.wend \nThe assembler checks the loop counter during compilation. Whenever it exceeds #FFFF (65535), it raises an error.","the-ifelifelseendif-statement#The IF..ELIF..ELSE..ENDIF Statement":"You can use the .if statement to create branches with conditions. For example, this code emits inc b or inc c statement depending on whether the value of branch is even or odd:\n.if branch % 2 == 0\n  inc b\n.else\n  inc c\n.endif\nYou do not have to specify an .else branch, so this statement is entirely valid:\n.if branch % 2 == 0\n  inc b\n.endif\nYou can nest if statements like this to manage four different code branches according to the value of branch:\n.if branch == 1\n  inc b\n.else\n  .if branch == 2\n    inc c\n  .else \n    .if branch == 3\n      inc d\n    .else\n      inc e\n    .endif\n  .endif\n.endif\nNonetheless, you can use the .elif statement to create the code snippet above more clearly:\n.if branch == 1\n  inc b\n.elif branch == 2\n  inc c\n.elif branch == 3\n  inc d\n.else\n  inc e\n.endif","if-and-scopes#IF and Scopes":"Unlike the loop statements, .if does not provide its local scope. Whenever you create a symbol, a label, or a variable, those get into the current scope. This code defines a label with the same name in each branch. Because the compiler evaluates the .if branches from top to down, it either compiles one of the .elif branches â€”\nthe first with a matching condition â€” or the else branch. Thus, this code does not define MyLabel twice:\nbranch = 4 ; Try to set up a different value\n; Do something (omitted from code)\n    ld hl,MyLabel\n.if branch == 1\n  inc b\n  MyLabel ld a,20\n.elif branch > 2\n  MyLabel ld a,30\n  inc c\n.elif branch < 6\n  inc d\n  MyLabel ld a,40\n.else\n  MyLabel ld a,50\n  inc e\n.endif\nGenerally, you can decorate any statement with labels. The .elif and .else statements are exceptions. If you do so, the compiler raises an error:\n.if branch == 1\n  inc b\n  MyLabel ld a,20\n.elif branch > 2\n  MyLabel ld a,30\n  inc c\nOther .elif branch < 6 ; ERROR: ELIF section cannot have a label\n  inc d\n  MyLabel ld a,40\nAnother .else          ; ERROR: ELSE section cannot have a label\n  MyLabel ld a,50\n  inc e\n.endif","if-nesting#IF Nesting":"When you nest .if statements, ensure each has a corresponding .endif. Whenever the compiler finds an .endif, it associates it with the closest .if statement before .endif. Use indentation to make the structure more straightforward, as the following code snippet shows:\nrow = 2\ncol = 2\n; Change row and col (omitted from code)\n.if row == 0\n  .if col == 0\n    .db #00\n  .elif col == 1\n    .db #01\n  .else\n    .db #02\n  .endif\n.elif row == 1\n  .if col == 0\n    .db #03\n  .elif col == 1\n    .db #04\n  .else\n    .db #05\n  .endif\n.elif row == 2\n  .if col == 0\n    .db #06\n  .elif col == 1\n    .db #07\n  .else\n    .db #08\n  .endif\n.else\n  .if col == 0\n    .db #09\n  .elif col == 1\n    .db #0A\n  .else\n    .db #0B\n  .endif\n.endif","the-ifusedifnused-statements#The IFUSED/IFNUSED Statements":"Klive offers a similar construct to IF..ELIF..ELSE..ENDIF, using the IFUSED or IFNUSED statement instead of IF. These new statements are specialized forms of IF. You can use these statements to emit code depending on whether a symbol (label, .EQU, .VAR, structure, or structure field) exists and has already been used by the code preceding the IFUSED/IFNUSED statement.Here are a few examples:\nMyProc:\n  ld hl,#5800\n  ld (hl),a\n  ret\n  ; some other code\n  .ifused MyProc\n    MyMsg: .defn \"MyProc is used\"\n  .else\n    MyMsg: .defn \"MyProc is not used\"\n  .endif\nMain:\n  ld hl,MyMsg\nHere, the .ifused statement will set the string the MyMsg label point to according to whether the MyProc label is used. As in this case, MyProc is defined but not invoked before the .ifused statement, HL will point to the \"MyProc is not used\" message.Should you call MyProc before .ifused, HL would point to the other message, \"MyProc is used\":\nMyProc:\n  ld hl,#5800\n  ld (hl),a\n  ret\n  ; some other code\n  call MyProc\n  ; some other code\n  .ifused MyProc\n    MyMsg: .defn \"MyProc is used\"\n  .else\n    MyMsg: .defn \"MyProc is not used\"\n  .endif\nMain:\n  ld hl,MyMsg\nThe .ifnused statement is the complement of .ifused. It is evaluated to a true condition value only if the symbol following .ifnused is not defined or, if defined, is not used.","ifusedifnused-syntax#IFUSED/IFNUSED Syntax":"You must specify a symbol after the .ifused  or .ifnused keywords. These symbols must follow the syntax of identifiers. They can be compound names used for modules and structures. So, all of these symbol names are correct:\nMyLabel\nMyStruct\nMyStruct.FieldX\nMyModule.Main\n::NestedModule.Start.MyProc\nNote: You can use these aliases for .ifused: .IFUSED, ifused, IFUSED. Similarly, .ifnused accept alternative tokens: .IFNUSED, ifnused, and IFNUSED.","ifusedifnused-semantics#IFUSED/IFNUSED Semantics":"The Klive Assembler accepts any .ifused and .ifnused statements until they are syntactically correct. When the assembler tests their condition, it works this way:\nIf the specified symbol does not exist, .ifused evaluates to false, while .ifnused evaluates to true.\nIf the particular symbol exists and is used in the code section preceding the .ifused or .ifnused statement, .ifused evaluates to true, and .ifnused to false.\nIf the particular symbol exists and it is not used in the code section preceding the .ifused or .ifnused statement, .ifused evaluates to false, .ifnused to true.\nThese statements do not support the look-ahead in the code. This behavior could lead to paradoxical situations, like in this example:\nMyFlag = true\nMyValue: .equ #1234\n  ; some other code that does not use MyValue\n  .ifused MyValue\n    MyFlag = false;\n  .endif\n  ; some other code that does not change MyFlag\n  .if MyFlag\n    ld a,MyValue\n  .endif\nShould .ifused work with look-ahead, this code would make the compiler scratch its virtual head. Because MyFlag is set to true, the .if statement at the bottom of the code would emit an ld a,MyValue instruction. The compiler would say that .ifused MyValue should be considered true. However, in this case, the body .ifused would set MyFlag to true, and that would prevent the bottom .if from emitting ld a,MyValue, and then MyValue would not be used at all.","block-statements-without-a-closing-statement#Block Statements without a Closing Statement":"The compiler automatically recognizes if a block does not have a closing statement and provides an error message accordingly.","orphan-closing-statements#Orphan Closing Statements":"When the compiler finds a closing statement (such as .endw, .endl, .until, .endif, etc.) it will issue an error.","the-break-statement#The BREAK statement":"You can exit the loop â€” independently of the loop's exit condition â€” with the .break statement:\n; LOOP sample\n.loop 5\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.endl\n; REPEAT sample\n.repeat\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.until $cnt == 5\n; WHILE sample\n.while $cnt < 5\n  .if $cnt == 4\n    .break\n  .endif\n  .db $cnt\n.endw\n; FOR-loop sample\n.for value = 1 to 5\n  .if value == 4\n    .break\n  .endif\n  .db value\n.next\nBecause all these loops are exited at the beginning of the 4th iteration, they produce this output:\n.db #01\n.db #02\n.db #03\nNote: You cannot use the .break statement outside a loop construct. If you do so, the compiler raises an error.","the-continue-statement#The CONTINUE Statement":"You can interrupt the current iteration of the loop and carry on the next iteration with the .continue statement:\n; LOOP sample\n.loop 5\n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.endl\n; REPEAT sample\n.repeat\n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.until $cnt == 5\n; WHILE sample\n.while $cnt <= 5 \n  .if $cnt == 4\n    .continue\n  .endif\n  .db $cnt\n.endw\n; FOR-loop sample\n.for value = 1 to 5\n  .if value == 4\n    .continue\n  .endif\n  .db value\n.next\nBecause all these loops skip the 4th iteration, they produce this output:\n.db #01\n.db #02\n.db #03\n; #04 is skipped\n.db #05\nNote: You cannot use the .continue statement outside of a loop construct. If you do so, the Assembler raises an error."}},"/z80-assembly/structs":{"title":"Structures","data":{"":"Klive allows you to use structure definitions and placements in your Z80 programs. If you know the struct construct from C, C++, or C#, the concept in Z80 is only partly similar.","understanding-structures#Understanding Structures":"In Klive Assembler, a structure definition is a placeholder that defines a byte pattern like this:\nObject2D: .struct\n    .defw 0\n    .defw 0\n    .defb 1\n    .defb 1\n  .ends\nThis definition says that Object2D is a structure of six bytes (two 16-bit words and two 8-bit bytes) with the following bytes emitted: #00, #00, #00, #00, #01, #01. Whenever you place a structure declaration in a program, just like in this sample, the assembler will emit the bytes you specified in the .struct definition:\n  Object2D() ; emits #00, #00, #00, #00, #01, #01\nAs you can see, six subsequent bytes do not tell enough about the semantics of Object2D. When we created this structure, the original concept was to use two 16-bit numbers to specify the X and Y coordinates of the object, plus two 8-bit numbers to describe its horizontal and vertical velocity. With field definitions (see X, Y, DX, and DY), the meaning of Object2D is more straightforward than it was before:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nOf course, we would like to initialize objects with different states. With field initializers, we can define structures with initial states that are different from the .struct definition:\nApple: Object2D()\n  X -> .defw 100\n  Y -> .defw 100\nPear: Object2D()\n  DX -> .defb -1\n  DY -> .defb -1\n  ; Some other code\n  ; ...\n  ld hl,Apple\n  ld de,Pear\nIn this sample, the Apple label (that the code later loads into HL) points to an Object2D declaration that holds 100 in its X and Y values. Another label, Pear, points to a different instance of Object2D (later, the code loads that address into DE). Pear has a converse velocity compared to Apple.The Assembler allows you to initialize structures with any pragma that emits bytes to the assembly output. For example, the following code snippet sets a new Object2D structure in a particular way:\nBanana: Object2D()\n  -> .defb 10, 1\n  -> .defb 12, 2\n  DX -> .defb 2, 2\nThe first .defb pragma (right after the first ->) emits two bytes, 10 and 1, respectively, and it sets the X field to 266 (10 + 1256). The second .defb sets Y to 524 (12 * 2256). The initialization of DX (DX -> .defb 2, 2) emits two bytes and sets both DX and DY to 2.","structure-definition#Structure Definition":"You can define structure between the .struct and .ends  statements. Each structure must have a unique name to declare with a label. The compiler accepts all of these definitions:\n; Version #1\nMyStruct .struct\n  ; ...\n  .ends\n; Version #2\nMyStruct: .struct\n  ; ...\n  .ends\n; Version #3\nMyStruct\n  .struct\n  ; ...\n  .ends\n; Version#4\nMyStruct:\n  .struct\n  ; ...\n  .ends\nNonetheless, it raises an error if you do not name the structure:\n.struct ; ERROR: .struct must have a name\n; ...\n.ends\nNote: The assembler accepts the following alternative keywords for .struct: .STRUCT, struct, or STRUCT. Similarly, .ends has these aliases, too: .ENDS, ends, and ENDS. Though you can define an empty structure, there is no practical reason to do so.\nIn the body of the structure, you can use only one of these byte-emitter pragmas: .defb, .defw, .defm, .defn, .defc, .defs, .fillb, .fillw, .defg,  or .defgx. If you try to use any other construct, the compiler raises an error message.As you saw earlier, you can specify field labels within the structure body. The assembler is flexible: you can omit field labels or even use multiple labels for a single field:\nObject2D_A: .struct\n  Coords:\n    X: .defw 0\n    Y: .defw 0\n  Velocity:\n    .defb 1\n    .defb 1\n  .ends\nHere, Object2D_A has two field name for the first .defw field, Coords, and X, respectively. The last .defb does not have its field name, unlike the one before, Velocity.","labels-and-field-names#Labels and Field Names":"The label assigned to the .struct definition has a dual role. When used in a structure initialization (for example, as Object2D is utilized in the Object2D() initializer), it identifies the structure. Nonetheless, you can use the label name in Z80 instructions, too. In this case, the label's value is the size of the structure. For example, these instructions are equivalent, as the size of the Object2D structure is six bytes:\nld a,Object2D ; Size of Object2D\n; ...\nld a,6 ; \nYou can allocate a memory block for 100 uninitialized instances of Object2D with this pragma:\nMy100Objects:\n  .defs 100 * Object2D\nNote: You cannot assign a label to the .ends statement. If you do, the compiler throws an error.\nLabels assigned to the body of the .struct definition are used as field names. You can use them only with the structure name:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nApple: Object2D()\n  ; ...\n  ld hl,Apple + Object2D.DX\n  ld a,(hl)\nField label values contain the offset of the particular field from the beginning of the structure. Thus, the last two instructions in the code above load the content of the Apple structure's DX field into A.According to these definitions, here are the field label values of Object2D:\nObject2D.X: 0\nObject2D.Y: 2\nObject2D.DX: 4\nObject2D.DY: 5","structure-initialization#Structure initialization":"The .struct definition does not emit any code; it just tells the compiler the layout and initial contents of a structure. To allocate space for a particular structure, you need to initialize it with the name of the structure plus a pair of opening and closing parentheses, just like these samples show:\n; Initalize an Object2D\nMyObject: Object2D()\n; Initialize another one\nOtherObject: Object2D()\nWhen you add a label to the structure initialization, that label's value points to the beginning of the structure in the memory.\nstart: .org #8000\nDistanceEntry:\n  .struct\n    Address: .defw $\n    SeqNo: .defb Index\n  .ends\nData: .org #9000\nIndex = 1;\nEntry1:\tDistanceEntry()\nIndex = 2;\nEntry2:\tDistanceEntry()\nIndex = 3;\nEntry3:\tDistanceEntry()\nThe compiler emits the initialization code for Entry1, Entry2, and Entry3 as if you wrote this:\nData .org #9000\nEntry1:\n  .defw #9000\n  .defb 1\nEntry2:\n  .defw #9003\n  .defb 2\nEntry3:\n  .defw #9006\n  .defb 03","field-initializers#Field Initializers":"Field initializers can be used to change the default structure initializer. A field initializer has this syntax:[identifier] -> byte-emitter-pragmaFor a moment, let's forget that identifier is optional. When you use it, it must be one of the structure's field names. The byte-emitter-pragma is one of the Klive pragmas you can use to define a structure body, namely these:  .defb, .defw, .defm, .defn, .defc, .defs, .fillb, .fillw, .defg,  or .defgx.\nNote: You can use the label syntax for field names; thus, you can add an optional colon after the identifier.\nYou can apply field initializer statements right after the structure initialization. Any other Z80 instruction, pragma, statement, or directive signs the end of the structure initialization. This code snippet shows two examples of setting up Object2D structures. The first is correct; however, the second one raises an error:\nObject2D: .struct\n    X: .defw 0\n    Y: .defw 0\n    DX: .defb 1\n    DY: .defb 1\n  .ends\nObj1: Object2D()\n  DX -> .defb 2\n  DY -> .defb 2\n  ld a,b\n  ; ... Some other code\nObj2: Object2D()\n  X -> .defw 100\n  Y -> .defw 100\n  ld hl,#4000    ; Field initialization stops here\n  DX -> .defb 4  ; ERROR\nThe compiler does not care how you initialize fields. For example, even if you have created the X field of Object2D with a .defw pragma, you can set its value with .defb, like in this example:\nObj3: Object2D()\n  X -> .defb 100, 0\nYou can even initialize two fields with a simple initializer statement. For example, DX and DY are one byte each. You can initialize both of these fields in a single step, as these code snippet shows:\nObj4: Object2D()\n  DX -> .defb 2,2\nObj5: Object2D()\n  DX -> .defw #0202\nThe order of fields is unimportant; you can initialize them in any order:\nObj6: Object2D()\n  DX -> .defb 1\n  X -> .defw 100\n  DY -> .defb 1\n  Y -> .defw 200","fluent-structure-initialization#Fluent Structure Initialization":"The assembler allows flexible initialization, where you do not use field names. The compiler emits bytes as the byte emitter pragmas would do if you were not within a structure initialization. Let's assume you initialize an Object2D this way:\nObj7: Object2D()\n  -> .defb 1, 0\n  DX -> defw #0303\nWithout the field initializers, the structure would contain these six bytes:#00, #00, #00, #00, #01, #01However, the field initializers overwrote the default bytes with the ones displayed in boldface:#01, #00, #00, #00, #03, #03You can choose your preferred way to initialize a structure using a field or unnamed initializers. The compiler does not care how you assemble the set of bytes within the structure. However, it does not allow you to overflow the structure boundaries. This sample shows you two initializations of Object2D. The first is correct, as it emits exactly six bytes. However, the second raises an error since the initialization tries to put eight bytes into the structure:\nObj8: Object2D()\n  -> .defm \"012345\"\nObj9: Object2D()    ; ERROR: The code tries to initialize the structure with 8 bytes\n  X -> .defw 100\n  -> .defm \"012345\""}},"/z80-assembly/z80-assembler":{"title":"The Klive Z80 Assembler","data":{"":"The original goal of the Klive Assembler was to have a simple tool that allows you to compile Z80 assembly code and inject it into the ZX Spectrum virtual machine. As the community has started using it, I've been receiving feature requests to add some helpful capabilities to the Assembler.","main-features#Main Features":"Here is a list of essential features the Klive Assembler supports:\nFull Z80 instruction set, including the initially undocumented Z80 registers and instructions\n(such as the 8-bit halves of ix and iy, namely ixl, ixh, iyl, iyh).\nZX Spectrum Next extended Z80 instruction set\nAlternate syntax versions. All directives, pragmas, and statements have multiple versions; you can use your preferred notation. For example, you can use .loop, loop, .LOOP or LOOP to declare a loop. All of the .defb, DEFB, .db, DB (and a few other) tokens can be used for defining byte data.\nZ80 Preprocessor. With preprocessor directives, you can execute conditional compilation and include other source files, inject symbols for debug time, and run time compilations separately. In Klive\nyou can use powerful macros, too. Nonetheless, they are not preprocessor constructs (see below).\nFast compilation. Of course, it depends on the code, but the compiler can emit code for about ten thousand source code lines per second (MacBook Pro).\nRich expressions. The compiler can handle most arithmetic and logic operators in C, C++, C#, Java, and JavaScript. You can use integer, float, and string expressions. The language supports more than 40 functions that you can use in the expressions (e.g., Amp * sin($cnt * Pi() / 16))\nRich literal formats. Decimal, float, hexadecimal, binary, and string literals are available.\nYou can use multiple variants for hexadecimal numbers ($12ae, #12AE, 0x12AE, 12AEh), and binary numbers\n(0b00111100, %00111100, %0011_1100). In strings, you can use ZX Spectrum-specific escape codes, for example, \\i for INK, \\P for the pound sign, and many others.\nAssembler control flow statements. You can use loops (loop, repeat..until, while..wend, for..next) and conditional statements (if) to create an assembler control flow. These constructs\ncan be nested and provide local scope for labels, symbols, and variables.\nPowerful dynamic macros. You can create macros with arguments. In the macro bodies, the current values of arguments can replace entire instructions, operands, or parts of expressions. Moreover, through arguments, you can inject multiline instructions and statements into macro declarations.\nModules. You can use modules to serve both as logical containers to separate partitions of the code and namespaces to create scopes for labels and symbols.","how-the-assembler-works#How The Assembler Works":"The assembler compiles the code in these phases:\nIt takes the source code and runs a preprocessor that parses the entire code and applies the directives in the code. You can easily recognize directives starting with #, such as #ifdef, #endif, #define, #include, and others. During the preprocessing phase, the assembler detects the syntax errors and loads and processes the included files. The result is a digested syntax tree that does not contain directives anymore, only instructions, pragmas, and statements.\nThe assembler collects macro definitions and stores their syntax tree to later use them when macros are invoked with their actual parameters.\nThe assembler goes through the digested syntax tree and emits code. During this operation, it must evaluate expressions to resolve symbols and identifiers to their actual values. Because the assembler progresses from the first line to the last, it may happen that it cannot get the value of an identifier, which is defined somewhere later in the code. When the assembler detects such a situation, it notes it and creates a fixup entry.\nThe assembler goes through all fixup entries and resolves symbols not defined in the previous phase. Of course, it might find unknown symbols. If this happens, the assembler reports an error.\nNote: Several pragmas and statements intend to evaluate an expression in phase 3. If they find an unresolved symbol during that phase, they do not create a fixup entry but immediately report an error."}},"/z80-assembly/z80-instructions":{"title":"Accepted Z80 Instructions","data":{"":"The Klive Assembler implements every officially documented Z80 instruction as well as the non-official ones. During the implementation, the ClrHome.org was used as a reference.Z80 instructions may start with a label. Labels are identifiers that can be terminated by an optional colon (:). The compiler accepts both labels in these samples:\nStart: ld b,#f0\nWait   djnz Wait","z80-mnemonics#Z80 Mnemonics":"The compiler accepts these mnemonics:ADC, ADD, AND, BIT, CALL, CCF, CP, CPD,\nCPDR, CPI, CPIR, CPL, DAA, DEC, DI, DJNZ,\nEI, EX, EXX, HALT, IM, IN, INC, IND,\nINDR, INI, INIR, JP, JR, LD, LDD, LDDR, LDDRX*, LDRX*, LDDX*,\nLDI, LDIR, LDIRX*, LIRX*, LDIX*, LDPIRX*, LPRX*, MIRROR*, MIRR*, MUL*, NEG,\nNEXTREG*, NREG*, NOP, OR, OTDR, OTIR, OUT, OUTINB*, OTIB*,\nOUTD, OUTI, PIXELAD*, PXAD*, PIXELDN*, PXDN*, POP, PUSH, RES, RET, RETI, RETN,\nRL, RLA, RLC, RLCA, RLD, RR, RRA, RRC,\nRRCA, RRD, RST, SBC, SCF, SET, SETAE*, STAE*, SLA, SLL\nSRA, SRL, SUB, SWAPNIB*, SWAP*, TEST*, XOR.\nNote: The instructions marked with * can be used only with the ZX Spectrum Next model.","z80-registers#Z80 Registers":"The compiler uses the standard 8-bit and 16-bit register names, as specified in the official\nZilog Z80 documentation:\n8-bit registers: A, B, C, D, E, H, L, I, R\n16-bit registers: AF, BC, DE, HL, SP, IX, IY\nFor the 8-bit halves of the IX and IY index registers, the compiler uses these names: XL, XH, YL, YH. Alternatively, the compiler accepts these names, too: IXL, IXH, IYL, IYH. As a kind of exception to general naming conventions, these mixed-case names are also accepted: IXl, IXh, IYl, IYh.","jp-syntax#JP Syntax":"Z80 assemblers use two different syntax constructs for the indirect JP statements:\n; Notation #1\njp hl\njp ix\njp iy\n; Notation #2\njp (hl)\njp (ix)\njp (iy)\nThe Klive Assembler accepts both notations.","alu-operations-syntax#ALU operations syntax":"Three standard ALU operations between A and other operands (ADD, ADC, and SBC) sign A\nas their first operand:\nadd a,b\nadc a,(hl)\nsbc a,e\nHowever, the five other standard ALU operations between A and other operands (SUB, AND, XOR,\nOR, and CP) omit A from their notation:\nsub e\nand (hl)\nxor e\nor c\ncp b\nThe Klive compiler accepts the second group of ALU operations using the explicit A operand, too:\nsub a,e\nand a,(hl)\nxor a,e\nor a,c\ncp a,b"}},"/":{"title":"Introduction to Klive IDE","data":{"":"Klive IDE is a retro computer emulator and Integrated Development Environment running on Mac and Windows.Klive offers not only the emulators but also debugging views, a multi-pane code editor, interactive commands, and other tools to create your Z80 Assembly and ZX BASIC (Boriel's Basic) programs.Klive IDE supports dual monitor mode to place the Emulator and IDE on different monitors while working with code.","supported-emulators#Supported Emulators":"Klive IDE intends to support retro computers with the Z80 family of CPUs. Klive supports these emulators:\nZX Spectrum 48K\nZX Spectrum 128K\nZX Spectrum +2E/+3E\nCambridge Z88\nZX Spectrum Next (in progress)\nZX 80/81 (in the future)","emulator-features#Emulator Features":"The emulator can run the selected machine with or without debugging. These modes can be changed without restarting the running machine:\nStarting, pausing, continuing to run\nStart or continue in debug mode\nSetting up breakpoints, step-in, step-over, step-out modes\nTo examine the state of the emulator, Klive offers several views:\nFull CPU view\nFull ULA view\nMemory view with live refresh\nDisassembly view with execution point tracking\nMonitoring system variable values\nDisplaying (and exporting) the current BASIC listing\nYou can quickly load and play programs (games) from files:\nLoading tape files (.tap and .tzx)\nFast load\nLoading from disk files (.dsk) with ZX Spectrum +3E\nWriting and formatting disk (.dsk) files (in progress)\nOther emulator features:\nVisual keyboard (ZX Spectrum 48K and ZX Spectrum 128K styles)\nMultiplying CPU clock speed (1-24 multiplier)\nSetting up the sound level, muting and unmuting sound\nPlanned features (in the future):\nUsing custom machine ROMs\nMemory read/write breakpoints\nI/O read/write breakpoints\nBreakpoints with hit count conditions","ide-features#IDE Features":"The IDE allows you to open project folders that keep the files belonging to a particular (development) project together. You can use Z80 Assembly language (with the built-in Klive Z80 Assembler) and ZX BASIC (Boriel's Basic) as your programming language.\nSyntax highlighting\nSource code debugging (works with the Klive Z80 Assembler)\nExporting the compiled code to tape files (.tap and `.tzx) with BASIC loaders\nKlive's unique feature is the one-click start and debugging: With a click of one button, your code is compiled and injected into the selected emulator and immediately starts up. You can start your code with debugging (or pause it and continue with debugging).Commands: The IDE has an interactive command panel to issue CLI commands executed within the IDE.Planned features (in the future):\nWatch Panel: display runtime information about memory variables (expressions)\nConditional breakpoints\nIntegration with other assemblers, including compilation and optional source code debugging (if the particular compiler supports debug symbol information)."}}}