(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[628],{5344:(e,n,s)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/z80-assembly/structs",function(){return s(2928)}])},2928:(e,n,s)=>{"use strict";s.r(n),s.d(n,{default:()=>l,useTOC:()=>d});var i=s(4848),t=s(7849),r=s(2421),a=s(8023);function d(e){return[{value:"Understanding Structures",id:"understanding-structures",depth:2},{value:"Structure Definition",id:"structure-definition",depth:2},{value:"Labels and Field Names",id:"labels-and-field-names",depth:2},{value:"Structure initialization",id:"structure-initialization",depth:2},{value:"Field Initializers",id:"field-initializers",depth:2},{value:"Fluent Structure Initialization",id:"fluent-structure-initialization",depth:2}]}let l=(0,t.e)(function(e){let{toc:n=d(e)}=e,s={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",span:"span",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{children:"Structures"}),"\n",(0,i.jsxs)(s.p,{children:["Klive allows you to use structure definitions and placements in your Z80 programs. If you know the ",(0,i.jsx)(s.code,{children:"struct"})," construct from C, C++, or C#, the concept in Z80 is only partly similar."]}),"\n",(0,i.jsx)(s.h2,{id:n[0].id,children:n[0].value}),"\n",(0,i.jsx)(s.p,{children:"In Klive Assembler, a structure definition is a placeholder that defines a byte pattern like this:"}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D: .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["This definition says that ",(0,i.jsx)(s.code,{children:"Object2D"})," is a structure of six bytes (two 16-bit words and two 8-bit bytes) with the following bytes emitted: #00, #00, #00, #00, #01, #01. Whenever you place a structure declaration in a program, just like in this sample, the assembler will emit the bytes you specified in the ",(0,i.jsx)(s.code,{children:".struct"})," definition:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsx)(s.code,{children:(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  Object2D() ; emits #00, #00, #00, #00, #01, #01"})})})}),"\n",(0,i.jsxs)(s.p,{children:["As you can see, six subsequent bytes do not tell enough about the semantics of ",(0,i.jsx)(s.code,{children:"Object2D"}),". When we created this structure, the original concept was to use two 16-bit numbers to specify the X and Y coordinates of the object, plus two 8-bit numbers to describe its horizontal and vertical velocity. With ",(0,i.jsx)(s.em,{children:"field definitions"})," (see ",(0,i.jsx)(s.code,{children:"X"}),", ",(0,i.jsx)(s.code,{children:"Y"}),", ",(0,i.jsx)(s.code,{children:"DX"}),", and ",(0,i.jsx)(s.code,{children:"DY"}),"), the meaning of ",(0,i.jsx)(s.code,{children:"Object2D"})," is more straightforward than it was before:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D: .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    X: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    Y: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    DX: .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    DY: .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["Of course, we would like to initialize objects with different states. With ",(0,i.jsx)(s.em,{children:"field initializers"}),", we can define structures with initial states that are different from the ",(0,i.jsx)(s.code,{children:".struct"})," definition:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Apple: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  X -> .defw 100"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  Y -> .defw 100"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Pear: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defb -1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DY -> .defb -1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; Some other code"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ld hl,Apple"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ld de,Pear"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["In this sample, the ",(0,i.jsx)(s.code,{children:"Apple"})," label (that the code later loads into ",(0,i.jsx)(s.strong,{children:"HL"}),") points to an ",(0,i.jsx)(s.code,{children:"Object2D"})," declaration that holds 100 in its X and Y values. Another label, ",(0,i.jsx)(s.code,{children:"Pear"}),", points to a different instance of ",(0,i.jsx)(s.code,{children:"Object2D"})," (later, the code loads that address into ",(0,i.jsx)(s.strong,{children:"DE"}),"). ",(0,i.jsx)(s.code,{children:"Pear"})," has a converse velocity compared to ",(0,i.jsx)(s.code,{children:"Apple"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["The Assembler allows you to initialize structures with any pragma that emits bytes to the assembly output. For example, the following code snippet sets a new ",(0,i.jsx)(s.code,{children:"Object2D"})," structure in a particular way:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Banana: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  -> .defb 10, 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  -> .defb 12, 2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defb 2, 2"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["The first ",(0,i.jsx)(s.code,{children:".defb"})," pragma (right after the first ",(0,i.jsx)(s.code,{children:"->"}),") emits two bytes, 10 and 1, respectively, and it sets the X field to 266 (10 + 1",(0,i.jsxs)(s.em,{children:["256). The second ",(0,i.jsx)(s.code,{children:".defb"})," sets Y to 524 (12 * 2"]}),"256). The initialization of DX (",(0,i.jsx)(s.code,{children:"DX -> .defb 2, 2"}),") emits two bytes and sets both ",(0,i.jsx)(s.code,{children:"DX"})," and ",(0,i.jsx)(s.code,{children:"DY"})," to 2."]}),"\n",(0,i.jsx)(s.h2,{id:n[1].id,children:n[1].value}),"\n",(0,i.jsxs)(s.p,{children:["You can define structure between the ",(0,i.jsx)(s.code,{children:".struct"})," and ",(0,i.jsx)(s.code,{children:".ends"}),"  statements. Each structure must have a unique name to declare with a label. The compiler accepts all of these definitions:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; Version #1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"MyStruct .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; Version #2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"MyStruct: .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; Version #3"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"MyStruct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; Version#4"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"MyStruct:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})})]})}),"\n",(0,i.jsx)(s.p,{children:"Nonetheless, it raises an error if you do not name the structure:"}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:".struct ; ERROR: .struct must have a name"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:".ends"})})]})}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note"}),": The assembler accepts the following alternative keywords for ",(0,i.jsx)(s.code,{children:".struct"}),": ",(0,i.jsx)(s.code,{children:".STRUCT"}),", ",(0,i.jsx)(s.code,{children:"struct"}),", or ",(0,i.jsx)(s.code,{children:"STRUCT"}),". Similarly, ",(0,i.jsx)(s.code,{children:".ends"})," has these aliases, too: ",(0,i.jsx)(s.code,{children:".ENDS"}),", ",(0,i.jsx)(s.code,{children:"ends"}),", and ",(0,i.jsx)(s.code,{children:"ENDS"}),". Though you can define an empty structure, there is no practical reason to do so."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["In the body of the structure, you can use only one of these byte-emitter pragmas: ",(0,i.jsx)(s.code,{children:".defb"}),", ",(0,i.jsx)(s.code,{children:".defw"}),", ",(0,i.jsx)(s.code,{children:".defm"}),", ",(0,i.jsx)(s.code,{children:".defn"}),", ",(0,i.jsx)(s.code,{children:".defc"}),", ",(0,i.jsx)(s.code,{children:".defs"}),", ",(0,i.jsx)(s.code,{children:".fillb"}),", ",(0,i.jsx)(s.code,{children:".fillw"}),", ",(0,i.jsx)(s.code,{children:".defg"}),",  or ",(0,i.jsx)(s.code,{children:".defgx"}),". If you try to use any other construct, the compiler raises an error message."]}),"\n",(0,i.jsx)(s.p,{children:"As you saw earlier, you can specify field labels within the structure body. The assembler is flexible: you can omit field labels or even use multiple labels for a single field:"}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D_A: .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  Coords:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    X: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    Y: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  Velocity:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["Here, ",(0,i.jsx)(s.code,{children:"Object2D_A"})," has two field name for the first ",(0,i.jsx)(s.code,{children:".defw"})," field, ",(0,i.jsx)(s.code,{children:"Coords"}),", and ",(0,i.jsx)(s.code,{children:"X"}),", respectively. The last ",(0,i.jsx)(s.code,{children:".defb"})," does not have its field name, unlike the one before, ",(0,i.jsx)(s.code,{children:"Velocity"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:n[2].id,children:n[2].value}),"\n",(0,i.jsxs)(s.p,{children:["The label assigned to the ",(0,i.jsx)(s.code,{children:".struct"})," definition has a dual role. When used in a structure initialization (for example, as ",(0,i.jsx)(s.code,{children:"Object2D"})," is utilized in the ",(0,i.jsx)(s.code,{children:"Object2D()"})," initializer), it identifies the structure. Nonetheless, you can use the label name in Z80 instructions, too. In this case, the label’s value is the size of the structure. For example, these instructions are equivalent, as the size of the ",(0,i.jsx)(s.code,{children:"Object2D"})," structure is six bytes:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"ld a,Object2D ; Size of Object2D"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"ld a,6 ; "})})]})}),"\n",(0,i.jsxs)(s.p,{children:["You can allocate a memory block for 100 uninitialized instances of ",(0,i.jsx)(s.code,{children:"Object2D"})," with this pragma:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"My100Objects:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defs 100 * Object2D"})})]})}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note"}),": You cannot assign a label to the ",(0,i.jsx)(s.code,{children:".ends"})," statement. If you do, the compiler throws an error."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Labels assigned to the body of the ",(0,i.jsx)(s.code,{children:".struct"})," definition are used as field names. You can use them only with the structure name:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D: .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    X: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    Y: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    DX: .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    DY: .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Apple: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ..."})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ld hl,Apple + Object2D.DX"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ld a,(hl)"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["Field label values contain the offset of the particular field from the beginning of the structure. Thus, the last two instructions in the code above load the content of the ",(0,i.jsx)(s.code,{children:"Apple"})," structure’s ",(0,i.jsx)(s.code,{children:"DX"})," field into ",(0,i.jsx)(s.strong,{children:"A"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["According to these definitions, here are the field label values of ",(0,i.jsx)(s.code,{children:"Object2D"}),":"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D.X: 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D.Y: 2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D.DX: 4"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D.DY: 5"})})]})}),"\n",(0,i.jsx)(s.h2,{id:n[3].id,children:n[3].value}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:".struct"})," definition does not emit any code; it just tells the compiler the layout and initial contents of a structure. To allocate space for a particular structure, you need to initialize it with the name of the structure plus a pair of opening and closing parentheses, just like these samples show:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; Initalize an Object2D"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"MyObject: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"; Initialize another one"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"OtherObject: Object2D()"})})]})}),"\n",(0,i.jsx)(s.p,{children:"When you add a label to the structure initialization, that label’s value points to the beginning of the structure in the memory."}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"start: .org #8000"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"DistanceEntry:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    Address: .defw $"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    SeqNo: .defb Index"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Data: .org #9000"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Index = 1;"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Entry1:	DistanceEntry()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Index = 2;"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Entry2:	DistanceEntry()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Index = 3;"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Entry3:	DistanceEntry()"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["The compiler emits the initialization code for ",(0,i.jsx)(s.code,{children:"Entry1"}),", ",(0,i.jsx)(s.code,{children:"Entry2"}),", and ",(0,i.jsx)(s.code,{children:"Entry3"})," as if you wrote this:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Data .org #9000"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Entry1:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defw #9000"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Entry2:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defw #9003"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defb 2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Entry3:"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defw #9006"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .defb 03"})})]})}),"\n",(0,i.jsx)(s.h2,{id:n[4].id,children:n[4].value}),"\n",(0,i.jsx)(s.p,{children:"Field initializers can be used to change the default structure initializer. A field initializer has this syntax:"}),"\n",(0,i.jsxs)(s.p,{children:["[",(0,i.jsx)(s.em,{children:"identifier"}),"] ",(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"->"})})," ",(0,i.jsx)(s.em,{children:"byte-emitter-pragma"})]}),"\n",(0,i.jsxs)(s.p,{children:["For a moment, let’s forget that ",(0,i.jsx)(s.em,{children:"identifier"})," is optional. When you use it, it must be one of the structure’s field names. The ",(0,i.jsx)(s.em,{children:"byte-emitter-pragma"})," is one of the Klive pragmas you can use to define a structure body, namely these:  ",(0,i.jsx)(s.code,{children:".defb"}),", ",(0,i.jsx)(s.code,{children:".defw"}),", ",(0,i.jsx)(s.code,{children:".defm"}),", ",(0,i.jsx)(s.code,{children:".defn"}),", ",(0,i.jsx)(s.code,{children:".defc"}),", ",(0,i.jsx)(s.code,{children:".defs"}),", ",(0,i.jsx)(s.code,{children:".fillb"}),", ",(0,i.jsx)(s.code,{children:".fillw"}),", ",(0,i.jsx)(s.code,{children:".defg"}),",  or ",(0,i.jsx)(s.code,{children:".defgx"}),"."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note"}),": You can use the label syntax for field names; thus, you can add an optional colon after the ",(0,i.jsx)(s.em,{children:"identifier"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["You can apply field initializer statements right after the structure initialization. Any other Z80 instruction, pragma, statement, or directive signs the end of the structure initialization. This code snippet shows two examples of setting up ",(0,i.jsx)(s.code,{children:"Object2D"})," structures. The first is correct; however, the second one raises an error:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Object2D: .struct"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    X: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    Y: .defw 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    DX: .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"    DY: .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  .ends"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj1: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defb 2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DY -> .defb 2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ld a,b"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ; ... Some other code"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj2: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  X -> .defw 100"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  Y -> .defw 100"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  ld hl,#4000    ; Field initialization stops here"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defb 4  ; ERROR"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["The compiler does not care how you initialize fields. For example, even if you have created the ",(0,i.jsx)(s.code,{children:"X"})," field of ",(0,i.jsx)(s.code,{children:"Object2D"})," with a ",(0,i.jsx)(s.code,{children:".defw"})," pragma, you can set its value with ",(0,i.jsx)(s.code,{children:".defb"}),", like in this example:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj3: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  X -> .defb 100, 0"})})]})}),"\n",(0,i.jsxs)(s.p,{children:["You can even initialize two fields with a simple initializer statement. For example, ",(0,i.jsx)(s.code,{children:"DX"})," and ",(0,i.jsx)(s.code,{children:"DY"})," are one byte each. You can initialize both of these fields in a single step, as these code snippet shows:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj4: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defb 2,2"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj5: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defw #0202"})})]})}),"\n",(0,i.jsx)(s.p,{children:"The order of fields is unimportant; you can initialize them in any order:"}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj6: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  X -> .defw 100"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DY -> .defb 1"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  Y -> .defw 200"})})]})}),"\n",(0,i.jsx)(s.h2,{id:n[5].id,children:n[5].value}),"\n",(0,i.jsxs)(s.p,{children:["The assembler allows flexible initialization, where you do not use field names. The compiler emits bytes as the byte emitter pragmas would do if you were not within a structure initialization. Let’s assume you initialize an ",(0,i.jsx)(s.code,{children:"Object2D"})," this way:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj7: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  -> .defb 1, 0"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  DX -> defw #0303"})})]})}),"\n",(0,i.jsx)(s.p,{children:"Without the field initializers, the structure would contain these six bytes:"}),"\n",(0,i.jsx)(s.p,{children:"#00, #00, #00, #00, #01, #01"}),"\n",(0,i.jsx)(s.p,{children:"However, the field initializers overwrote the default bytes with the ones displayed in boldface:"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"#01"}),", ",(0,i.jsx)(s.strong,{children:"#00"}),", #00, #00, ",(0,i.jsx)(s.strong,{children:"#03"}),", ",(0,i.jsx)(s.strong,{children:"#03"})]}),"\n",(0,i.jsxs)(s.p,{children:["You can choose your preferred way to initialize a structure using a field or unnamed initializers. The compiler does not care how you assemble the set of bytes within the structure. However, it does not allow you to overflow the structure boundaries. This sample shows you two initializations of ",(0,i.jsx)(s.code,{children:"Object2D"}),". The first is correct, as it emits exactly six bytes. However, the second raises an error since the initialization tries to put eight bytes into the structure:"]}),"\n",(0,i.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(s.code,{children:[(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj8: Object2D()"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:'  -> .defm "012345"'})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"Obj9: Object2D()    ; ERROR: The code tries to initialize the structure with 8 bytes"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:"  X -> .defw 100"})}),"\n",(0,i.jsx)(s.span,{children:(0,i.jsx)(s.span,{children:'  -> .defm "012345"'})})]})})]})},"/z80-assembly/structs",{filePath:"pages/z80-assembly/structs.mdx",pageMap:r.O,frontMatter:{},title:"Structures"},"undefined"==typeof RemoteContent?d:RemoteContent.useTOC)},2421:(e,n,s)=>{"use strict";s.d(n,{O:()=>i});let i=[{data:{index:"Introduction","getting-started":"Getting Started","working-with-ide":"Working with the IDE",howto:"How To","z80-assembly":"Klive Z80 Assembler",scripting:"Scripting","command-reference":"Command Reference","machine-types":"Machine Types"}},{name:"command-reference",route:"/command-reference",frontMatter:{sidebarTitle:"Command Reference"}},{name:"getting-started",route:"/getting-started",children:[{data:{installation:"Installing Klive","first-run":"Running Klive",keyboard:"Using the Keyboard",tapes:"Loading from Tape","save-programs":"Saving Files","creating-project":"Creating a Klive Project"}},{name:"creating-project",route:"/getting-started/creating-project",frontMatter:{sidebarTitle:"Creating Project"}},{name:"first-run",route:"/getting-started/first-run",frontMatter:{sidebarTitle:"First Run"}},{name:"installation",route:"/getting-started/installation",frontMatter:{sidebarTitle:"Installation"}},{name:"keyboard",route:"/getting-started/keyboard",frontMatter:{sidebarTitle:"Keyboard"}},{name:"save-programs",route:"/getting-started/save-programs",frontMatter:{sidebarTitle:"Save Programs"}},{name:"tapes",route:"/getting-started/tapes",frontMatter:{sidebarTitle:"Tapes"}}]},{name:"howto",route:"/howto",children:[{data:{"file-extensions":"Changing default file extensions","instant-screen":"Using the Instant Screen"}},{name:"file-extensions",route:"/howto/file-extensions",frontMatter:{sidebarTitle:"File Extensions"}},{name:"instant-screen",route:"/howto/instant-screen",frontMatter:{sidebarTitle:"Instant Screen"}}]},{name:"index",route:"/",frontMatter:{sidebarTitle:"Index"}},{name:"machine-types",route:"/machine-types",frontMatter:{sidebarTitle:"Machine Types"}},{name:"project-templates",route:"/project-templates",frontMatter:{sidebarTitle:"Project Templates"}},{name:"scripting",route:"/scripting",children:[{data:{overview:"Overview",syntax:"Scripting Syntax"}},{name:"overview",route:"/scripting/overview",frontMatter:{sidebarTitle:"Overview"}},{name:"syntax",route:"/scripting/syntax",frontMatter:{sidebarTitle:"Syntax"}}]},{name:"working-with-ide",route:"/working-with-ide",children:[{data:{"project-explorer":"The Project Explorer","editing-code":"Editing Code","run-debug":"Running & Debugging Code",zxb:"ZXBASIC Integration","ide-settings":"IDE Settings",cpu:"The CPU View",ula:"The ULA View",memory:"The Memory View",disassembly:"The Disassembly View",breakpoints:"The Breakpoints View","system-vars":"The System Variables View",basic:"The BASIC Listing",commands:"Interactive Commands","build-system":"The Build System"}},{name:"basic",route:"/working-with-ide/basic",frontMatter:{sidebarTitle:"Basic"}},{name:"breakpoints",route:"/working-with-ide/breakpoints",frontMatter:{sidebarTitle:"Breakpoints"}},{name:"build-system",route:"/working-with-ide/build-system",frontMatter:{sidebarTitle:"Build System"}},{name:"commands",route:"/working-with-ide/commands",frontMatter:{sidebarTitle:"Commands"}},{name:"cpu",route:"/working-with-ide/cpu",frontMatter:{sidebarTitle:"Cpu"}},{name:"disassembly",route:"/working-with-ide/disassembly",frontMatter:{sidebarTitle:"Disassembly"}},{name:"editing-code",route:"/working-with-ide/editing-code",frontMatter:{sidebarTitle:"Editing Code"}},{name:"ide-settings",route:"/working-with-ide/ide-settings",frontMatter:{sidebarTitle:"Ide Settings"}},{name:"memory",route:"/working-with-ide/memory",frontMatter:{sidebarTitle:"Memory"}},{name:"project-explorer",route:"/working-with-ide/project-explorer",frontMatter:{sidebarTitle:"Project Explorer"}},{name:"run-debug",route:"/working-with-ide/run-debug",frontMatter:{sidebarTitle:"Run Debug"}},{name:"system-vars",route:"/working-with-ide/system-vars",frontMatter:{sidebarTitle:"System Vars"}},{name:"ula",route:"/working-with-ide/ula",frontMatter:{sidebarTitle:"Ula"}},{name:"zxb",route:"/working-with-ide/zxb",frontMatter:{sidebarTitle:"Zxb"}}]},{name:"z80-assembly",route:"/z80-assembly",children:[{data:{"z80-assembler":"Assembler Overview","language-structure":"Language Structure",expressions:"Expressions","z80-instructions":"Z80 Instructions",pragmas:"Pragmas",statements:"Assembler Statements",macros:"Macros",structs:"Structs"}},{name:"expressions",route:"/z80-assembly/expressions",frontMatter:{sidebarTitle:"Expressions"}},{name:"language-structure",route:"/z80-assembly/language-structure",frontMatter:{sidebarTitle:"Language Structure"}},{name:"macros",route:"/z80-assembly/macros",frontMatter:{sidebarTitle:"Macros"}},{name:"pragmas",route:"/z80-assembly/pragmas",frontMatter:{sidebarTitle:"Pragmas"}},{name:"statements",route:"/z80-assembly/statements",frontMatter:{sidebarTitle:"Statements"}},{name:"structs",route:"/z80-assembly/structs",frontMatter:{sidebarTitle:"Structs"}},{name:"z80-assembler",route:"/z80-assembly/z80-assembler",frontMatter:{sidebarTitle:"Z80 Assembler"}},{name:"z80-instructions",route:"/z80-assembly/z80-instructions",frontMatter:{sidebarTitle:"Z80 Instructions"}}]}]}},e=>{var n=n=>e(e.s=n);e.O(0,[849,636,593,792],()=>n(5344)),_N_E=e.O()}]);