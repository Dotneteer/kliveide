(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[828],{2940:function(e,s,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/z80-assembly/z80-assembler",function(){return n(3241)}])},3241:function(e,s,n){"use strict";n.r(s),n.d(s,{__toc:function(){return o}});var t=n(5893),l=n(2673),i=n(7758),r=n(3911);n(9128);var a=n(2643);let o=[{depth:2,value:"Main Features",id:"main-features"},{depth:2,value:"How The Assembler Works",id:"how-the-assembler-works"}];function _createMdxContent(e){let s=Object.assign({h1:"h1",p:"p",h2:"h2",ul:"ul",li:"li",strong:"strong",code:"code",em:"em",ol:"ol",blockquote:"blockquote"},(0,a.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{children:"The Klive Z80 Assembler"}),"\n",(0,t.jsx)(s.p,{children:"The original goal of the Klive Assembler was to have a simple tool that allows you to compile Z80 assembly code and inject it into the ZX Spectrum virtual machine. As the community has started using it, I've been receiving feature requests to add some helpful capabilities to the Assembler."}),"\n",(0,t.jsx)(s.h2,{id:"main-features",children:"Main Features"}),"\n",(0,t.jsx)(s.p,{children:"Here is a list of essential features the Klive Assembler supports:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Full Z80 instruction set"}),", including the initially undocumented Z80 registers and instructions\n(such as the 8-bit halves of ",(0,t.jsx)(s.code,{children:"ix"})," and ",(0,t.jsx)(s.code,{children:"iy"}),", namely ",(0,t.jsx)(s.code,{children:"ixl"}),", ",(0,t.jsx)(s.code,{children:"ixh"}),", ",(0,t.jsx)(s.code,{children:"iyl"}),", ",(0,t.jsx)(s.code,{children:"iyh"}),")."]}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.strong,{children:"ZX Spectrum Next extended Z80 instruction set"})}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Alternate syntax versions"}),". All directives, pragmas, and statements have multiple versions; you can use your preferred notation. For example, you can use ",(0,t.jsx)(s.code,{children:".loop"}),", ",(0,t.jsx)(s.code,{children:"loop"}),", ",(0,t.jsx)(s.code,{children:".LOOP"})," or ",(0,t.jsx)(s.code,{children:"LOOP"})," to declare a loop. All of the ",(0,t.jsx)(s.code,{children:".defb"}),", ",(0,t.jsx)(s.code,{children:"DEFB"}),", ",(0,t.jsx)(s.code,{children:".db"}),", ",(0,t.jsx)(s.code,{children:"DB"})," (and a few other) tokens can be used for defining byte data."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Z80 Preprocessor"}),". With preprocessor directives, you can execute conditional compilation and include other source files, inject symbols for debug time, and run time compilations separately. ",(0,t.jsx)(s.em,{children:"In Klive\nyou can use powerful macros, too. Nonetheless, they are not preprocessor constructs (see below)"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Fast compilation"}),". Of course, it depends on the code, but the compiler can emit code for about ten thousand source code lines per second (MacBook Pro)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Rich expressions"}),". The compiler can handle most arithmetic and logic operators in C, C++, C#, Java, and JavaScript. You can use integer, float, and string expressions. The language supports more than 40 functions that you can use in the expressions (e.g., ",(0,t.jsx)(s.code,{children:"Amp * sin($cnt * Pi() / 16)"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Rich literal formats"}),". Decimal, float, hexadecimal, binary, and string literals are available.\nYou can use multiple variants for hexadecimal numbers (",(0,t.jsx)(s.code,{children:"$12ae"}),", #12AE, 0x12AE, 12AEh), and binary numbers\n(0b00111100, %00111100, %0011_1100). In strings, you can use ZX Spectrum-specific escape codes, for example, ",(0,t.jsx)(s.code,{children:"\\i"})," for INK, ",(0,t.jsx)(s.code,{children:"\\P"})," for the pound sign, and many others."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Assembler control flow statements"}),". You can use loops (",(0,t.jsx)(s.code,{children:"loop"}),", ",(0,t.jsx)(s.code,{children:"repeat"}),"..",(0,t.jsx)(s.code,{children:"until"}),", ",(0,t.jsx)(s.code,{children:"while"}),"..",(0,t.jsx)(s.code,{children:"wend"}),", ",(0,t.jsx)(s.code,{children:"for"}),"..",(0,t.jsx)(s.code,{children:"next"}),") and conditional statements (",(0,t.jsx)(s.code,{children:"if"}),") to create an assembler control flow. These constructs\ncan be nested and provide local scope for labels, symbols, and variables."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Powerful dynamic macros"}),". You can create macros with arguments. In the macro bodies, the current values of arguments can replace entire instructions, operands, or parts of expressions. Moreover, through arguments, you can inject multiline instructions and statements into macro declarations."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Modules"}),". You can use modules to serve both as logical containers to separate partitions of the code and namespaces to create scopes for labels and symbols."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"how-the-assembler-works",children:"How The Assembler Works"}),"\n",(0,t.jsx)(s.p,{children:"The assembler compiles the code in these phases:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["It takes the source code and runs a preprocessor that parses the entire code and applies the ",(0,t.jsx)(s.em,{children:"directives"})," in the code. You can easily recognize directives starting with ",(0,t.jsx)(s.code,{children:"#"}),", such as ",(0,t.jsx)(s.code,{children:"#ifdef"}),", ",(0,t.jsx)(s.code,{children:"#endif"}),", ",(0,t.jsx)(s.code,{children:"#define"}),", ",(0,t.jsx)(s.code,{children:"#include"}),", and others. During the preprocessing phase, the assembler detects the syntax errors and loads and processes the included files. The result is a ",(0,t.jsx)(s.em,{children:"digested syntax tree"})," that does not contain directives anymore, only ",(0,t.jsx)(s.em,{children:"instructions"}),", ",(0,t.jsx)(s.em,{children:"pragmas"}),", and ",(0,t.jsx)(s.em,{children:"statements"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"The assembler collects macro definitions and stores their syntax tree to later use them when macros are invoked with their actual parameters."}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["The assembler goes through the digested syntax tree and emits code. During this operation, it must evaluate expressions to resolve symbols and identifiers to their actual values. Because the assembler progresses from the first line to the last, it may happen that it cannot get the value of an identifier, which is defined somewhere later in the code. When the assembler detects such a situation, it notes it and creates a ",(0,t.jsx)(s.em,{children:"fixup"})," entry."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsx)(s.p,{children:"The assembler goes through all fixup entries and resolves symbols not defined in the previous phase. Of course, it might find unknown symbols. If this happens, the assembler reports an error."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Note"}),": Several pragmas and statements intend to evaluate an expression in phase 3. If they find an unresolved symbol during that phase, they do not create a fixup entry but immediately report an error."]}),"\n"]})]})}function MDXContent(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,a.a)(),e.components);return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)}let d={MDXContent,pageOpts:{filePath:"pages/z80-assembly/z80-assembler.mdx",route:"/z80-assembly/z80-assembler",pageMap:[{kind:"Meta",data:{index:"Introduction","getting-started":"Getting Started","z80-assembly":"Klive Z80 Assembler"}},{kind:"Folder",name:"getting-started",route:"/getting-started",children:[{kind:"Meta",data:{installation:"Installing Klive"}},{kind:"MdxPage",name:"installation",route:"/getting-started/installation"}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"z80-assembly",route:"/z80-assembly",children:[{kind:"Meta",data:{"z80-assembler":"Assembler Overview","language-structure":"Language Structure",expressions:"Expressions","z80-instructions":"Z80 Instructions",pragmas:"Pragmas",statements:"Assembler Statements",macros:"Macros",structs:"Structs"}},{kind:"MdxPage",name:"expressions",route:"/z80-assembly/expressions"},{kind:"MdxPage",name:"language-structure",route:"/z80-assembly/language-structure"},{kind:"MdxPage",name:"macros",route:"/z80-assembly/macros"},{kind:"MdxPage",name:"pragmas",route:"/z80-assembly/pragmas"},{kind:"MdxPage",name:"statements",route:"/z80-assembly/statements"},{kind:"MdxPage",name:"structs",route:"/z80-assembly/structs"},{kind:"MdxPage",name:"z80-assembler",route:"/z80-assembly/z80-assembler"},{kind:"MdxPage",name:"z80-instructions",route:"/z80-assembly/z80-instructions"}]}],flexsearch:{codeblocks:!0},title:"The Klive Z80 Assembler",headings:o},pageNextRoute:"/z80-assembly/z80-assembler",nextraLayout:i.ZP,themeConfig:r.Z};s.default=(0,l.j)(d)},3911:function(e,s,n){"use strict";n.d(s,{Z:function(){return l}});var t=n(5893);n(7294);var l={logo:(0,t.jsx)(()=>(0,t.jsxs)("svg",{width:"118",height:"50",viewBox:"0 0 294 124",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[(0,t.jsx)("rect",{width:"100%",height:"100%",fill:"#000"}),(0,t.jsx)("rect",{width:"100%",height:"100%",stroke:"black",strokeWidth:4}),(0,t.jsx)("rect",{x:12,y:0,width:7,height:"100%",fill:"#007acc"}),(0,t.jsx)("path",{d:"M 293 103 l -21 21 l -21 0 l 42 -42",fill:"#0ff"}),(0,t.jsx)("path",{d:"M 293 82 l -42 42 l -21 0 l 63 -63",fill:"#0f0"}),(0,t.jsx)("path",{d:"M 293 61 l -63 63 l -21 0 l 84 -84",fill:"#ff0"}),(0,t.jsx)("path",{d:"M 293 40 l -84 84 l -21 0 l 105 -105",fill:"#f00"}),(0,t.jsx)("path",{d:"M 41 12 l 0 42 l 7 0 l 0 -42 M 48 26 l 14 0 l 0 7 l -14 0 M 62 19 l 7 0 l 0 7 l -7 0 M 69 12 l 7 0 l 0 7 l -7 0 M 62 33 l 7 0 l 0 7 l -7 0 M 69 40 l 7 0 l 0 7 l -7 0 M 76 47 l 7 0 l 0 7 l -7 0",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 90 12 l 0 42 l 35 0 l 0 -7 l -28 0 l 0 -35",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 139 12 l 35 0 l 0 7 l -14 0 l 0 28 l 14 0 l 0 7 l -35 0 l 0 -7 l 14 0 l 0 -28 l -14 0",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 190 12 l 0 28 l 7 0 l 0 -28 M 195 40 l 7 0 l 0 7 l -7 0 M 202 47 l 14 0 l 0 7 l -14 0 M 216 40 l 7 0 l 0 7 l -7 0 M 223 12 l 0 28 l 7 0 l 0 -28",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 237 12 l 0 42 l 42 0 l 0 -7 l -35 0 l 0 -14 l 28 0 l 0 -7 l -28 0 l 0 -7 l 35 0 l 0 -7",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 56 68 l 7 0 l 0 7 l -7 0 M 49 82 l 14 0 l 0 21 l 7 0 l 0 7 l -21 0 l 0 -7 l 7 0 l 0 -14 l -7 0",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 119 68 l 7 0 l 0 42 l -28 0 l 0 -7 l 21 0 M 119 82 l -21 0 l 0 7 l 21 0 M 98 89 l 0 14 l -7 0 l 0 -14",fill:"#e0e0e0"}),(0,t.jsx)("path",{d:"M 147 75 l 21 0 l 0 7 l -21 0 M 140 82 l 0 21 l 7 0 l 0 -21 M 147 103 l 28 0 l 0 7 l -28 0 M 168 82 l 7 0 l 0 7 l -7 0 M 147 89 l 21 0 l 0 7 l -21 0",fill:"#e0e0e0"}),(0,t.jsx)("defs",{children:(0,t.jsxs)("linearGradient",{id:"paint0_linear_2790_21058",x1:"11.9663",y1:"6.54545",x2:"22.5351",y2:"22.5385",gradientUnits:"userSpaceOnUse",children:[(0,t.jsx)("stop",{stopColor:"#D62400"}),(0,t.jsx)("stop",{offset:"1",stopColor:"#A02020"})]})})]}),{}),logoLink:"https://dotneteer.github.io/kliveide",editLink:{text:null},feedback:{content:null},project:{link:"https://github.com/dotneteer/kliveide"}}}},function(e){e.O(0,[774,546,888,179],function(){return e(e.s=2940)}),_N_E=e.O()}]);