(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[972],{5276:(e,n,s)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/z80-assembly/language-structure",function(){return s(3922)}])},3922:(e,n,s)=>{"use strict";s.r(n),s.d(n,{default:()=>d,useTOC:()=>l});var r=s(4848),i=s(7849),t=s(2421),a=s(8023);function l(e){return[{value:"Syntax Basics",id:"syntax-basics",depth:2},{value:"Comments",id:"comments",depth:2},{value:"Literals",id:"literals",depth:2},{value:"Identifiers",id:"identifiers",depth:2},{value:"Scoped Identifiers",id:"scoped-identifiers",depth:2},{value:"Characters and Strings",id:"characters-and-strings",depth:2},{value:"Labels and Symbols",id:"labels-and-symbols",depth:2},{value:"Label and Symbol Declarations",id:"label-and-symbol-declarations",depth:3},{value:"Temporary Labels",id:"temporary-labels",depth:3}]}let d=(0,i.e)(function(e){let{toc:n=l(e)}=e,s={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{children:"Klive Z80 Assembly Language Structure"}),"\n",(0,r.jsx)(s.p,{children:"Each line of the source code is a declaration unit and is parsed in its context. Such a source code line can be one of these constructs:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["A Z80 ",(0,r.jsx)(s.em,{children:"instruction"}),", which can be directly compiled to binary code (such as ",(0,r.jsx)(s.code,{children:"ld bc,#12AC"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["A ",(0,r.jsx)(s.em,{children:"directive"})," that is used by the compiler’s preprocessor (e.g. ",(0,r.jsx)(s.code,{children:"#include"}),", ",(0,r.jsx)(s.code,{children:"#if"}),", etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["A ",(0,r.jsx)(s.em,{children:"pragma"})," that emits binary output or instructs the compiler about code emission (",(0,r.jsx)(s.code,{children:".org"}),", ",(0,r.jsx)(s.code,{children:".defb"}),", etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["A ",(0,r.jsx)(s.em,{children:"compiler statement"})," (or shortly, a ",(0,r.jsx)(s.em,{children:"statement"}),") that implements control flow operations for the compiler (e.g., ",(0,r.jsx)(s.code,{children:".loop"}),", ",(0,r.jsx)(s.code,{children:".repeat"}),"..",(0,r.jsx)(s.code,{children:".until"}),", ",(0,r.jsx)(s.code,{children:".if"}),"..",(0,r.jsx)(s.code,{children:".elif"}),"..",(0,r.jsx)(s.code,{children:".else"}),"..",(0,r.jsx)(s.code,{children:".endif"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["A ",(0,r.jsx)(s.em,{children:"comment"})," that helps the understanding of the code."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:n[0].id,children:n[0].value}),"\n",(0,r.jsx)(s.p,{children:"The assembler language uses a unique way of case sensitivity. You can write reserved words (such as assembly instructions, pragmas, or directives) with lowercase or uppercase letters, but you cannot mix these cases. For example, these instructions use the proper syntax:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"LD c,A"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"JP #12ac"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"ldir"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"djnz MyLabel"})})]})}),"\n",(0,r.jsx)(s.p,{children:"However, in these samples, character cases are mixed, and the compiler will refuse them:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"Ld c,A"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"Jp #12ac"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"ldIR"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"djNZ MyLabel"})})]})}),"\n",(0,r.jsx)(s.p,{children:"In symbolic names (labels, identifiers, etc.), you can mix lowercase and uppercase letters. Nonetheless, the compiler applies case-insensitive comparison when matching symbolic names. So, these statement pairs are equivalent to each other:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"jp MainEx"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"jp MAINEX"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"djnz mylabel"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"djnz MyLabel"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"ld hl,ErrNo"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"ld hl,errNo"})})]})}),"\n",(0,r.jsx)(s.h2,{id:n[1].id,children:n[1].value}),"\n",(0,r.jsxs)(s.p,{children:["The language supports two types of comments: ",(0,r.jsx)(s.em,{children:"end-of-line"})," and ",(0,r.jsx)(s.em,{children:"block"})," comments."]}),"\n",(0,r.jsxs)(s.p,{children:["En-of-line comments start with a semicolon (",(0,r.jsx)(s.code,{children:";"}),") or double forward slash (",(0,r.jsx)(s.code,{children:"//"}),"). The compiler takes the rest of the line into account as the body of the comment. This sample illustrates this concept:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"; This line is a comment-only line"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"Wait:   ld b,8     ; Set the counter"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"Wait1:  djnz Wait1 // wait while the counter reaches zero"})})]})}),"\n",(0,r.jsxs)(s.p,{children:["Block comments can be put anywhere within an instruction line between ",(0,r.jsx)(s.code,{children:"/*"})," and ",(0,r.jsx)(s.code,{children:"*/"})," tokens until they do not break other tokens. Nonetheless, block comments cannot span multiple lines; they must start and end within the same source code line. All of the block comments in this code snippet are correct:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"SetAttr:"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"	ld b,32"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"fill:"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  /* block */"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  /* b2 */ ld (hl),a"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  inc /* b3 */ hl"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  djnz /* b4 */ fill /* b5 */"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ret"})})]})}),"\n",(0,r.jsx)(s.p,{children:"However, this will result in a syntax error:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"/* "})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  This block comment spans multiple lines,"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  and thus, it is invalid"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"*/"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"SetAttr:"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"	ld b,32"})})]})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note"}),": If you need multi-line comments, you can add single-line comments after each other. The Z80 assembly does not have separate multi-line comment syntax."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:n[2].id,children:n[2].value}),"\n",(0,r.jsx)(s.p,{children:"The language syntax provides these types of literals:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Boolean values."})," The following tokens represent Booleans: ",(0,r.jsx)(s.code,{children:".false"}),", ",(0,r.jsx)(s.code,{children:"false"}),", ",(0,r.jsx)(s.code,{children:".true"}),", and ",(0,r.jsx)(s.code,{children:"true"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Decimal numbers."})," You can use up to 5 digits (0..9) to declare a decimal number. For example: ",(0,r.jsx)(s.code,{children:"16"}),", ",(0,r.jsx)(s.code,{children:"32768"}),", ",(0,r.jsx)(s.code,{children:"2354"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Floating point numbers."})," You can use the same notation for floating point numbers as in C/C++/Java/C#. Here are a few samples:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:".25"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"123.456"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"12.45E34"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"12.45e-12"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"3e+4"})})]})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Hexadecimal numbers."})," You can use up to 4 hexadecimal digits (0..9, a..f or A..F) to declare a hexadecimal literal. The compiler looks for a ",(0,r.jsx)(s.code,{children:"#"}),", ",(0,r.jsx)(s.code,{children:"0x"}),", or ",(0,r.jsx)(s.code,{children:"$"})," prefix or one of the ",(0,r.jsx)(s.code,{children:"h"})," or ",(0,r.jsx)(s.code,{children:"H"})," suffixes to recognize them as hexadecimal. If you use the ",(0,r.jsx)(s.code,{children:"h"})," or ",(0,r.jsx)(s.code,{children:"H"})," suffixes, the hexadecimal number should start with a decimal digit ",(0,r.jsx)(s.code,{children:"0"}),"…",(0,r.jsx)(s.code,{children:"9"}),"; otherwise, the assembler interprets it as an identifier (label). Here are a few samples:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"#12AC"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"0x12ac"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"$12Ac"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"12ACh"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"12acH"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"0AC34H"})})]})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Binary numbers."})," Literals starting with one of the ",(0,r.jsx)(s.code,{children:"%"}),", or ",(0,r.jsx)(s.code,{children:"0b"})," prefixes (or with the ",(0,r.jsx)(s.code,{children:"b"})," or ",(0,r.jsx)(s.code,{children:"B"})," suffix) are considered binary literals. You can follow the prefix with up to 16 ",(0,r.jsx)(s.code,{children:"0"})," or ",(0,r.jsx)(s.code,{children:"1"})," digits. To make them more readable, you can separate adjacent digits with the underscore (",(0,r.jsx)(s.code,{children:"_"}),") or single quote (",(0,r.jsx)(s.code,{children:"'"}),") character. These are all valid binary literals:"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"%01011111"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"0b01011111"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"0b_0101_1111"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"0101_1111b"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"0b'0101'1111"})})]})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Octal numbers."})," You can use up to 6 digits (0..7) with an ",(0,r.jsx)(s.code,{children:"o"}),", ",(0,r.jsx)(s.code,{children:"O"})," (letter O), ",(0,r.jsx)(s.code,{children:"q"}),", or ",(0,r.jsx)(s.code,{children:"Q"})," suffix to declare an octal number. Examples: ",(0,r.jsx)(s.code,{children:"16o"}),", ",(0,r.jsx)(s.code,{children:"327q"}),", ",(0,r.jsx)(s.code,{children:"2354Q"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note"}),": You can use negative numbers with the minus sign in front of them. The sign is not part of the numeric literal; it is an operator."]}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Characters"}),". You can put a character between single quotes (for example: ",(0,r.jsx)(s.code,{children:"'Q'"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Strings"}),". You can put a series of characters between double quotes (for example: ",(0,r.jsx)(s.code,{children:'"Sinclair"'}),")."]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note"}),": You can use escape sequences to define non-visible or control characters, as you will learn soon."]}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["The ",(0,r.jsx)(s.code,{children:"$"}),", ",(0,r.jsx)(s.code,{children:"*"})," or ",(0,r.jsx)(s.code,{children:"."})," tokens"]}),". These literals are equivalent; all represent the current assembly address."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:n[3].id,children:n[3].value}),"\n",(0,r.jsxs)(s.p,{children:["You can use identifiers to refer to labels and other constants. Identifiers must start with a letter (a…z or A…Z) or with one of these characters: ",(0,r.jsx)(s.code,{children:"`"})," (backtick), ",(0,r.jsx)(s.code,{children:"_"})," (underscore), ",(0,r.jsx)(s.code,{children:"@"}),", ",(0,r.jsx)(s.code,{children:"!"}),", ",(0,r.jsx)(s.code,{children:"?"}),", or ",(0,r.jsx)(s.code,{children:"#"}),". The subsequent ones can be digits and any start characters except backtick. Here are a few examples:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"MyCycle"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"ERR_NO"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"Cycle_4_Wait"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"`MyTemp"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"@ModLocal"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"IsLastLine?"})})]})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note"}),": Some strings can be identifiers or hexadecimal literals with the ",(0,r.jsx)(s.code,{children:"H"})," or ",(0,r.jsx)(s.code,{children:"h"})," suffix, like ",(0,r.jsx)(s.code,{children:"AC0Fh"}),", or ",(0,r.jsx)(s.code,{children:"FADH"}),". The assembler considers such strings as identifiers. To sign a hexadecimal literal, use a ",(0,r.jsx)(s.code,{children:"0"})," prefix: ",(0,r.jsx)(s.code,{children:"0FADH"})," is a hexadecimal literal, while ",(0,r.jsx)(s.code,{children:"FADH"})," is an identifier."]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note"}),": Theoretically, you can use arbitrary long identifiers. I suggest you make them no longer than 32 characters so readers can read your code easily."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:n[4].id,children:n[4].value}),"\n",(0,r.jsx)(s.p,{children:"As you will later learn, the Klive Assembler supports modules like namespaces in other languages (Java, C#, C++, etc.) to encapsulate labels and symbols. To access symbols within modules, you can use scoped identifiers with this syntax:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"::"}),"? ",(0,r.jsx)(s.em,{children:"identifier"})," (",(0,r.jsx)(s.code,{children:"."})," ",(0,r.jsx)(s.em,{children:"identifier"}),")*"]}),"\n",(0,r.jsxs)(s.p,{children:["The optional ",(0,r.jsx)(s.code,{children:"::"})," token means the name should start in the outermost (global) scope. The module and identifier segments are separated with a dot. Examples:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"::FirstLevelModule.Routine1"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"NestedModule.ClearScreen"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"FirstLevelModule.NestedModule.ClearScreen"})})]})}),"\n",(0,r.jsx)(s.h2,{id:n[5].id,children:n[5].value}),"\n",(0,r.jsx)(s.p,{children:"You have already learned that you can utilize character and string literals (wrapped into single or double quotes, respectively), such as in these samples:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:'"This is a string. The next sample is a single character:"'})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"'c'"})})]})}),"\n",(0,r.jsx)(s.p,{children:"ZX Spectrum has a character set with special control characters such as AT, INK, PAPER, etc. The Assembler allows you to define these with special escape sequences:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Escape"}),(0,r.jsx)(s.th,{children:"Code"}),(0,r.jsx)(s.th,{children:"Character"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\i"})}),(0,r.jsx)(s.td,{children:"0x10"}),(0,r.jsx)(s.td,{children:"INK"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\p"})}),(0,r.jsx)(s.td,{children:"0x11"}),(0,r.jsx)(s.td,{children:"PAPER"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\f"})}),(0,r.jsx)(s.td,{children:"0x12"}),(0,r.jsx)(s.td,{children:"FLASH"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\b"})}),(0,r.jsx)(s.td,{children:"0x13"}),(0,r.jsx)(s.td,{children:"BRIGHT"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\I"})}),(0,r.jsx)(s.td,{children:"0x14"}),(0,r.jsx)(s.td,{children:"INVERSE"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\o"})}),(0,r.jsx)(s.td,{children:"0x15"}),(0,r.jsx)(s.td,{children:"OVER"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\a"})}),(0,r.jsx)(s.td,{children:"0x16"}),(0,r.jsx)(s.td,{children:"AT"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\t"})}),(0,r.jsx)(s.td,{children:"0x17"}),(0,r.jsx)(s.td,{children:"TAB"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\P"})}),(0,r.jsx)(s.td,{children:"0x60"}),(0,r.jsx)(s.td,{children:"pound sign"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\C"})}),(0,r.jsx)(s.td,{children:"0x7F"}),(0,r.jsx)(s.td,{children:"copyright sign"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\\\"})}),(0,r.jsx)(s.td,{children:"0x5C"}),(0,r.jsx)(s.td,{children:"backslash"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\'"})}),(0,r.jsx)(s.td,{children:"0x27"}),(0,r.jsx)(s.td,{children:"single quote"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:'\\"'})}),(0,r.jsx)(s.td,{children:"0x22"}),(0,r.jsx)(s.td,{children:"double quote"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"\\0"})}),(0,r.jsx)(s.td,{children:"0x00"}),(0,r.jsx)(s.td,{children:"binary zero"})]})]})]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Note"}),": Some of these sequences have different values than their corresponding pairs in other languages, such as C, C++, C#, or Java."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["To declare a character by its binary code, you can use the ",(0,r.jsx)(s.code,{children:"\\xH"})," or",(0,r.jsx)(s.br,{}),"\n",(0,r.jsx)(s.code,{children:"\\xHH"})," sequences (",(0,r.jsx)(s.code,{children:"H"})," is a hexadecimal digit). For example, these\nescape sequence pairs are equivalent:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:'"\\i"'})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:'"\\x10"'})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:'"\\C by me"'})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:'"\\x7f \\x62y me"'})})]})}),"\n",(0,r.jsx)(s.h2,{id:n[6].id,children:n[6].value}),"\n",(0,r.jsx)(s.p,{children:"In Klive Z80 Assembly, you can define labels and symbols. Both constructs are syntactically the same, but there is some difference in their semantics. While we define labels to mark addresses (code points) in the program so that we can jump to those addresses and read or write their contents, symbols are not as specific; they just store values we intend to use."}),"\n",(0,r.jsx)(s.p,{children:"From now on, I will mention “label” for both constructs and do otherwise only when the context requires it."}),"\n",(0,r.jsx)(s.p,{children:"When you write a Klive Assembly instruction, you can start the line with a label:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsx)(s.code,{children:(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"MyStart: ld hl,0"})})})}),"\n",(0,r.jsxs)(s.p,{children:["Here, in this sample, ",(0,r.jsx)(s.code,{children:"MyStart"})," is a label. The assembler allows you to omit the colon after the label name, so this line is valid:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsx)(s.code,{children:(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"MyStart ld hl,0"})})})}),"\n",(0,r.jsxs)(s.p,{children:["Some developers like to put a label in a separate line from the instruction to which it belongs. You can use the same hanging label style within Klive. In this case, the label should go ",(0,r.jsx)(s.em,{children:"before"})," its instruction. Take a look at this code snippet:"]}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"MyStart:"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld hl,0"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"MyNext"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ; Use B as a counter"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld b,32"})})]})}),"\n",(0,r.jsxs)(s.p,{children:["This code is entirely correct. Note the ",(0,r.jsx)(s.code,{children:"ld b,32"})," instruction belongs to the ",(0,r.jsx)(s.code,{children:"MyNext"})," label. As you see from the sample, the colon character is optional for hanging labels, too. You can have multiple line breaks between a label and its instruction, and the space can include comments."]}),"\n",(0,r.jsx)(s.h3,{id:n[7].id,children:n[7].value}),"\n",(0,r.jsxs)(s.p,{children:["As you will learn later, you can define symbols with the ",(0,r.jsx)(s.code,{children:".EQU"})," or ",(0,r.jsx)(s.code,{children:".VAR"})," pragmas. While ",(0,r.jsx)(s.code,{children:".EQU"})," allows you to assign a constant value to a symbol, it cannot change its value after the declaration. ",(0,r.jsx)(s.code,{children:".VAR"})," lets you re-assign the initial value."]}),"\n",(0,r.jsxs)(s.p,{children:["Klive supports the idea of lexical scopes. When you create the program, it starts with a global (outermost) lexical scope. Particular language elements, such a ",(0,r.jsx)(s.em,{children:"statements"})," create their nested lexical scope. Labels and symbols are always created within the current lexical scope. Nonetheless, when resolving them, the assembler starts with the innermost scope and goes through all outer scopes until it finds the label declaration."]}),"\n",(0,r.jsx)(s.p,{children:"This mechanism means that you can declare labels within a nested scope so that those hide labels and symbols in outer scopes."}),"\n",(0,r.jsx)(s.p,{children:"Klive also supports modules, which allow you to use namespace-like constructs."}),"\n",(0,r.jsx)(s.h3,{id:n[8].id,children:n[8].value}),"\n",(0,r.jsx)(s.p,{children:"The assembler considers labels that start with a backtick (`) character as temporary labels. Their scope is the area between the last persistent label preceding the temporary one and the first persistent label following the temporary one."}),"\n",(0,r.jsx)(s.p,{children:"This code snippet demonstrates this concept:"}),"\n",(0,r.jsx)(s.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,r.jsxs)(s.code,{children:[(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"SetPixels:        ; Persistent label"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld hl, #4000"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld a,#AA"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld b,#20"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"`loop:            ; Temporary label (scope #1)"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld (hl),a"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  inc hl"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  djnz `loop"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"SetAttr:          ; Persistent label, scope #1 disposed here"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld hl,#5800"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld a,#32"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld b,#20"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"`loop:            ; Temporary label (scope #2)"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld (hl),a"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  inc hl"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  djnz `loop"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ret"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"; scope #2 still lives here"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"; ..."})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"Another: ; Persistent label, scope #2 disposed here"})}),"\n",(0,r.jsx)(s.span,{children:(0,r.jsx)(s.span,{children:"  ld a,b"})})]})}),"\n",(0,r.jsxs)(s.p,{children:["As you see, the two occurrences of ",(0,r.jsx)(s.code,{children:" `loop"}),"  belong to two separate temporary scopes. The first scope is the one between ",(0,r.jsx)(s.code,{children:"SetPixels"})," and ",(0,r.jsx)(s.code,{children:"SetAttr"}),", the second one between ",(0,r.jsx)(s.code,{children:"SetAttr"})," and ",(0,r.jsx)(s.code,{children:"Another"}),"."]})]})},"/z80-assembly/language-structure",{filePath:"pages/z80-assembly/language-structure.mdx",pageMap:t.O,frontMatter:{},title:"Klive Z80 Assembly Language Structure"},"undefined"==typeof RemoteContent?l:RemoteContent.useTOC)},2421:(e,n,s)=>{"use strict";s.d(n,{O:()=>r});let r=[{data:{index:"Introduction","getting-started":"Getting Started","working-with-ide":"Working with the IDE",howto:"How To","z80-assembly":"Klive Z80 Assembler",scripting:"Scripting","command-reference":"Command Reference","machine-types":"Machine Types"}},{name:"command-reference",route:"/command-reference",frontMatter:{sidebarTitle:"Command Reference"}},{name:"getting-started",route:"/getting-started",children:[{data:{installation:"Installing Klive","first-run":"Running Klive",keyboard:"Using the Keyboard",tapes:"Loading from Tape","save-programs":"Saving Files","creating-project":"Creating a Klive Project"}},{name:"creating-project",route:"/getting-started/creating-project",frontMatter:{sidebarTitle:"Creating Project"}},{name:"first-run",route:"/getting-started/first-run",frontMatter:{sidebarTitle:"First Run"}},{name:"installation",route:"/getting-started/installation",frontMatter:{sidebarTitle:"Installation"}},{name:"keyboard",route:"/getting-started/keyboard",frontMatter:{sidebarTitle:"Keyboard"}},{name:"save-programs",route:"/getting-started/save-programs",frontMatter:{sidebarTitle:"Save Programs"}},{name:"tapes",route:"/getting-started/tapes",frontMatter:{sidebarTitle:"Tapes"}}]},{name:"howto",route:"/howto",children:[{data:{"file-extensions":"Changing default file extensions","instant-screen":"Using the Instant Screen"}},{name:"file-extensions",route:"/howto/file-extensions",frontMatter:{sidebarTitle:"File Extensions"}},{name:"instant-screen",route:"/howto/instant-screen",frontMatter:{sidebarTitle:"Instant Screen"}}]},{name:"index",route:"/",frontMatter:{sidebarTitle:"Index"}},{name:"machine-types",route:"/machine-types",frontMatter:{sidebarTitle:"Machine Types"}},{name:"project-templates",route:"/project-templates",frontMatter:{sidebarTitle:"Project Templates"}},{name:"scripting",route:"/scripting",children:[{data:{overview:"Overview",syntax:"Scripting Syntax"}},{name:"overview",route:"/scripting/overview",frontMatter:{sidebarTitle:"Overview"}},{name:"syntax",route:"/scripting/syntax",frontMatter:{sidebarTitle:"Syntax"}}]},{name:"working-with-ide",route:"/working-with-ide",children:[{data:{"project-explorer":"The Project Explorer","editing-code":"Editing Code","run-debug":"Running & Debugging Code",zxb:"ZXBASIC Integration","ide-settings":"IDE Settings",cpu:"The CPU View",ula:"The ULA View",memory:"The Memory View",disassembly:"The Disassembly View",breakpoints:"The Breakpoints View","system-vars":"The System Variables View",basic:"The BASIC Listing",commands:"Interactive Commands","build-system":"The Build System"}},{name:"basic",route:"/working-with-ide/basic",frontMatter:{sidebarTitle:"Basic"}},{name:"breakpoints",route:"/working-with-ide/breakpoints",frontMatter:{sidebarTitle:"Breakpoints"}},{name:"build-system",route:"/working-with-ide/build-system",frontMatter:{sidebarTitle:"Build System"}},{name:"commands",route:"/working-with-ide/commands",frontMatter:{sidebarTitle:"Commands"}},{name:"cpu",route:"/working-with-ide/cpu",frontMatter:{sidebarTitle:"Cpu"}},{name:"disassembly",route:"/working-with-ide/disassembly",frontMatter:{sidebarTitle:"Disassembly"}},{name:"editing-code",route:"/working-with-ide/editing-code",frontMatter:{sidebarTitle:"Editing Code"}},{name:"ide-settings",route:"/working-with-ide/ide-settings",frontMatter:{sidebarTitle:"Ide Settings"}},{name:"memory",route:"/working-with-ide/memory",frontMatter:{sidebarTitle:"Memory"}},{name:"project-explorer",route:"/working-with-ide/project-explorer",frontMatter:{sidebarTitle:"Project Explorer"}},{name:"run-debug",route:"/working-with-ide/run-debug",frontMatter:{sidebarTitle:"Run Debug"}},{name:"system-vars",route:"/working-with-ide/system-vars",frontMatter:{sidebarTitle:"System Vars"}},{name:"ula",route:"/working-with-ide/ula",frontMatter:{sidebarTitle:"Ula"}},{name:"zxb",route:"/working-with-ide/zxb",frontMatter:{sidebarTitle:"Zxb"}}]},{name:"z80-assembly",route:"/z80-assembly",children:[{data:{"z80-assembler":"Assembler Overview","language-structure":"Language Structure",expressions:"Expressions","z80-instructions":"Z80 Instructions",pragmas:"Pragmas",statements:"Assembler Statements",macros:"Macros",structs:"Structs"}},{name:"expressions",route:"/z80-assembly/expressions",frontMatter:{sidebarTitle:"Expressions"}},{name:"language-structure",route:"/z80-assembly/language-structure",frontMatter:{sidebarTitle:"Language Structure"}},{name:"macros",route:"/z80-assembly/macros",frontMatter:{sidebarTitle:"Macros"}},{name:"pragmas",route:"/z80-assembly/pragmas",frontMatter:{sidebarTitle:"Pragmas"}},{name:"statements",route:"/z80-assembly/statements",frontMatter:{sidebarTitle:"Statements"}},{name:"structs",route:"/z80-assembly/structs",frontMatter:{sidebarTitle:"Structs"}},{name:"z80-assembler",route:"/z80-assembly/z80-assembler",frontMatter:{sidebarTitle:"Z80 Assembler"}},{name:"z80-instructions",route:"/z80-assembly/z80-instructions",frontMatter:{sidebarTitle:"Z80 Instructions"}}]}]}},e=>{var n=n=>e(e.s=n);e.O(0,[849,636,593,792],()=>n(5276)),_N_E=e.O()}]);