(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6983],{5969:(e,s,n)=>{"use strict";n.r(s),n.d(s,{default:()=>a,useTOC:()=>o});var r=n(7876),t=n(1807),i=n(8964),l=n(9707);function o(e){return[{value:"The Z80: A 1976 Design That Refused to Die",id:"the-z80-a-1976-design-that-refused-to-die",depth:2},{value:"Core Architecture: What Makes a Z80 a Z80",id:"core-architecture-what-makes-a-z80-a-z80",depth:2},{value:"The Register Set: More Than It Looks",id:"the-register-set-more-than-it-looks",depth:3},{value:"The Flags: How the CPU Remembers What Just Happened",id:"the-flags-how-the-cpu-remembers-what-just-happened",depth:3},{value:"Memory Addressing: 16 Bits of Reach",id:"memory-addressing-16-bits-of-reach",depth:3},{value:"Instruction Categories: What Can This Thing Do?",id:"instruction-categories-what-can-this-thing-do",depth:2},{value:"Data Movement: Getting Bytes Where They Need to Be",id:"data-movement-getting-bytes-where-they-need-to-be",depth:3},{value:"Arithmetic and Logic: Making Numbers Dance",id:"arithmetic-and-logic-making-numbers-dance",depth:3},{value:"Bit Operations: Twiddling Individual Bits",id:"bit-operations-twiddling-individual-bits",depth:3},{value:"Control Flow: Making Decisions and Loops",id:"control-flow-making-decisions-and-loops",depth:3},{value:"Stack Operations: Last In, First Out",id:"stack-operations-last-in-first-out",depth:3},{value:"Block Operations: When You Need to Move Data in Bulk",id:"block-operations-when-you-need-to-move-data-in-bulk",depth:3},{value:"Z80N Extensions: What the Next Adds",id:"z80n-extensions-what-the-next-adds",depth:2},{value:"Motivation: Why Add Instructions at All?",id:"motivation-why-add-instructions-at-all",depth:3},{value:"New Load Instructions",id:"new-load-instructions",depth:3},{value:"Push Immediate Values",id:"push-immediate-values",depth:3},{value:"Extended Register Operations",id:"extended-register-operations",depth:3},{value:"Test and Set: Atomic Bit Operations",id:"test-and-set-atomic-bit-operations",depth:3},{value:"Mirror Operations",id:"mirror-operations",depth:3},{value:"Multiply Operations",id:"multiply-operations",depth:3},{value:"Extended Addressing Modes",id:"extended-addressing-modes",depth:3},{value:"Stack Frame Operations",id:"stack-frame-operations",depth:3},{value:"Swap Operations",id:"swap-operations",depth:3},{value:"Barrel Shift Operations",id:"barrel-shift-operations",depth:3},{value:"Practical Considerations: Writing Z80N Code",id:"practical-considerations-writing-z80n-code",depth:2},{value:"When to Use Z80N Instructions",id:"when-to-use-z80n-instructions",depth:3},{value:"Cycle Timing Matters",id:"cycle-timing-matters",depth:3},{value:"Register Allocation Strategy",id:"register-allocation-strategy",depth:3},{value:"Summary: Z80 and Z80N in the Next",id:"summary-z80-and-z80n-in-the-next",depth:2}]}let a=(0,t.e)(function(e){let{toc:s=o(e)}=e,n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{children:"The Z80 and Z80N: Processor Overview"}),"\n",(0,r.jsx)(n.p,{children:"To build a ZX Spectrum Next emulator, you need to understand the processor at its heart. This chapter covers the Zilog Z80 architecture and the Z80N extensions specific to the Next - not as a complete tutorial, but as a focused overview of what matters for emulation. We’ll look at registers, addressing modes, instruction categories, and the new Z80N opcodes that make the Next more than just a faster Spectrum."}),"\n",(0,r.jsx)(n.h2,{id:s[0].id,children:s[0].value}),"\n",(0,r.jsx)(n.p,{children:"The Zilog Z80 debuted in 1976 as an enhanced, binary-compatible version of Intel’s 8080. While Intel moved on to the 8086 and beyond, the Z80 found a home in everything from arcade games to home computers to industrial controllers. By the time the ZX Spectrum shipped in 1982, the Z80 was already considered mature - yet here we are in the 2020s, still building machines around this architecture."}),"\n",(0,r.jsxs)(n.p,{children:["Why? Because the Z80 hit a sweet spot: ",(0,r.jsx)(n.strong,{children:"powerful enough to be useful, simple enough to understand completely"}),". You can hold the entire instruction set in your head (well, most of it). The architecture makes sense. There are no hidden microcode layers, no speculative execution, no cache coherency protocols. What you see is what you get, and what you get is enough to build surprisingly sophisticated software."]}),"\n",(0,r.jsx)(n.p,{children:"The Z80N in the ZX Spectrum Next is a cycle-accurate recreation implemented in FPGA, with carefully chosen extensions that add modern conveniences without breaking the fundamental character of the original design. It’s still recognizably a Z80, just with some quality-of-life improvements that would have been impossible in 1976."}),"\n",(0,r.jsx)(n.h2,{id:s[1].id,children:s[1].value}),"\n",(0,r.jsx)(n.p,{children:"Before diving into instructions, you need to understand what you’re working with: the Z80’s internal architecture. Registers, flags, and addressing modes form the foundation everything else builds on."}),"\n",(0,r.jsx)(n.h3,{id:s[2].id,children:s[2].value}),"\n",(0,r.jsxs)(n.p,{children:["The Z80 has an unusual register architecture: it appears to have only seven 8-bit registers (A, B, C, D, E, H, L) plus the accumulator… but these are actually ",(0,r.jsx)(n.strong,{children:"two complete sets"})," that you can swap with a single instruction (",(0,r.jsx)(n.code,{children:"EX AF,AF'"})," or ",(0,r.jsx)(n.code,{children:"EXX"}),"). This gives you:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Main register set:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"A"})," (accumulator): Primary register for arithmetic, logic, and I/O"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"F"})," (flags): Status bits (zero, carry, sign, etc.) - not directly accessible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"BC"}),", ",(0,r.jsx)(n.code,{children:"DE"}),", ",(0,r.jsx)(n.code,{children:"HL"}),": Three 16-bit register pairs (can be used as 8-bit or 16-bit)\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HL"})," is special - most operations treat it as “the” pointer register"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Alternate register set:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"A'"}),", ",(0,r.jsx)(n.code,{children:"F'"}),": Alternate accumulator and flags"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"BC'"}),", ",(0,r.jsx)(n.code,{children:"DE'"}),", ",(0,r.jsx)(n.code,{children:"HL'"}),": Alternate versions of the register pairs"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why the duplicates?"})," Fast context switching. Writing interrupt handlers? Swap to the alternate set with ",(0,r.jsx)(n.code,{children:"EX AF,AF'"})," and ",(0,r.jsx)(n.code,{children:"EXX"}),", do your work, swap back. No pushing/popping dozens of bytes on the stack. It’s beautifully efficient when you need it, but many programs never touch the alternate set."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Special purpose registers:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"IX"}),", ",(0,r.jsx)(n.code,{children:"IY"}),": 16-bit index registers for displacement addressing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SP"}),": Stack pointer (grows downward from high memory)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PC"}),": Program counter (where execution currently is)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"I"}),": Interrupt vector register (high byte for IM2 mode)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"R"}),": Memory refresh counter (increments each instruction, used for DRAM refresh)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:s[3].id,children:s[3].value}),"\n",(0,r.jsx)(n.p,{children:"The F register contains status flags that reflect the result of the last operation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Z (Zero)"}),": Set if result was zero"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"C (Carry)"}),": Set if arithmetic generated a carry or borrow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"S (Sign)"}),": Reflects bit 7 of result (negative if set, treating values as signed)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"P/V (Parity/Overflow)"}),": Means parity for logical ops, overflow for arithmetic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"N (Add/Subtract)"}),": Set if last operation was a subtraction (used by ",(0,r.jsx)(n.code,{children:"DAA"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"H (Half-carry)"}),": Carry from bit 3 to bit 4 (also used by ",(0,r.jsx)(n.code,{children:"DAA"})," for BCD math)"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"BCD (Binary Coded Decimal)"}),": A numbering system where each byte represents two decimal digits (0-99), with 0x00-0x09 valid in each nibble. The ",(0,r.jsx)(n.code,{children:"DAA"})," instruction converts after addition/subtraction to maintain BCD format. Used in calculators and financial software where decimal precision matters more than speed."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Conditional jumps and calls test these flags: ",(0,r.jsx)(n.code,{children:"JP Z,label"}),", ",(0,r.jsx)(n.code,{children:"CALL NC,subroutine"}),", etc. The flags update automatically after most arithmetic and logical operations, but not after loads or bit operations."]}),"\n",(0,r.jsx)(n.h3,{id:s[4].id,children:s[4].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 has a 16-bit address bus, giving it a 64KB address space (0x0000 to 0xFFFF). That’s it - no banking, no segments, no MMU from the CPU’s perspective. When later systems needed more memory (like the Spectrum 128K or Next’s 2MB), they added external hardware to page different memory banks into the Z80’s view."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Addressing modes"})," determine how the CPU interprets operands:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Immediate"}),": Value is part of the instruction"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"42"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"        "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Load literal 42 into A"})]})})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Register direct"}),": Value comes from a register"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,B         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Copy B into A"})]})})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Register indirect"}),": Register contains an address to read from"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,(HL)      "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Load from memory address in HL"})]})})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Indexed with displacement"}),": Base address + signed offset"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,(IX+"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"5"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:")    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Load from address in IX plus 5"})]})})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Extended (absolute)"}),": 16-bit address in the instruction"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,("}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x4000"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:")  "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Load from address 0x4000"})]})})}),"\n",(0,r.jsxs)(n.p,{children:["The choice of addressing mode affects both ",(0,r.jsx)(n.strong,{children:"speed"})," (immediate is fast, indexed is slow) and ",(0,r.jsx)(n.strong,{children:"code size"})," (direct is compact, extended needs 2 extra bytes)."]}),"\n",(0,r.jsx)(n.h2,{id:s[5].id,children:s[5].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 instruction set divides roughly into categories by function. Understanding these categories helps you pick the right tool for each job - and spot when you’re using an expensive instruction where a cheap one would work."}),"\n",(0,r.jsx)(n.h3,{id:s[6].id,children:s[6].value}),"\n",(0,r.jsxs)(n.p,{children:["The Z80 has a powerful ",(0,r.jsx)(n.code,{children:"LD"})," (load) instruction with dozens of variants:"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"42"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Immediate to register (7 cycles)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,B          "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Register to register (4 cycles)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,(HL)       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Memory to register (7 cycles)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD (HL),A       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Register to memory (7 cycles)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD HL,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x4000"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; 16-bit immediate to register pair (10 cycles)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,("}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x5C00"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:")   "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Memory to A using absolute address (13 cycles)"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["There’s also ",(0,r.jsx)(n.code,{children:"LDI"})," and ",(0,r.jsx)(n.code,{children:"LDIR"})," for block moves - ",(0,r.jsx)(n.code,{children:"LDIR"})," copies ",(0,r.jsx)(n.code,{children:"BC"})," bytes from ",(0,r.jsx)(n.code,{children:"HL"})," to ",(0,r.jsx)(n.code,{children:"DE"})," automatically. One instruction, hundreds of bytes moved. Perfect for copying graphics data or clearing memory."]}),"\n",(0,r.jsx)(n.h3,{id:s[7].id,children:s[7].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 provides comprehensive arithmetic and logical operations, with separate instruction sets for 8-bit and 16-bit values. Most operations automatically update flags, making conditional execution straightforward."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"8-bit arithmetic:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A,B         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A + B (sets flags)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A,C         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A + C + carry flag (for multi-byte math)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"SUB"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" D           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A - D"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SBC A,E         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A - E - carry flag"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"INC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A + 1 (doesn't affect carry!)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"DEC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" B           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; B = B - 1"})]})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"16-bit arithmetic:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL,BC       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; HL = HL + BC (16-bit addition)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL,DE       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; HL = HL + DE + carry (for 32-bit math)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SBC HL,BC       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; HL = HL - BC - carry"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"INC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL          "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; HL = HL + 1 (doesn't affect flags)"})]})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Logical operations:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"AND"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" B           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A & B (bitwise AND)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"OR"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" C            "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A | C (bitwise OR)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"XOR"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" D           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = A ^ D (bitwise XOR)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"CP E            "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Compare A with E (A - E, update flags, discard result)"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"CP"})," instruction is clever - it performs subtraction just to set flags, then throws away the result. Perfect for testing values without destroying them."]}),"\n",(0,r.jsx)(n.h3,{id:s[8].id,children:s[8].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 has dedicated bit manipulation instructions:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"BIT "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"3"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:",A         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Test if bit 3 of A is set (updates Z flag)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SET "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"5"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:",B         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Set bit 5 of B to 1"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"RES "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"2"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:",C         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Reset bit 2 of C to 0"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["These are ",(0,r.jsx)(n.strong,{children:"slow"})," when operating on memory via ",(0,r.jsx)(n.code,{children:"(HL)"})," or indexed - they take 15+ cycles. But for register operations, they’re clean and readable."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rotate and shift:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"RLA             "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Rotate A left through carry"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"RRA             "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Rotate A right through carry"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"RLC A           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Rotate A left (bit 7 -> bit 0, also -> carry)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SLA B           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Shift B left (bit 7 -> carry, 0 -> bit 0)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SRL C           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Shift C right logical (0 -> bit 7, bit 0 -> carry)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SRA D           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Shift D right arithmetic (bit 7 preserved, bit 0 -> carry)"})]})]})}),"\n",(0,r.jsx)(n.h3,{id:s[9].id,children:s[9].value}),"\n",(0,r.jsx)(n.p,{children:"Programs need to make decisions and repeat operations. The Z80 provides jumps, calls, and returns in both conditional and unconditional forms, plus specialized loop instructions."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Unconditional jumps:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"JP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x4000"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump to absolute address"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"JR label        "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump relative (-126 to +129 bytes, smaller/faster)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"JP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" (HL)         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump to address in HL (not a memory read!)"})]})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Conditional jumps:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"JP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" Z,label      "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump if Zero flag set"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"JP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" NZ,label     "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump if Zero flag clear"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"JP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" C,label      "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump if Carry flag set"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"JR NC,label     "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Relative jump if No Carry"})]})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Subroutines:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"CALL"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" subroutine "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Push PC to stack, jump to address"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"RET"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"             "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Pop return address from stack, jump there"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"RET"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" Z           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Return if Zero flag set"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"JR"})," (jump relative) instructions are faster and smaller than ",(0,r.jsx)(n.code,{children:"JP"})," when the target is nearby. They use a signed 8-bit offset, so they can reach -126 to +129 bytes from the current position."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Loops using DJNZ:"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    LD B,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"10"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Loop counter"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"loop"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:":"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; ... do something 10 times ..."})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    DJNZ "}),(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"loop"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Decrement B, jump if not zero"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"DJNZ"})," (Decrement and Jump if Not Zero) is a single instruction that decrements B and jumps if the result isn’t zero. Compact loop construct that costs just 13 cycles when it branches."]}),"\n",(0,r.jsx)(n.h3,{id:s[10].id,children:s[10].value}),"\n",(0,r.jsxs)(n.p,{children:["The stack starts at high memory and grows downward. The stack pointer (",(0,r.jsx)(n.code,{children:"SP"}),") points to the last pushed value."]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"PUSH"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" BC         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; SP -= 2, write BC to stack"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"POP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" DE          "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Read from stack into DE, SP += 2"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"PUSH"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" AF         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Save accumulator and flags"})]})]})}),"\n",(0,r.jsx)(n.p,{children:"The stack is crucial for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subroutine calls"}),": ",(0,r.jsx)(n.code,{children:"CALL"})," pushes the return address, ",(0,r.jsx)(n.code,{children:"RET"})," pops it"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interrupts"}),": Hardware automatically pushes ",(0,r.jsx)(n.code,{children:"PC"})," when an interrupt fires"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Temporary storage"}),": Need an extra register? Push one to the stack"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["But stack operations are slow (memory accesses), so don’t use PUSH/POP for quick register swaps - that’s what ",(0,r.jsx)(n.code,{children:"EX"})," and ",(0,r.jsx)(n.code,{children:"EXX"})," are for."]}),"\n",(0,r.jsx)(n.h3,{id:s[11].id,children:s[11].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 has powerful block instructions that operate on entire memory regions:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LDI             "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; (DE) = (HL), increment HL and DE, decrement BC"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LDIR            "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Repeat LDI until BC = 0 (auto-loop)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"CPI             "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Compare A with (HL), increment HL, decrement BC"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"CPIR            "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Repeat CPI until BC = 0 or A = (HL)"})]})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example: Clear 256 bytes of screen memory"})}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    LD HL,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x4000"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Source (will be incremented)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    LD DE,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x4001"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Destination (one byte higher)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    LD BC,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"255"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Count (256 - 1, we handle first byte separately)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    LD (HL),"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Clear first byte"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    LDIR            "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Fill rest with zeros (copies 0x4000 to 0x4001, then 0x4001 to 0x4002, etc.)"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["This trick uses ",(0,r.jsx)(n.code,{children:"LDIR"})," to propagate a single zero byte across memory. Classic Z80 optimization."]}),"\n",(0,r.jsx)(n.h2,{id:s[12].id,children:s[12].value}),"\n",(0,r.jsxs)(n.p,{children:["The Z80N extends the original instruction set with new opcodes that live in previously undefined instruction space. All original Z80 software runs unchanged - the new instructions use opcodes the original Z80 would execute as ",(0,r.jsx)(n.code,{children:"NOP"})," or invalid."]}),"\n",(0,r.jsx)(n.h3,{id:s[13].id,children:s[13].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 instruction set has gaps - operations that require awkward multi-instruction sequences. The Z80N additions focus on:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Register operations"})," that save cycles in common patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stack manipulation"})," for cleaner function prologues/epilogues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bit manipulation"})," that’s faster and more flexible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory access"})," with new addressing modes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware access"})," specific to Next features"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:s[14].id,children:s[14].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"LD (nn),BC / LD (nn),DE / LD (nn),HL"})}),"\n",(0,r.jsx)(n.p,{children:"The original Z80 can load register pairs from memory but not store them directly:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Original Z80 - storing BC to memory requires two instructions:"})}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD (addr),C"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD (addr+"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"1"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"),B"})]}),"\n",(0,r.jsx)(n.span,{children:" "}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N - single instruction:"})}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD (addr),BC"})})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"LD BC/DE/HL,(nn)"})}),"\n",(0,r.jsx)(n.p,{children:"Similarly, loading 16-bit values is now symmetric:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N - load BC from memory:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD BC,("}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x5C78"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:")"})]})]})}),"\n",(0,r.jsx)(n.p,{children:"These save cycles and code space in common operations like saving/restoring pointers."}),"\n",(0,r.jsx)(n.h3,{id:s[15].id,children:s[15].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"PUSH nn"})}),"\n",(0,r.jsx)(n.p,{children:"The original Z80 can’t push immediate values to the stack:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Original Z80:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD HL,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x1234"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"PUSH"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL"})]}),"\n",(0,r.jsx)(n.span,{children:" "}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"PUSH"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x1234"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"     "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Directly push 16-bit value"})]})]})}),"\n",(0,r.jsx)(n.p,{children:"Saves 2 bytes and multiple cycles when setting up stack frames or passing constant parameters."}),"\n",(0,r.jsx)(n.h3,{id:s[16].id,children:s[16].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NEXTREG reg,value"})}),"\n",(0,r.jsx)(n.p,{children:"This is Z80N’s killer feature for Next-specific hardware: write to NextReg registers without going through ports:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Original Z80 method:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD BC,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x243B"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; NextReg select port"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"21"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Register number"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"OUT"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" (C),A"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD BC,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x253B"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; NextReg data port"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"128"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"        "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Value to write"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"OUT"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" (C),A"})]}),"\n",(0,r.jsx)(n.span,{children:" "}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N method:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"NEXTREG "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"21"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:","}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"128"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"  "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Single instruction, 2 bytes shorter, faster"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["NextReg registers control Next-specific features: layer priorities, palettes, memory mapping, sprites, copper, DMA, etc. The ",(0,r.jsx)(n.code,{children:"NEXTREG"})," instruction makes accessing these dramatically more efficient."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"NEXTREG reg,A"})}),"\n",(0,r.jsx)(n.p,{children:"Variant that writes the accumulator’s value:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,(palette_value)"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"NEXTREG "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x41"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:",A      "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Write A to palette register"})]})]})}),"\n",(0,r.jsx)(n.h3,{id:s[17].id,children:s[17].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"TEST n"})}),"\n",(0,r.jsxs)(n.p,{children:["Test immediate value against accumulator (like ",(0,r.jsx)(n.code,{children:"CP"})," but with ",(0,r.jsx)(n.code,{children:"AND"})," semantics):"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"TEST"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x80"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Test if bit 7 of A is set"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"JP"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" NZ,bit_set   "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Jump if it was"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["Equivalent to ",(0,r.jsx)(n.code,{children:"AND 0x80"})," but doesn’t destroy A’s value."]}),"\n",(0,r.jsx)(n.h3,{id:s[18].id,children:s[18].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"MIRROR A"})}),"\n",(0,r.jsx)(n.p,{children:"Reverses the bit order of the accumulator:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0b10110001"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Binary 177"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"MIRROR A           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = 0b10001101 (bits reversed)"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["Why? Bitmap graphics use little-endian bit order (bit 0 = leftmost pixel), but sometimes you need to flip horizontally. ",(0,r.jsx)(n.code,{children:"MIRROR"})," does this in a single instruction instead of 8 shifts and masks."]}),"\n",(0,r.jsx)(n.h3,{id:s[19].id,children:s[19].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"MUL / MUL D,E"})}),"\n",(0,r.jsx)(n.p,{children:"The original Z80 has no multiply instruction - you write a loop:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Original Z80 - multiply D by E, result in HL:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD HL,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD B,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"8"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"loop"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:":"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL,HL"})]}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    SLA E"})}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    JR NC,skip"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    "}),(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL,DE"})]}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#FF8C42"},children:"skip:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"    DJNZ "}),(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"loop"})]}),"\n",(0,r.jsx)(n.span,{children:" "}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"MUL"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" D,E         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; HL = D * E (unsigned 8x8 = 16-bit result)"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["This is ",(0,r.jsx)(n.strong,{children:"dramatically"})," faster - the multiply completes in about 128 cycles versus 100+ for the loop version, but saves massive code space and programming complexity."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": The multiply is unsigned. For signed multiplication, you need to handle signs separately and negate the result if needed."]}),"\n",(0,r.jsx)(n.h3,{id:s[20].id,children:s[20].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ADD/ADC/SUB/SBC HL,value"})}),"\n",(0,r.jsx)(n.p,{children:"Immediate arithmetic on 16-bit register pairs:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Original Z80:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD BC,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"1000"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL,BC"})]}),"\n",(0,r.jsx)(n.span,{children:" "}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" HL,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"1000"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"     "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Directly add immediate value"})]})]})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ADD/ADC/SUB/SBC A,value"})}),"\n",(0,r.jsx)(n.p,{children:"Wait, doesn’t the Z80 already have this? Yes - but Z80N adds missing modes:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A,(HL)      "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Add memory via HL (original Z80 has this)"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A,(IX+d)    "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Add memory via IX+offset (Z80N adds this)"})]})]})}),"\n",(0,r.jsx)(n.p,{children:"Fills in gaps in the addressing mode matrix."}),"\n",(0,r.jsx)(n.h3,{id:s[21].id,children:s[21].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"LDPIRX"})}),"\n",(0,r.jsx)(n.p,{children:"Complex instruction designed for stack frame manipulation in high-level languages. It combines multiple operations:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LDPIRX          "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; DE = (HL), HL += 2, BC -= 2, repeat until BC = 0"})]})})}),"\n",(0,r.jsx)(n.p,{children:"Used in CP/M BDOS emulation and some compiler-generated code. Specialized, but useful when you need it."}),"\n",(0,r.jsx)(n.h3,{id:s[22].id,children:s[22].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SWAPNIB"})}),"\n",(0,r.jsx)(n.p,{children:"Swaps the high and low nibbles of the accumulator:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x3F"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"SWAPNIB         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = 0xF3"})]})]})}),"\n",(0,r.jsx)(n.p,{children:"Useful for BCD operations, palette color manipulation, and bit-packed data structures."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"PIXELDN / PIXELAD"})}),"\n",(0,r.jsx)(n.p,{children:"These are Next-specific operations for navigating screen memory:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"PIXELDN         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Move HL down one pixel row in screen memory"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"PIXELAD         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Move HL down one attribute row in screen memory"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:["Screen memory on the Spectrum is ",(0,r.jsx)(n.strong,{children:"not"})," linear - it’s divided into three 2KB thirds, each containing 64 character rows. Navigating vertically requires awkward arithmetic:"]}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Original Z80 - move down one pixel in screen memory:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"INC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" H           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Move to next row in same third"})]}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,H"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"AND"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" "}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x07"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"JR NZ,done      "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Still in same character row"})]}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,L"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADD"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x20"})]}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD L,A"})}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,H"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"ADC"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:" A,"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"0x00"})]}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD H,A"})}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#FF8C42"},children:"done:"})}),"\n",(0,r.jsx)(n.span,{children:" "}),"\n",(0,r.jsx)(n.span,{children:(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Z80N:"})}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"PIXELDN         "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; Single instruction"})]})]})}),"\n",(0,r.jsx)(n.h3,{id:s[23].id,children:s[23].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SETAE"})}),"\n",(0,r.jsx)(n.p,{children:"Sets the accumulator from flags in a specific pattern:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsx)(n.code,{children:(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#4A9EFF",fontWeight:"bold"},children:"SETAE"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"           "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; A = carry flag (extended to 8 bits: 0xFF if C=1, 0x00 if C=0)"})]})})}),"\n",(0,r.jsx)(n.p,{children:"Useful for branchless code and bit manipulation."}),"\n",(0,r.jsx)(n.h2,{id:s[24].id,children:s[24].value}),"\n",(0,r.jsx)(n.p,{children:"Understanding instructions is one thing; using them effectively is another. Here’s practical guidance for writing Z80N code that’s fast, compatible, and maintainable."}),"\n",(0,r.jsx)(n.h3,{id:s[25].id,children:s[25].value}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use them when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You’re writing Next-specific code that won’t run on original hardware"}),"\n",(0,r.jsx)(n.li,{children:"The speed improvement matters (multiply, NextReg access)"}),"\n",(0,r.jsx)(n.li,{children:"Code clarity improves significantly (PIXELDN vs. manual screen navigation)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Avoid them when:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You need compatibility with original Spectrum"}),"\n",(0,r.jsx)(n.li,{children:"You’re writing library code that should be portable"}),"\n",(0,r.jsx)(n.li,{children:"The benefit is marginal (one instruction vs. two with no speed gain)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:s[26].id,children:s[26].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 runs at 3.5 MHz on original Spectrum, 3.5/7/14/28 MHz on Next. Every instruction has a fixed cycle count:"}),"\n",(0,r.jsx)(n.pre,{tabIndex:"0","data-language":"asm","data-word-wrap":"",children:(0,r.jsxs)(n.code,{children:[(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,B          "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:";  4 cycles"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,(HL)       "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:";  7 cycles"})]}),"\n",(0,r.jsxs)(n.span,{children:[(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:"LD A,(IX+"}),(0,r.jsx)(n.span,{style:{color:"#4D8061"},children:"5"}),(0,r.jsx)(n.span,{style:{color:"#A4A4A4"},children:")     "}),(0,r.jsx)(n.span,{style:{color:"#6A9955"},children:"; 19 cycles (slow!)"})]})]})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Contended memory"})," adds wait states when accessing screen memory (0x4000-0x7FFF) during active display. At 3.5 MHz, this can add 0-6 cycles per memory access depending on timing. Avoid the contended region in tight loops, or use uncontended memory (0xC000+) for critical data."]}),"\n",(0,r.jsx)(n.h3,{id:s[27].id,children:s[27].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 has limited registers, so choose wisely:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"A"}),": Your workhorse accumulator; all arithmetic starts here"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HL"}),": Primary pointer; most instructions favor HL over DE/BC"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BC"}),": Loop counters, secondary pointer, port addresses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DE"}),": Data pointer, rarely as versatile as HL"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IX/IY"}),": Fixed base addresses with offsets (but slow - add 4-8 cycles vs. HL)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Alternate registers"})," (via ",(0,r.jsx)(n.code,{children:"EXX"}),"): Great for interrupt handlers and preserving state, but creates “invisible” dependencies that make debugging harder. Use sparingly in application code."]}),"\n",(0,r.jsx)(n.h2,{id:s[28].id,children:s[28].value}),"\n",(0,r.jsx)(n.p,{children:"The Z80 brought 8-bit computing to millions in the late 1970s and 1980s. Its instruction set is powerful enough for sophisticated software, yet simple enough to understand without years of study. The architecture’s limitations (64KB address space, limited registers) forced programmers to think carefully about resource usage - constraints that made better programmers."}),"\n",(0,r.jsx)(n.p,{children:"The Z80N extensions respect this legacy. They don’t fundamentally change the architecture - you’re still writing Z80 assembly,just with better tools for common operations. The original Z80 mindset still applies: every byte matters, every cycle counts, clever tricks beat brute force."}),"\n",(0,r.jsx)(n.p,{children:"For emulator builders, this means:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement the original Z80 instruction set completely and accurately"}),"\n",(0,r.jsx)(n.li,{children:"Add Z80N extensions as a separate layer that can be toggled"}),"\n",(0,r.jsx)(n.li,{children:"Track cycle counts precisely (they matter for timing-sensitive code)"}),"\n",(0,r.jsx)(n.li,{children:"Handle contended memory correctly (or document that you don’t)"}),"\n",(0,r.jsx)(n.li,{children:"Remember that real programmers are incredibly clever - anything your emulator gets wrong, someone will notice"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The Z80 and Z80N aren’t just historical curiosities. They’re living architectures with active communities writing new software today. Understanding them means understanding a design philosophy: ",(0,r.jsx)(n.strong,{children:"make the simple stuff simple, make the complex stuff possible, and trust programmers to know the difference"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"For deeper dives into specific instruction categories, see the detailed chapters on arithmetic operations, memory management, and timing-critical code. For Z80N-specific emulation notes, see the Next extensions chapter."})})]})},"/book/z80-z80n-overview",{filePath:"pages/book/z80-z80n-overview.md",timestamp:1771779014e3,pageMap:i.O,frontMatter:{},title:"The Z80 and Z80N: Processor Overview"},"undefined"==typeof RemoteContent?o:RemoteContent.useTOC)},7394:(e,s,n)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/book/z80-z80n-overview",function(){return n(5969)}])},8964:(e,s,n)=>{"use strict";n.d(s,{O:()=>r});let r=[{data:{index:"Introduction","getting-started":"Getting Started","working-with-ide":"Working with the IDE",howto:"How To","z80-assembly":"Klive Z80 Assembler",contribute:"Contribute",scripting:"Scripting","commands-reference":"Commands Reference","machine-types":"Machine Types",book:{display:"hidden"}}},{name:"book",route:"/book",children:[{name:"app-A-nex-file-format",route:"/book/app-A-nex-file-format",frontMatter:{sidebarTitle:"App a Nex File Format"}},{name:"app-B-nextreg-reference",route:"/book/app-B-nextreg-reference",frontMatter:{sidebarTitle:"App B Nextreg Reference"}},{name:"introduction",route:"/book/introduction",frontMatter:{sidebarTitle:"Introduction"}},{name:"preface",route:"/book/preface",frontMatter:{sidebarTitle:"Preface"}},{name:"using-klive-ide",route:"/book/using-klive-ide",frontMatter:{sidebarTitle:"Using Klive Ide"}},{name:"z80-z80n-overview",route:"/book/z80-z80n-overview",frontMatter:{sidebarTitle:"Z80 Z80n Overview"}}]},{name:"book",route:"/book",frontMatter:{sidebarTitle:"Book"}},{name:"commands-reference",route:"/commands-reference",frontMatter:{sidebarTitle:"Commands Reference"}},{name:"contribute",route:"/contribute",children:[{data:{"get-source":"Get the source code","improve-docs":"Improve the documentation"}},{name:"get-source",route:"/contribute/get-source",frontMatter:{sidebarTitle:"Get Source"}},{name:"improve-docs",route:"/contribute/improve-docs",frontMatter:{sidebarTitle:"Improve Docs"}}]},{name:"getting-started",route:"/getting-started",children:[{data:{installation:"Installing Klive","first-run":"Running Klive",keyboard:"Using the Keyboard",tapes:"Loading from Tape","save-programs":"Saving Files","creating-project":"Creating a Klive Project"}},{name:"creating-project",route:"/getting-started/creating-project",frontMatter:{sidebarTitle:"Creating Project"}},{name:"first-run",route:"/getting-started/first-run",frontMatter:{sidebarTitle:"First Run"}},{name:"installation",route:"/getting-started/installation",frontMatter:{sidebarTitle:"Installation"}},{name:"keyboard",route:"/getting-started/keyboard",frontMatter:{sidebarTitle:"Keyboard"}},{name:"save-programs",route:"/getting-started/save-programs",frontMatter:{sidebarTitle:"Save Programs"}},{name:"tapes",route:"/getting-started/tapes",frontMatter:{sidebarTitle:"Tapes"}}]},{name:"howto",route:"/howto",children:[{data:{"ide-startup":"IDE startup options",diagnostics:"Diagnostics",shortcuts:"Changing keyboard shortcuts","file-extensions":"Changing default file extensions","customize-syntax-colors":"Customizing syntax highlighting colors","instant-screen":"Using the Instant Screen","screen-recording":"Recording the Emulator Screen","always-on-top":"Keeping the Emulator always on top","measure-t-states":"Measuring T-states","sp48-custom-rom":"Using a Custom ROM with ZX Spectrum 48K"}},{name:"always-on-top",route:"/howto/always-on-top",frontMatter:{sidebarTitle:"Always on Top"}},{name:"customize-syntax-colors",route:"/howto/customize-syntax-colors",frontMatter:{sidebarTitle:"Customize Syntax Colors"}},{name:"diagnostics",route:"/howto/diagnostics",frontMatter:{sidebarTitle:"Diagnostics"}},{name:"file-extensions",route:"/howto/file-extensions",frontMatter:{sidebarTitle:"File Extensions"}},{name:"ide-startup",route:"/howto/ide-startup",frontMatter:{sidebarTitle:"Ide Startup"}},{name:"instant-screen",route:"/howto/instant-screen",frontMatter:{sidebarTitle:"Instant Screen"}},{name:"measure-t-states",route:"/howto/measure-t-states",frontMatter:{sidebarTitle:"Measure T States"}},{name:"screen-recording",route:"/howto/screen-recording",frontMatter:{sidebarTitle:"Screen Recording"}},{name:"shortcuts",route:"/howto/shortcuts",frontMatter:{sidebarTitle:"Shortcuts"}},{name:"sp48-custom-rom",route:"/howto/sp48-custom-rom",frontMatter:{sidebarTitle:"Sp48 Custom Rom"}}]},{name:"index",route:"/",frontMatter:{sidebarTitle:"Index"}},{name:"machine-types",route:"/machine-types",frontMatter:{sidebarTitle:"Machine Types"}},{name:"project-templates",route:"/project-templates",frontMatter:{sidebarTitle:"Project Templates"}},{name:"scripting",route:"/scripting",children:[{data:{overview:"Overview",syntax:"Scripting Syntax"}},{name:"overview",route:"/scripting/overview",frontMatter:{sidebarTitle:"Overview"}},{name:"syntax",route:"/scripting/syntax",frontMatter:{sidebarTitle:"Syntax"}}]},{name:"working-with-ide",route:"/working-with-ide",children:[{data:{"project-explorer":"The Project Explorer","editing-code":"Editing Code","run-debug":"Running & Debugging Code","exporting-code":"Exporting Code",zxb:"ZXBASIC Integration",sjasmp:"SJASMPLUS Integration","ide-settings":"IDE Settings",cpu:"The CPU View",ula:"The ULA View",memory:"The Memory View",disassembly:"The Disassembly View",watch:"Watch Expressions",breakpoints:"The Breakpoints View","system-vars":"The System Variables View",basic:"The BASIC Listing",commands:"Interactive Commands","build-system":"The Build System"}},{name:"basic",route:"/working-with-ide/basic",frontMatter:{sidebarTitle:"Basic"}},{name:"breakpoints",route:"/working-with-ide/breakpoints",frontMatter:{sidebarTitle:"Breakpoints"}},{name:"build-system",route:"/working-with-ide/build-system",frontMatter:{sidebarTitle:"Build System"}},{name:"commands",route:"/working-with-ide/commands",frontMatter:{sidebarTitle:"Commands"}},{name:"cpu",route:"/working-with-ide/cpu",frontMatter:{sidebarTitle:"Cpu"}},{name:"disassembly",route:"/working-with-ide/disassembly",frontMatter:{sidebarTitle:"Disassembly"}},{name:"editing-code",route:"/working-with-ide/editing-code",frontMatter:{sidebarTitle:"Editing Code"}},{name:"exporting-code",route:"/working-with-ide/exporting-code",frontMatter:{sidebarTitle:"Exporting Code"}},{name:"ide-settings",route:"/working-with-ide/ide-settings",frontMatter:{sidebarTitle:"Ide Settings"}},{name:"memory",route:"/working-with-ide/memory",frontMatter:{sidebarTitle:"Memory"}},{name:"project-explorer",route:"/working-with-ide/project-explorer",frontMatter:{sidebarTitle:"Project Explorer"}},{name:"run-debug",route:"/working-with-ide/run-debug",frontMatter:{sidebarTitle:"Run Debug"}},{name:"sjasmp",route:"/working-with-ide/sjasmp",frontMatter:{sidebarTitle:"Sjasmp"}},{name:"system-vars",route:"/working-with-ide/system-vars",frontMatter:{sidebarTitle:"System Vars"}},{name:"ula",route:"/working-with-ide/ula",frontMatter:{sidebarTitle:"Ula"}},{name:"watch",route:"/working-with-ide/watch",frontMatter:{sidebarTitle:"Watch"}},{name:"zxb",route:"/working-with-ide/zxb",frontMatter:{sidebarTitle:"Zxb"}}]},{name:"z80-assembly",route:"/z80-assembly",children:[{data:{"z80-assembler":"Assembler Overview","language-structure":"Language Structure",directives:"Directives",expressions:"Expressions","z80-instructions":"Z80 Instructions",pragmas:"Pragmas","zx-next":"ZX Spectrum Next",statements:"Assembler Statements",macros:"Macros",structs:"Structs"}},{name:"directives",route:"/z80-assembly/directives",frontMatter:{sidebarTitle:"Directives"}},{name:"expressions",route:"/z80-assembly/expressions",frontMatter:{sidebarTitle:"Expressions"}},{name:"language-structure",route:"/z80-assembly/language-structure",frontMatter:{sidebarTitle:"Language Structure"}},{name:"macros",route:"/z80-assembly/macros",frontMatter:{sidebarTitle:"Macros"}},{name:"pragmas",route:"/z80-assembly/pragmas",frontMatter:{sidebarTitle:"Pragmas"}},{name:"statements",route:"/z80-assembly/statements",frontMatter:{sidebarTitle:"Statements"}},{name:"structs",route:"/z80-assembly/structs",frontMatter:{sidebarTitle:"Structs"}},{name:"z80-assembler",route:"/z80-assembly/z80-assembler",frontMatter:{sidebarTitle:"Z80 Assembler"}},{name:"z80-instructions",route:"/z80-assembly/z80-instructions",frontMatter:{sidebarTitle:"Z80 Instructions"}},{name:"zx-next",route:"/z80-assembly/zx-next",frontMatter:{sidebarTitle:"Zx Next"}}]}]}},e=>{e.O(0,[1807,636,6593,8792],()=>e(e.s=7394)),_N_E=e.O()}]);